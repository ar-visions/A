# 1 "/home/kalen/src/A/src/A.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 387 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/kalen/src/A/src/A.c" 2
# 13 "/home/kalen/src/A/src/A.c"
# 1 "/home/kalen/src/A/./src/A" 1



# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 72 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 73 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 24 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 3
typedef int wchar_t;
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 107 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_max_align_t.h" 1 3
# 19 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 108 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_offsetof.h" 1 3
# 113 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 5 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 464 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 465 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3 4
# 55 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 1 3 4
# 12 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 56 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3 4
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ ));






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ )) ;




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ )) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ ));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ ));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ ));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ ));
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                         ;
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
                                                  ;
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ ));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ ));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ))
                                     ;





extern char *cuserid (char *__s)
                                     ;




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ ));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ ));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 6 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 133 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
                                           ;





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)))
                                           ;





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 286 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 380 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))

                                         ;



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ ));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ ));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ ));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 24 "/usr/include/strings.h" 2 3 4
# 34 "/usr/include/strings.h" 3 4
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                  ;



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ ));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ ));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                          ;
# 527 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 7 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 1 3
# 52 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 2 3
# 8 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3
# 60 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_list.h" 1 3
# 12 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 61 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_arg.h" 1 3
# 66 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___va_copy.h" 1 3
# 71 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_copy.h" 1 3
# 76 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3
# 9 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));




extern int isblank (int) __attribute__ ((__nothrow__ ));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ ));






extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
# 10 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/libgen.h" 1 3 4
# 26 "/usr/include/libgen.h" 3 4
extern char *dirname (char *__path) __attribute__ ((__nothrow__ ));







extern char *__xpg_basename (char *__path) __attribute__ ((__nothrow__ ));
# 11 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 227 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;
# 255 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;




typedef __pid_t pid_t;
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ ));
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ ));






extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ ));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
                                                  ;





extern ssize_t write (int __fd, const void *__buf, size_t __n)
                                         ;
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
                                                  ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
                                         ;
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
                                                  ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
                                         ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ )) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ )) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ ));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ ));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ )) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ )) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ )) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ ));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
                                       ;




extern int dup (int __fd) __attribute__ ((__nothrow__ )) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ ));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ ));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ )) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ ));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ ));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ ))
                                                  ;




extern __pid_t getpid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ ));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ ));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ ));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ ));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ ));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ ));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ ));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ ))
                                                  ;


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ ));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ )) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ )) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ ));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ ));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ )) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ )) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ ));






extern __pid_t _Fork (void) __attribute__ ((__nothrow__ ));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ ));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)))
                                                   ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ ));




extern int ttyslot (void) __attribute__ ((__nothrow__ ));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)))
                                                   ;





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)))
                                                   ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ ));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ ));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
                                                  ;




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4
# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                  ;






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ )) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                   ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern int vhangup (void) __attribute__ ((__nothrow__ ));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ ));



extern char *getusershell (void) __attribute__ ((__nothrow__ ));
extern void endusershell (void) __attribute__ ((__nothrow__ ));
extern void setusershell (void) __attribute__ ((__nothrow__ ));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ )) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ ));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ ));





extern int getpagesize (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ ));
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ )) ;
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ )) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ )) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ ));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ ));
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1124 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)))

                                          ;
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
                                          ;
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) __attribute__ ((__nothrow__ ));
# 1218 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ ));



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4
# 12 "/home/kalen/src/A/./src/A" 2
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-arch.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 36 "/usr/include/signal.h" 2 3 4
# 53 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 2 3 4



struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 54 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;

     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR,

  SEGV_MTEAERR,

  SEGV_MTESERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef union pthread_attr_t pthread_attr_t;




typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ ));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ ));



extern int raise (int __sig) __attribute__ ((__nothrow__ ));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ ));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause")
  __attribute__ ((__deprecated__ ("Use the sigsuspend function instead")));
# 173 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));
# 188 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 230 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ ));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ ));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));







extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));
# 292 "/usr/include/signal.h" 3 4
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ ));







# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 302 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ ));






# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 312 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 314 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 317 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("Use sigaction with SA_RESTART instead")));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 328 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigstksz.h" 1 3 4
# 329 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 330 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ ));




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 340 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("Use the signal function instead")));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("Use the signal and sigprocmask functions instead")));






# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};






typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 376 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ ));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ ));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ ));
# 377 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ ));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ ));





# 1 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 392 "/usr/include/signal.h" 2 3 4
# 13 "/home/kalen/src/A/./src/A" 2


typedef void none;
typedef signed char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef long long num;
typedef long long sz;
typedef unsigned int bool;
typedef float f32;
typedef double f64;
typedef long double f128;
typedef double real;
typedef void* handle;
typedef char* cstr;
typedef const char* symbol;
typedef const char* cereal;

typedef struct A* object;
typedef struct A** ARef;
typedef struct A* A;
typedef struct type_member_t* Member;

void* calloc(size_t num, size_t size);
void free();
void exit(int);
int abs(int);
cstr realpath(symbol, symbol);
FILE *popen(symbol command, symbol type);
int pclose(FILE*);
i64 strtoll(symbol str, cstr* endptr, int base);
f64 strtod (symbol str, cstr* endptr);
int system(symbol command);
int setenv(symbol key, symbol value, int);
cstr getenv(symbol key);


typedef bool(*global_init_fn)();
# 66 "/home/kalen/src/A/./src/A"
enum A_TYPE {
    A_TYPE_NONE = 0,
    A_TYPE_CONSTRUCT = 1,
    A_TYPE_PROP = 2,
    A_TYPE_PRIV = 4,
    A_TYPE_INTERN = 8,
    A_TYPE_IMETHOD = 16,
    A_TYPE_SMETHOD = 32,
    A_TYPE_OPERATOR = 64,
    A_TYPE_CAST = 128,
    A_TYPE_INDEX = 256,
    A_TYPE_ENUMV = 512,
    A_TYPE_OVERRIDE = 1024
};

enum A_TRAIT {
    A_TRAIT_PRIMITIVE = 1,
    A_TRAIT_INTEGRAL = 2,
    A_TRAIT_REALISTIC = 4,
    A_TRAIT_SIGNED = 8,
    A_TRAIT_UNSIGNED = 16,
    A_TRAIT_ENUM = 32,
    A_TRAIT_ALIAS = 64,
    A_TRAIT_ABSTRACT = 128
};
# 545 "/home/kalen/src/A/./src/A"
# 1 "/home/kalen/src/A/./src/A-type" 1



typedef struct A_f* AType;

struct type_member_t;
struct array;
struct A_f;

#pragma pack(push, 1)

typedef struct meta_t {
    int count;
    AType meta_0, meta_1, meta_2, meta_3,
                    meta_4, meta_5, meta_6, meta_7, meta_8, meta_9;
} meta_t;

typedef struct ftable_t {
    struct ftable_t* parent_type;
    char* name;
    int size;
    int member_count;
    struct type_member_t* members;
    int traits;
    AType src;
    meta_t meta;
    void* arb;
} ftable_t;

typedef struct type_member_t {
    char* name;
    AType type;
    int offset;
    int member_type;
    int operator_type;
    int required;
    meta_t args;
    void* ptr;
    void* method;
} type_member_t;

#pragma pack(pop)
# 546 "/home/kalen/src/A/./src/A" 2

typedef struct method_t {
    struct array* atypes;
    struct A_f* rtype;
    void* address;
    void* ffi_cif;
    void* ffi_args;
} method_t;
# 630 "/home/kalen/src/A/./src/A"
void A_push_type(AType type);

void A_lazy_init(global_init_fn fn);
# 777 "/home/kalen/src/A/./src/A"
void* primitive_ffi_arb(AType);
# 831 "/home/kalen/src/A/./src/A"
typedef struct string* string;
# 853 "/home/kalen/src/A/./src/A"
typedef struct A* A;
# 853 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 853 "/home/kalen/src/A/./src/A"
 typedef struct A { AType type; num refs; num ar_index; A data; num alloc; num count; A origin; struct A_f* f; } *A; none A_init(A); none A_destructor(A); i32 A_compare(A, A); u64 A_hash(A); A A_copy(A); typedef struct A_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } A_f;
# 853 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 853 "/home/kalen/src/A/./src/A"
 extern A_f A_type;

typedef struct object_f {
    struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb;
    none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A);
} object_f, *object_ft;
extern object_f object_type;




typedef struct numeric *numeric; typedef struct numeric_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } numeric_f, *numeric_ft; extern numeric_f numeric_type;


typedef struct string_like *string_like; typedef struct string_like_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } string_like_f, *string_like_ft; extern string_like_f string_like_type;


typedef struct nil *nil; typedef struct nil_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } nil_f, *nil_ft; extern nil_f nil_type;


typedef struct raw *raw; typedef struct raw_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } raw_f, *raw_ft; extern raw_f raw_type;


typedef struct ref *ref; typedef struct ref_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } ref_f, *ref_ft; extern ref_f ref_type;


typedef struct imported *imported; typedef struct imported_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } imported_f, *imported_ft; extern imported_f imported_type;
# 909 "/home/kalen/src/A/./src/A"
typedef struct i8_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } i8_f, *i8_ft; extern i8_f i8_type;
typedef struct i16_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } i16_f, *i16_ft; extern i16_f i16_type;
typedef struct i32_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } i32_f, *i32_ft; extern i32_f i32_type;
typedef struct i64_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } i64_f, *i64_ft; extern i64_f i64_type;
typedef struct u8_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } u8_f, *u8_ft; extern u8_f u8_type;
typedef struct u16_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } u16_f, *u16_ft; extern u16_f u16_type;
typedef struct u32_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } u32_f, *u32_ft; extern u32_f u32_type;
typedef struct u64_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } u64_f, *u64_ft; extern u64_f u64_type;
typedef struct f32_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } f32_f, *f32_ft; extern f32_f f32_type;
typedef struct f64_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } f64_f, *f64_ft; extern f64_f f64_type;
typedef struct f128_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } f128_f, *f128_ft; extern f128_f f128_type;
typedef struct cstr_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } cstr_f, *cstr_ft; extern cstr_f cstr_type;
typedef struct symbol_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } symbol_f, *symbol_ft; extern symbol_f symbol_type;
typedef struct cereal_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } cereal_f, *cereal_ft; extern cereal_f cereal_type;
typedef struct bool_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } bool_f, *bool_ft; extern bool_f bool_type;
typedef struct none_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } none_f, *none_ft; extern none_f none_type;
typedef struct num_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } num_f, *num_ft; extern num_f num_type;
typedef struct sz_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } sz_f, *sz_ft; extern sz_f sz_type;
typedef struct raw_t_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } raw_t_f, *raw_t_ft; extern raw_t_f raw_t_type;
typedef struct handle_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } handle_f, *handle_ft; extern handle_f handle_type;

typedef struct AType_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } AType_f, *AType_ft; extern AType_f AType_type;
typedef struct ARef_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } ARef_f, *ARef_ft; extern ARef_f ARef_type;
typedef struct Member_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } Member_f, *Member_ft; extern Member_f Member_type;
# 944 "/home/kalen/src/A/./src/A"
typedef struct item* item;
# 944 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 944 "/home/kalen/src/A/./src/A"
 typedef struct item { item next; item prev; A value; A key; struct item_f* f; } *item; typedef struct item_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } item_f, *item_ft; extern item_f item_type;
# 944 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 962 "/home/kalen/src/A/./src/A"
typedef struct list* list;
# 962 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 962 "/home/kalen/src/A/./src/A"
 typedef struct list { item first; item last; i64 count; struct list_f* f; } *list; A list_pop(list); item list_push(list, A); num list_index_of(list, A); item list_item_of(list, A); none list_remove(list, num); none list_remove_item(list, item); A list_get(list, A); num list_count(list); typedef struct list_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); A (*pop)(list); item (*push)(list, A); num (*index_of)(list, A); item (*item_of)(list, A); none (*remove)(list, num); none (*remove_item)(list, item); A (*get)(list, A); num (*count)(list); } list_f, *list_ft; extern list_f list_type;
# 962 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 973 "/home/kalen/src/A/./src/A"
typedef struct string* string;
# 1000 "/home/kalen/src/A/./src/A"
typedef enum OPType { OPType__add, OPType__sub, OPType__mul, OPType__div, OPType__or, OPType__and, OPType__xor, OPType__right, OPType__left, OPType__compare_equal, OPType__compare_not, OPType__is, OPType__inherits, OPType__assign, OPType__assign_add, OPType__assign_sub, OPType__assign_mul, OPType__assign_div, OPType__assign_or, OPType__assign_and, OPType__assign_xor, OPType__assign_right, OPType__assign_left, OPType__mod_assign, } OPType; typedef struct OPType_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(OPType); none (*destructor)(OPType); i32 (*compare)(OPType, OPType); u64 (*hash)(OPType); A (*copy)(OPType); OPType (*with_cereal)(OPType, cereal); string (*cast_string)(OPType); bool (*cast_bool)(OPType); } OPType_f, *OPType_ft; enum { OPType_ENUM_COUNT = (sizeof((int[]){1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,}) / sizeof(int)) }; extern OPType_f OPType_type;

typedef struct path* path;
# 1018 "/home/kalen/src/A/./src/A"
typedef struct file* file;
# 1018 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1018 "/home/kalen/src/A/./src/A"
 typedef struct file { path src; bool read; bool write; struct file_f* f; } *file; bool file_write(file, object); bool file_read(file, AType); none file_close(file); typedef struct file_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); bool (*write)(file, object); bool (*read)(file, AType); none (*close)(file); } file_f, *file_ft; extern file_f file_type;
# 1018 "/home/kalen/src/A/./src/A"
#pragma pack(pop)

typedef struct array* array;
# 1048 "/home/kalen/src/A/./src/A"
typedef struct path* path;
# 1048 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1048 "/home/kalen/src/A/./src/A"
 typedef struct path { cstr chars; struct path_f* f; } *path; bool path_exists(path); bool path_make_dir(path); bool path_is_empty(path); bool path_is_dir(path); path path_directory(path); string path_stem(path); string path_ext(path); string path_filename(path); path path_absolute(path); path path_parent(path); A path_read(path, AType); path path_change_ext(path, cstr); array path_ls(path, string, bool); path path_cwd(sz); typedef struct path_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); bool (*exists)(path); bool (*make_dir)(path); bool (*is_empty)(path); bool (*is_dir)(path); path (*directory)(path); string (*stem)(path); string (*ext)(path); string (*filename)(path); path (*absolute)(path); path (*parent)(path); A (*read)(path, AType); path (*change_ext)(path, cstr); array (*ls)(path, string, bool); path (*cwd)(sz); path (*with_string)(path, string); cstr (*cast_cstr)(path); sz (*cast_sz)(path); } path_f, *path_ft; extern path_f path_type;
# 1048 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1062 "/home/kalen/src/A/./src/A"
typedef struct vector* vector;
# 1062 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1062 "/home/kalen/src/A/./src/A"
 typedef struct vector { A data; i32 alloc; i32 len; AType type; struct vector_f* f; } *vector; none vector_push(vector, A); num vector_count(vector); typedef struct vector_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); none (*push)(vector, A); num (*count)(vector); } vector_f, *vector_ft; extern vector_f vector_type;
# 1062 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1072 "/home/kalen/src/A/./src/A"
typedef struct subprocedure* subprocedure;
# 1072 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1072 "/home/kalen/src/A/./src/A"
 typedef struct subprocedure { object target; object ctx; handle addr; struct subprocedure_f* f; } *subprocedure; A subprocedure_invoke(subprocedure, A); typedef struct subprocedure_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); A (*invoke)(subprocedure, A); } subprocedure_f, *subprocedure_ft; extern subprocedure_f subprocedure_type;
# 1072 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1106 "/home/kalen/src/A/./src/A"
typedef struct array* array;
# 1106 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1106 "/home/kalen/src/A/./src/A"
 typedef struct array { ARef elements; bool unmanaged; i32 alloc; i32 len; struct array_f* f; } *array; array array_of(AType, ...); array array_of_cstr(cstr, ...); A array_first(array); A array_last(array); A array_pop(array); none array_remove(array, num); none array_remove_weak(array, num); none array_push(array, A); none array_push_weak(array, A); none array_clear(array); none array_concat(array, array); A array_get(array, num); num array_count(array); sz array_len(array); num array_index_of(array, A); typedef struct array_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); array (*of)(AType, ...); array (*of_cstr)(cstr, ...); A (*first)(array); A (*last)(array); A (*pop)(array); none (*remove)(array, num); none (*remove_weak)(array, num); none (*push)(array, A); none (*push_weak)(array, A); none (*clear)(array); none (*concat)(array, array); A (*get)(array, num); num (*count)(array); sz (*len)(array); num (*index_of)(array, A); none (*operator__assign_add)(array, A); none (*operator__assign_sub)(array, num); none (*push_symbols)(array, cstr, ...); none (*push_objects)(array, A, ...); A (*index_num)(array, num); } array_f, *array_ft; extern array_f array_type;
# 1106 "/home/kalen/src/A/./src/A"
#pragma pack(pop)

typedef struct array* ATypes; typedef struct ATypes_f { struct array_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); array (*of)(AType, ...); array (*of_cstr)(cstr, ...); A (*first)(ATypes); A (*last)(ATypes); A (*pop)(ATypes); none (*remove)(ATypes, num); none (*remove_weak)(ATypes, num); none (*push)(ATypes, A); none (*push_weak)(ATypes, A); none (*clear)(ATypes); none (*concat)(ATypes, array); A (*get)(ATypes, num); num (*count)(ATypes); sz (*len)(ATypes); num (*index_of)(ATypes, A); none (*operator__assign_add)(ATypes, A); none (*operator__assign_sub)(ATypes, num); none (*push_symbols)(ATypes, cstr, ...); none (*push_objects)(ATypes, A, ...); A (*index_num)(ATypes, num); } ATypes_f, *ATypes_ft; extern ATypes_f ATypes_type;
# 1120 "/home/kalen/src/A/./src/A"
typedef struct AF* AF;
# 1120 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1120 "/home/kalen/src/A/./src/A"
 typedef struct AF { array pool; sz start_size; struct AF_f* f; } *AF; AF AF_fetch(num); AF AF_create(sz); typedef struct AF_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); AF (*fetch)(num); AF (*create)(sz); } AF_f, *AF_ft; extern AF_f AF_type;
# 1120 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1140 "/home/kalen/src/A/./src/A"
typedef struct hashmap* hashmap;
# 1140 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1140 "/home/kalen/src/A/./src/A"
 typedef struct hashmap { list data; num alloc; num count; struct hashmap_f* f; } *hashmap; none hashmap_remove(hashmap, A); none hashmap_set(hashmap, A, A); A hashmap_get(hashmap, A); item hashmap_fetch(hashmap, A); item hashmap_lookup(hashmap, A); bool hashmap_contains(hashmap, A); typedef struct hashmap_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); none (*remove)(hashmap, A); none (*set)(hashmap, A, A); A (*get)(hashmap, A); item (*fetch)(hashmap, A); item (*lookup)(hashmap, A); bool (*contains)(hashmap, A); A (*index_A)(hashmap, A); } hashmap_f, *hashmap_ft; extern hashmap_f hashmap_type;
# 1140 "/home/kalen/src/A/./src/A"
#pragma pack(pop)








typedef struct pair* pair;
# 1149 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1149 "/home/kalen/src/A/./src/A"
 typedef struct pair { item ref; A key; A value; struct pair_f* f; } *pair; typedef struct pair_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); } pair_f, *pair_ft; extern pair_f pair_type;
# 1149 "/home/kalen/src/A/./src/A"
#pragma pack(pop)

extern int fault_level;




typedef enum level { level_info, level_warn, level_err, } level; typedef struct level_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(level); none (*destructor)(level); i32 (*compare)(level, level); u64 (*hash)(level); A (*copy)(level); level (*with_cereal)(level, cereal); string (*cast_string)(level); bool (*cast_bool)(level); } level_f, *level_ft; enum { level_ENUM_COUNT = (sizeof((int[]){1, 1, 1,}) / sizeof(int)) }; extern level_f level_type;
# 1176 "/home/kalen/src/A/./src/A"
typedef struct map* map;
# 1176 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1176 "/home/kalen/src/A/./src/A"
 typedef struct map { item first; item last; i64 count; sz hsize; hashmap hmap; struct map_f* f; } *map; none map_set(map, A, A); item map_fetch(map, A); bool map_contains(map, A); none map_concat(map, map); sz map_len(map); typedef struct map_f { struct list_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); A (*pop)(list); item (*push)(list, A); num (*index_of)(list, A); item (*item_of)(list, A); none (*remove)(list, num); none (*remove_item)(list, item); A (*get)(list, A); num (*count)(list); none (*set)(map, A, A); item (*fetch)(map, A); bool (*contains)(map, A); none (*concat)(map, map); sz (*len)(map); A (*index_sz)(map, sz); A (*index_A)(map, A); } map_f, *map_ft; extern map_f map_type;
# 1176 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1187 "/home/kalen/src/A/./src/A"
typedef struct fn* fn;
# 1187 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1187 "/home/kalen/src/A/./src/A"
 typedef struct fn { A target; A context; method_t* method; struct fn_f* f; } *fn; A fn_call(fn, array); typedef struct fn_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); A (*call)(fn, array); } fn_f, *fn_ft; extern fn_f fn_type;
# 1187 "/home/kalen/src/A/./src/A"
#pragma pack(pop)
# 1217 "/home/kalen/src/A/./src/A"
typedef struct string* string;
# 1217 "/home/kalen/src/A/./src/A"
#pragma pack(push, 1)
# 1217 "/home/kalen/src/A/./src/A"
 typedef struct string { cstr chars; num alloc; num ref_length; num len; u64 h; struct string_f* f; } *string; sz string_len(string); array string_split(string, cstr); num string_index_of(string, cstr); none string_append(string, cstr); string string_mid(string, num, num); none string_reserve(string, num); none string_write(string, handle, bool); bool string_has_suffix(string, cstr); num string_cmp(string, cstr); bool string_eq(string, cstr); typedef struct string_f { struct BB_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A, A); u64 (*hash)(A); A (*copy)(A); A (*with_cereal)(A, cereal); string (*cast_string)(A); bool (*cast_bool)(A); sz (*len)(string); array (*split)(string, cstr); num (*index_of)(string, cstr); none (*append)(string, cstr); string (*mid)(string, num, num); none (*reserve)(string, num); none (*write)(string, handle, bool); bool (*has_suffix)(string, cstr); num (*cmp)(string, cstr); bool (*eq)(string, cstr); cstr (*cast_cstr)(string); sz (*cast_sz)(string); path (*cast_path)(string); string (*with_cstr)(string, cstr); i32 (*index_num)(string, num); } string_f, *string_ft; extern string_f string_type;
# 1217 "/home/kalen/src/A/./src/A"
#pragma pack(pop)


object A_formatter(AType rtype, FILE* f, bool write_ln, cstr template, ...);





typedef enum Exists { Exists_no, Exists_file, Exists_dir, } Exists; typedef struct Exists_f { struct A_f* parent_type; char* name; int size; int member_count; type_member_t* members; int traits; AType src; meta_t meta; void* arb; none (*init)(Exists); none (*destructor)(Exists); i32 (*compare)(Exists, Exists); u64 (*hash)(Exists); A (*copy)(Exists); Exists (*with_cereal)(Exists, cereal); string (*cast_string)(Exists); bool (*cast_bool)(Exists); } Exists_f, *Exists_ft; enum { Exists_ENUM_COUNT = (sizeof((int[]){1, 1, 1,}) / sizeof(int)) }; extern Exists_f Exists_type;
# 1279 "/home/kalen/src/A/./src/A"
A A_alloc(AType type, num count, bool af_pool);





string A_enum_string(AType type, i32 value);
i32 A_enum_value(AType type, cstr cs);



A A_new(AType type);
A A_construct(AType type, int n_args, ...);
A A_initialize(A a);
A A_convert(AType type, A input);
type_member_t* A_constructor(AType type, AType first_arg);
A A_instanceof(A left, AType type);
A A_hold(A a);
AType A_lookup_type(cstr);
void A_drop(A a);
sz A_len(A a);
num index_of_cstr(A a, cstr f);
Exists A_exists(A a);
num clamp(num i, num mn, num mx);
real clampf(real, real, real);
# 1312 "/home/kalen/src/A/./src/A"
map A_args(int argc, symbol argv[], map default_values, object default_key);
AF A_pool(sz size);
void A_free(A a);
A_f** A_types(num* length);
type_member_t* A_member(AType type, enum A_TYPE member_type, char* name);
A A_method_call(method_t* a, array args);
A A_method(AType type, char* method_name, array args);
A A_method_vargs(A instance, cstr method_name, int n_args, ...);
fn A_lambda(A target, type_member_t* member, A context);
A A_call(A instance, type_member_t* member, array args);
A A_primitive(AType type, void* data);
A A_enum(AType enum_type, i32 value);
A A_i8(i8);
A A_u8(u8);
A A_i16(i16);
A A_u16(u16);
A A_i32(i32);
A A_u32(u32);
A A_i64(i64);
A i(i64);
A A_sz(sz);
A A_u64(u64);
A A_f32(f32);
A A_f64(f64);
A f(f32);
A r(f64);
A A_cstr(cstr);
A A_none();
A A_bool(bool);
A A_realloc(A, num);
void A_push(A, A);
void A_start();
A A_fields(A instance);
A A_data(A instance);
A A_verify(A instance, AType type);
void A_module_init(bool(*fn)());
void debug();
void br();
bool A_reflect(symbol location);

bool is_meta(A a);
bool is_meta_compatible(A a, A b);

bool create_symlink(path target, path link);



map map_of(cstr first_key, ...);


void array_weak_push(array, A);
# 14 "/home/kalen/src/A/src/A.c" 2
# 1 "/home/kalen/src/silver-import/include/ffi.h" 1
# 84 "/home/kalen/src/silver-import/include/ffi.h"
# 1 "/home/kalen/src/silver-import/include/ffitarget.h" 1
# 78 "/home/kalen/src/silver-import/include/ffitarget.h"
typedef unsigned long ffi_arg;
typedef signed long ffi_sarg;



typedef enum ffi_abi {
# 96 "/home/kalen/src/silver-import/include/ffitarget.h"
  FFI_FIRST_ABI = 1,
  FFI_UNIX64,
  FFI_WIN64,
  FFI_EFI64 = FFI_WIN64,
  FFI_GNUW64,
  FFI_LAST_ABI,
  FFI_DEFAULT_ABI = FFI_UNIX64
# 127 "/home/kalen/src/silver-import/include/ffitarget.h"
} ffi_abi;
# 85 "/home/kalen/src/silver-import/include/ffi.h" 2







# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 93 "/home/kalen/src/silver-import/include/ffi.h" 2
# 1 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 1 3
# 21 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern long int __sysconf (int __name) __attribute__ ((__nothrow__ ));
# 82 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 22 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 2 3
# 94 "/home/kalen/src/silver-import/include/ffi.h" 2
# 129 "/home/kalen/src/silver-import/include/ffi.h"
typedef struct _ffi_type
{
  size_t size;
  unsigned short alignment;
  unsigned short type;
  struct _ffi_type **elements;
} ffi_type;
# 211 "/home/kalen/src/silver-import/include/ffi.h"
extern ffi_type ffi_type_void;
extern ffi_type ffi_type_uint8;
extern ffi_type ffi_type_sint8;
extern ffi_type ffi_type_uint16;
extern ffi_type ffi_type_sint16;
extern ffi_type ffi_type_uint32;
extern ffi_type ffi_type_sint32;
extern ffi_type ffi_type_uint64;
extern ffi_type ffi_type_sint64;
extern ffi_type ffi_type_float;
extern ffi_type ffi_type_double;
extern ffi_type ffi_type_pointer;
extern ffi_type ffi_type_longdouble;


extern ffi_type ffi_type_complex_float;
extern ffi_type ffi_type_complex_double;
extern ffi_type ffi_type_complex_longdouble;



typedef enum {
  FFI_OK = 0,
  FFI_BAD_TYPEDEF,
  FFI_BAD_ABI,
  FFI_BAD_ARGTYPE
} ffi_status;

typedef struct {
  ffi_abi abi;
  unsigned nargs;
  ffi_type **arg_types;
  ffi_type *rtype;
  unsigned bytes;
  unsigned flags;



} ffi_cif;
# 265 "/home/kalen/src/silver-import/include/ffi.h"
typedef union {
  ffi_sarg sint;
  ffi_arg uint;
  float flt;
  char data[8];
  void* ptr;
} ffi_raw;
# 284 "/home/kalen/src/silver-import/include/ffi.h"
typedef ffi_raw ffi_java_raw;




void ffi_raw_call (ffi_cif *cif,
     void (*fn)(void),
     void *rvalue,
     ffi_raw *avalue);

        void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
        void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
        size_t ffi_raw_size (ffi_cif *cif);







void ffi_java_raw_call (ffi_cif *cif,
   void (*fn)(void),
   void *rvalue,
   ffi_java_raw *avalue) __attribute__((deprecated));



void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));

void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));

size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));
# 324 "/home/kalen/src/silver-import/include/ffi.h"
typedef struct {




  union {
    char tramp[32];
    void *ftramp;
  };

  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
  void *user_data;



} ffi_closure

    __attribute__((aligned (8)))

    ;







        void *ffi_closure_alloc (size_t size, void **code);
        void ffi_closure_free (void *);

        ffi_status
ffi_prep_closure (ffi_closure*,
    ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*),
    void *user_data)



  __attribute__((deprecated))

  ;

        ffi_status
ffi_prep_closure_loc (ffi_closure*,
        ffi_cif *,
        void (*fun)(ffi_cif*,void*,void**,void*),
        void *user_data,
        void *codeloc);




typedef struct {




  char tramp[32];

  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_raw*,void*);
  void *user_data;

} ffi_raw_closure;

typedef struct {




  char tramp[32];


  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
  void *user_data;

} ffi_java_raw_closure;

        ffi_status
ffi_prep_raw_closure (ffi_raw_closure*,
        ffi_cif *cif,
        void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
        void *user_data);

        ffi_status
ffi_prep_raw_closure_loc (ffi_raw_closure*,
     ffi_cif *cif,
     void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
     void *user_data,
     void *codeloc);


        ffi_status
ffi_prep_java_raw_closure (ffi_java_raw_closure*,
             ffi_cif *cif,
             void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
             void *user_data) __attribute__((deprecated));

        ffi_status
ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
          ffi_cif *cif,
          void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
          void *user_data,
          void *codeloc) __attribute__((deprecated));






typedef struct {
  void *tramp;
  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
} ffi_go_closure;

        ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*));

        void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
    void **avalue, void *closure);






ffi_status ffi_prep_cif(ffi_cif *cif,
   ffi_abi abi,
   unsigned int nargs,
   ffi_type *rtype,
   ffi_type **atypes);


ffi_status ffi_prep_cif_var(ffi_cif *cif,
       ffi_abi abi,
       unsigned int nfixedargs,
       unsigned int ntotalargs,
       ffi_type *rtype,
       ffi_type **atypes);


void ffi_call(ffi_cif *cif,
       void (*fn)(void),
       void *rvalue,
       void **avalue);


ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
       size_t *offsets);
# 15 "/home/kalen/src/A/src/A.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 40 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
typedef __dev_t dev_t;
# 51 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
typedef __ino_t ino_t;







typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 86 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
typedef __blkcnt_t blkcnt_t;







typedef __blksize_t blksize_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
struct stat
  {



    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 74 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 89 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 99 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
  };



struct stat64
  {



    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 151 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];




  };
# 26 "/usr/include/x86_64-linux-gnu/bits/stat.h" 2 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 264 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 291 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 313 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ ));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ ));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ ));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 452 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ ));
# 465 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 stx_mnt_id;
 __u64 __spare2;

 __u64 __spare3[12];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 5)));
# 40 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 466 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 16 "/home/kalen/src/A/src/A.c" 2
# 1 "/usr/include/dirent.h" 1 3 4
# 41 "/usr/include/dirent.h" 3 4
typedef __ino64_t ino64_t;
# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 173 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
  __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 255 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 278 "/usr/include/dirent.h" 3 4
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
# 293 "/usr/include/dirent.h" 3 4
extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 315 "/usr/include/dirent.h" 3 4
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));




extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 353 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));






extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





# 1 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h" 3 4
extern __ssize_t getdents64 (int __fd, void *__buffer, size_t __length)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 405 "/usr/include/dirent.h" 2 3 4
# 17 "/home/kalen/src/A/src/A.c" 2
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 18 "/home/kalen/src/A/src/A.c" 2

__thread array af_stack;
__thread AF af_top;

static global_init_fn* call_after;
static num call_after_alloc;
static num call_after_count;

void A_lazy_init(global_init_fn fn) {
    if (call_after_count == call_after_alloc) {
        global_init_fn* prev = call_after;
        num alloc_prev = call_after_alloc;
        call_after_alloc = 32 + (call_after_alloc << 1);
        call_after = calloc(call_after_alloc, sizeof(global_init_fn));
        if (prev) {
            memcpy(call_after, prev, sizeof(global_init_fn) * alloc_prev);
            free(prev);
        }
    }
    call_after[call_after_count++] = fn;
}

static global_init_fn* call_last;
static num call_last_alloc;
static num call_last_count;

cstr copy_cstr(cstr input) {
    sz len = strlen(input);
    cstr res = calloc(len + 1, 1);
    memcpy(res, input, len);
    return res;
}

void A_module_init(bool(*fn)()) {

    if (call_last_count == call_last_alloc) {
        global_init_fn* prev = call_last;
        num alloc_prev = call_last_alloc;
        call_last_alloc = 32 + (call_last_alloc << 1);
        call_last = calloc(call_last_alloc, sizeof(global_init_fn));
        if (prev) {
            memcpy(call_last, prev, sizeof(global_init_fn) * alloc_prev);
            free(prev);
        }
    }
    call_last[call_last_count++] = fn;
}

static A_f** types;
static num types_alloc;
static num types_len;

void A_push_type(AType type) {
    if (types_alloc == types_len) {
        A_f** prev = types;
        num alloc_prev = types_alloc;
        types_alloc = 128 + (types_alloc << 1);
        types = calloc(types_alloc, sizeof(A_f*));
        if (alloc_prev) {
            memcpy(types, prev, sizeof(A_f*) * alloc_prev);
            free(prev);
        }
    }
    types[types_len++] = type;
}



A A_validate_type(A instance, AType type) {
    if (!instance) return ((void*)0);
    AType itype = (instance ? (struct A_f*)((struct A*)instance - 1)->type : (struct A_f*)0);
    do {
        if (itype == type)
            return instance;
        type = type->parent_type;
    } while (type && type != ((AType)&A_type));
    return ((void*)0);
}

A_f** A_types(num* length) {
    *length = types_len;
    return types;
}

AType A_find_type(cstr name) {
    for (int i = 0; i < types_len; i++) {
        AType type = types[i];
        if (strcmp(type->name, name) == 0)
            return type;
    }
    return ((void*)0);
}

A A_new(AType type) {
    A res = A_alloc(type, 1, (bool)1);

    return res;
}

static void A_validator(A a) {
    AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    for (num i = 0; i < type->member_count; i++) {
        type_member_t* m = &type->members[i];
        if (m->required) {
            u8* ptr = (u8*)a + m->offset;
            A* ref = ptr;
            do { if (!(*ref)) { A_formatter(((void*)0), stderr, (bool)1, "required arg [%s] not set for class %s", m->name, type->name); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
        }
    }
}

i32 A_enum_value(AType type, cstr cs) {
    int cur = 0;
    for (num m = 0; m < type->member_count; m++) {
        type_member_t* mem = &type->members[m];
        if (mem->member_type & A_TYPE_ENUMV) {
            if (strcmp(cs, mem->name) == 0)
                return cur;
            cur++;
        }
    }
    do { A_formatter(((void*)0), stderr, (bool)1, "enum not found"); exit(1); } while(0);
    return -1;
}

string A_enum_string(AType type, i32 value) {
    int cur = 0;
    for (num m = 0; m < type->member_count; m++) {
        type_member_t* mem = &type->members[m];
        if (mem->member_type & A_TYPE_ENUMV) {
            if (cur == value)
                return string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)(mem->name));
            cur++;
        }
    }
    do { A_formatter(((void*)0), stderr, (bool)1, "invalid enum-value of %i for type %s", value, type->name); exit(1); } while(0);
    return ((void*)0);
}

void debug() {
    return;
}

void A_init_recur(A a, AType current, raw last_init) {
    if (current == &A_type) return;
    void(*init)(A) = ((A_f*)current)->init;
    A_init_recur(a, current->parent_type, init);
    if (init) init(a);
}

A A_initialize(A a) {
    A f = A_fields(a);


    A_validator(a);


    A_init_recur(a, f->type, ((void*)0));
    return a;
}

A A_alloc(AType type, num count, bool af_pool) {
    sz map_sz = sizeof(map);
    sz A_sz = sizeof(struct A);

    A a = calloc(1, sizeof(struct A) + type->size * count);
    a->refs = af_pool ? 0 : 1;
    a->type = type;
    a->origin = a;
    a->data = &a[1];
    a->count = count;
    a->alloc = count;
    if (af_pool) {
        a->ar_index = af_top->pool->len;
        ((__typeof__((af_top->pool)->f)) ((A)(af_top->pool))[-1].type) -> push(af_top->pool, a->data);
    } else {
        a->ar_index = 0;
    }
    return a->data;
}


A A_realloc(A a, num alloc) {
    A obj = A_fields(a);
    do { if (!(obj->type->traits == A_TRAIT_PRIMITIVE)) { A_formatter(((void*)0), stderr, (bool)1, "realloc must be called on a primitive type"); exit(1); } } while(0);
    A re = calloc(1, sizeof(struct A) + obj->type->size * alloc);
    num count = obj->count < alloc ? obj->count : alloc;
    memcpy(&re[1], obj->data, obj->type->size * count);
    if (obj->data != &obj[1])
        free(&obj->data[-1]);
    re->origin = obj;
    obj->data = &re[1];
    obj->count = count;
    obj->alloc = alloc;
    return obj->data;
}

void A_push(A a, A value) {
    A obj = A_fields(a);
    do { if (!(obj->type->traits == A_TRAIT_PRIMITIVE)) { A_formatter(((void*)0), stderr, (bool)1, "must be called on a primitive type"); exit(1); } } while(0);
    num sz = obj->type->size;
    if (obj->count == obj->alloc)
        A_realloc(a, 32 + (obj->alloc << 1));
    memcpy(&((u8*)obj->data)[obj->count++ * sz], value, sz);
}





void array_alloc_sz(array a, sz alloc) {
    A* elements = (A*)calloc(alloc, sizeof(struct A*));
    memcpy(elements, a->elements, sizeof(struct A*) * a->len);

    free(a->elements);
    a->elements = elements;
    a->alloc = alloc;
}

void array_expand(array a) {
    num alloc = 32 + (a->alloc << 1);
    array_alloc_sz(a, alloc);
}

void array_push_weak(array a, A b) {
    if (a->alloc == a->len) {
        array_expand(a);
    }
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (is_meta(a))
        do { if (!(is_meta_compatible(a, b))) { A_formatter(((void*)0), stderr, (bool)1, "not meta compatible"); exit(1); } } while(0);
    a->elements[a->len++] = b;
}

method_t* method_with_address(handle address, AType rtype, array atypes, AType method_owner) {
    const num max_args = (sizeof(meta_t) - sizeof(num)) / sizeof(AType);
    method_t* method = calloc(1, sizeof(method_t));
    method->ffi_cif = calloc(1, sizeof(ffi_cif));
    method->ffi_args = calloc(max_args, sizeof(ffi_type*));
    method->atypes = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)0); ; A_initialize(instance); instance; });
    method->rtype = rtype;
    method->address = address;

    ffi_type **ffi_args = (ffi_type**)method->ffi_args;
    for (num i = 0; i < atypes->len; i++) {
        A_f* a_type = atypes->elements[i];
        bool is_prim = a_type->traits & A_TRAIT_PRIMITIVE;
        ffi_args[i] = is_prim ? a_type->arb : &ffi_type_pointer;
        ((__typeof__((method->atypes)->f)) ((A)(method->atypes))[-1].type) -> push_weak(method->atypes, a_type);
    }
    ffi_status status = ffi_prep_cif(
        (ffi_cif*) method->ffi_cif, FFI_DEFAULT_ABI, atypes->len,
        (ffi_type*)((rtype->traits & A_TRAIT_ABSTRACT) ? method_owner->arb : rtype->arb), ffi_args);
    do { if (!(status == FFI_OK)) { A_formatter(((void*)0), stderr, (bool)1, "status == %i", (i32)status); exit(1); } } while(0);
    return method;
}


fn A_lambda(A target, Member member, A context) {
    fn f = ({ fn instance = (fn)A_alloc(((AType)&fn_type), 1, (bool)1); instance->method = member->method; instance->target = target; instance->context = context;; A_initialize(instance); instance; });



    return f;
}

A A_method_call(method_t* a, array args) {
    const num max_args = 8;
    void* arg_values[max_args];
    do { if (!(args->len == a->atypes->len)) { A_formatter(((void*)0), stderr, (bool)1, "arg count mismatch"); exit(1); } } while(0);
    for (num i = 0; i < args->len; i++) {
        A_f* arg_type = a->atypes->elements[i];
        arg_values[i] = (arg_type->traits & (A_TRAIT_PRIMITIVE | A_TRAIT_ENUM)) ?
            (void*)args->elements[i] : (void*)&args->elements[i];
    }
    void* result[8];
    ffi_call((ffi_cif*)a->ffi_cif, a->address, result, arg_values);
    if (a->rtype->traits & A_TRAIT_PRIMITIVE)
        return A_primitive(a->rtype, result);
    else if (a->rtype->traits & A_TRAIT_ENUM)
        return A_enum(a->rtype, *(i32*)result);
    else
        return (A) result[0];
}


A A_method(AType type, cstr method_name, array args) {
    type_member_t* mem = A_member(type, A_TYPE_IMETHOD | A_TYPE_SMETHOD, method_name);
    do { if (!(mem->method)) { A_formatter(((void*)0), stderr, (bool)1, "method not set"); exit(1); } } while(0);
    method_t* m = mem->method;
    A res = A_method_call(m, args);
    return res;
}

A A_convert(AType type, A input) {
    if (type == (input ? (struct A_f*)((struct A*)input - 1)->type : (struct A_f*)0)) return input;
    do { if (!((bool)0)) { A_formatter(((void*)0), stderr, (bool)1, "not implemented"); exit(1); } } while(0);
    return input;
}

A A_method_vargs(A instance, cstr method_name, int n_args, ...) {
    AType type = (instance ? (struct A_f*)((struct A*)instance - 1)->type : (struct A_f*)0);
    type_member_t* mem = A_member(type, A_TYPE_IMETHOD | A_TYPE_SMETHOD, method_name);
    do { if (!(mem->method)) { A_formatter(((void*)0), stderr, (bool)1, "method not set"); exit(1); } } while(0);
    method_t* m = mem->method;
    va_list vargs;
    __builtin_va_start(vargs, n_args);
    array args = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)1); instance->alloc = n_args + 1;; A_initialize(instance); instance; });
    ((__typeof__((args)->f)) ((A)(args))[-1].type) -> push(args, instance);
    for (int i = 0; i < n_args; i++) {
        A arg = __builtin_va_arg(vargs, A);
        ((__typeof__((args)->f)) ((A)(args))[-1].type) -> push(args, arg);
    }
    __builtin_va_end(vargs);
    A res = A_method_call(m, args);
    return res;
}


int fault_level;

void A_start() {
    fault_level = level_err;

    AF pool = ({ AF instance = (AF)A_alloc(((AType)&AF_type), 1, (bool)0); ; A_initialize(instance); instance; });

    int remaining = call_after_count;
    while (remaining)
        for (int i = 0; i < call_after_count; i++) {
            global_init_fn fn = call_after[i];
            if (fn && fn()) {
                call_after[i] = ((void*)0);
                remaining--;
            }
        }

    remaining = call_last_count;
    while (remaining)
        for (int i = 0; i < call_last_count; i++) {
            global_init_fn fn = call_last[i];
            if (fn && fn()) {
                call_last[i] = ((void*)0);
                remaining--;
            }
        }

    num types_len;
    A_f** types = A_types(&types_len);
    const num max_args = 8;


    for (num i = 0; i < types_len; i++) {
        A_f* type = types[i];
        if (type->traits & A_TRAIT_ABSTRACT) continue;

        for (num m = 0; m < type->member_count; m++) {
            type_member_t* mem = &type->members[m];
            if (mem->member_type & (A_TYPE_IMETHOD | A_TYPE_SMETHOD)) {
                void* address = 0;
                memcpy(&address, &((u8*)type)[mem->offset], sizeof(void*));
                do { if (!(address)) { A_formatter(((void*)0), stderr, (bool)1, "no address"); exit(1); } } while(0);
                array args = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)0); instance->alloc = mem->args.count;; A_initialize(instance); instance; });
                for (num i = 0; i < mem->args.count; i++)
                    args->elements[i] = ((A_f**)&mem->args.meta_0)[i];
                args->len = mem->args.count;
                mem->method = method_with_address(address, mem->type, args, type);
            }
        }
    }
}

type_member_t* A_member(AType type, enum A_TYPE member_type, char* name) {
    for (num i = 0; i < type->member_count; i++) {
        type_member_t* mem = &type->members[i];
        if (mem->member_type & member_type && strcmp(mem->name, name) == 0)
            return mem;
    }
    return 0;
}

type_member_t* A_hold_members(A instance) {
    AType type = (instance ? (struct A_f*)((struct A*)instance - 1)->type : (struct A_f*)0);
    for (num i = 0; i < type->member_count; i++) {
        type_member_t* mem = &type->members[i];
        A *mdata = (A*)((cstr)instance + mem->offset);
        if (*mdata && mem->member_type & (A_TYPE_PROP | A_TYPE_PRIV | A_TYPE_INTERN))
            if (!(mem->type->traits & A_TRAIT_PRIMITIVE))
                A_hold(*mdata);
    }
    return 0;
}

A A_set_property(A instance, symbol name, A value) {
    AType type = (instance ? (struct A_f*)((struct A*)instance - 1)->type : (struct A_f*)0);
    type_member_t* m = A_member(type, (A_TYPE_PROP | A_TYPE_PRIV | A_TYPE_INTERN), (cstr)name);
    do { if (!(m)) { A_formatter(((void*)0), stderr, (bool)1, "%s not found on object %s", name, type->name); exit(1); } } while(0);
    A *mdata = (A*)((cstr)instance + m->offset);
    A prev = *mdata;
    *mdata = A_hold(value);
    A_drop(prev);
    return value;
}





map A_args(int argc, symbol argv[], map default_values, object default_key) {
    map result = ({ map instance = (map)A_alloc(((AType)&map_type), 1, (bool)1); instance->hsize = 16;; A_initialize(instance); instance; });
    for (item ii = default_values->first; ii; ii = ii->next) {
        pair hm = ii->value;
        object k = hm->key;
        object v = hm->value;
        ((__typeof__((result)->f)) ((A)(result))[-1].type) -> set(result, k, v);
    }
    int i = 1;
    bool found_single = (bool)0;
    while (i < argc + 1) {
        symbol arg = argv[i];
        if (!arg) {
            i++;
            continue;
        }
        if (arg[0] == '-') {

            bool doub = arg[1] == '-';
            string s_key = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = (cstr)&arg[doub + 1];; A_initialize(instance); instance; });
            string s_val = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = (cstr)argv[i + 1];; A_initialize(instance); instance; });

            for (item f = default_values->first; f; f = f->next) {

                pair mi = (pair) f->value;
                object def_value = mi->value;
                AType def_type = def_value ? (def_value ? (struct A_f*)((struct A*)def_value - 1)->type : (struct A_f*)0) : ((AType)&string_type);
                do { if (!(f->key == mi->key)) { A_formatter(((void*)0), stderr, (bool)1, "keys do not match"); exit(1); } } while(0);
                if ((!doub && strncmp(((string)f->key)->chars, s_key->chars, 1) == 0) ||
                    ( doub && ((__typeof__((f->key)->f)) ((A)(f->key))[-1].type) -> compare(f->key, s_key) == 0)) {


                    object value = A_formatter(def_type, ((void*)0), (bool)0, "%o", s_val);
                    do { if (!((value ? (struct A_f*)((struct A*)value - 1)->type : (struct A_f*)0) == def_type)) { A_formatter(((void*)0), stderr, (bool)1, ""); exit(1); } } while(0);
                    ((__typeof__((result)->f)) ((A)(result))[-1].type) -> set(result, f->key, value);
                }
            }
        } else if (!found_single && default_key) {
            A default_key_obj = A_fields(default_key);
            string s_val = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = (cstr)arg;; A_initialize(instance); instance; });
            object def_value = ((__typeof__((default_values)->f)) ((A)(default_values))[-1].type) -> get(default_values, default_key);
            AType def_type = (def_value ? (struct A_f*)((struct A*)def_value - 1)->type : (struct A_f*)0);
            object value = A_formatter(def_type, ((void*)0), (bool)0, "%o", s_val);
            ((__typeof__((result)->f)) ((A)(result))[-1].type) -> set(result, default_key, value);
            found_single = (bool)1;
        }
        i += 2;
    }
    return result;
}





A A_primitive(AType type, void* data) {
    do { if (!(type->traits & A_TRAIT_PRIMITIVE)) { A_formatter(((void*)0), stderr, (bool)1, "must be primitive"); exit(1); } } while(0);
    A copy = A_alloc(type, type->size, (bool)1);
    memcpy(copy, data, type->size);
    return copy;
}

A A_enum(AType type, i32 data) {
    do { if (!(type->traits & A_TRAIT_ENUM)) { A_formatter(((void*)0), stderr, (bool)1, "must be enum"); exit(1); } } while(0);
    do { if (!(type->size == sizeof(i32))) { A_formatter(((void*)0), stderr, (bool)1, "enum size invalid"); exit(1); } } while(0);
    A copy = A_alloc(type, type->size, (bool)1);
    memcpy(copy, &data, type->size);
    return copy;
}

A A_i8(i8 data) { return A_primitive(&i8_type, &data); }
A A_u8(u8 data) { return A_primitive(&u8_type, &data); }
A A_i16(i16 data) { return A_primitive(&i16_type, &data); }
A A_u16(u16 data) { return A_primitive(&u16_type, &data); }
A A_i32(i32 data) { return A_primitive(&i32_type, &data); }
A A_u32(u32 data) { return A_primitive(&u32_type, &data); }
A A_i64(i64 data) { return A_primitive(&i64_type, &data); }
A i(i64 data) { return A_primitive(&i64_type, &data); }
A A_sz (sz data) { return A_primitive(&sz_type, &data); }
A A_u64(u64 data) { return A_primitive(&u64_type, &data); }
A A_f32(f32 data) { return A_primitive(&f32_type, &data); }
A A_f64(f64 data) { return A_primitive(&f64_type, &data); }
A A_f128(f64 data) { return A_primitive(&f128_type, &data); }
A f(f32 data) { return A_primitive(&f32_type, &data); }
A r(f64 data) { return A_primitive(&f64_type, &data); }
A A_cstr(cstr data) { return A_primitive(&cstr_type, &data); }
A A_none() { return A_primitive(&none_type, ((void*)0)); }
A A_bool(bool data) { return A_primitive(&bool_type, &data); }


void A_init(A a) { }
void A_destructor(A a) {





    AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    for (num i = 0; i < type->member_count; i++) {
        type_member_t* m = &type->members[i];
        if ((m->member_type == A_TYPE_PROP || m->member_type == A_TYPE_PRIV) && !(m->type->traits & A_TRAIT_PRIMITIVE)) {
            u8* ptr = (u8*)a + m->offset;
            A* ref = ptr;
            A_drop(*ref);
            *ref = ((void*)0);
        }
    }
}
u64 A_hash (A a) { return (u64)(size_t)a; }
bool A_cast_bool (A a) { return (bool)(size_t)a; }

A A_with_cereal(A a, cereal cs) {
    sz len = strlen(cs);
    A f = A_fields(a);
    AType type = f->type;
    if (type == ((AType)&f64_type)) sscanf(cs, "%lf", (f64*)a);
    else if (type == ((AType)&f32_type)) sscanf(cs, "%f", (f32*)a);
    else if (type == ((AType)&i32_type)) sscanf(cs, "%i", (i32*)a);
    else if (type == ((AType)&u32_type)) sscanf(cs, "%u", (u32*)a);
    else if (type == ((AType)&i64_type)) sscanf(cs, "%lli", (i64*)a);
    else if (type == ((AType)&u64_type)) sscanf(cs, "%llu", (u64*)a);
    else if (type == ((AType)&string_type)) {
        string res = a;
        sz a_ln = len > -1 ? len : strlen(cs);
        res->chars = calloc(a_ln + 1, 1);
        res->len = a_ln;
        memcpy(res->chars, cs, a_ln);
        return res;
    }
    else {
        printf("implement ctr cstr for %s\n", f->type->name);
        exit(-1);
    }
    return a;
}

void A_serialize(AType type, string res, A a) {

    if (type->traits & A_TRAIT_PRIMITIVE) {
        char buf[128];
        int len = 0;
        if (type == ((AType)&i64_type)) len = sprintf(buf, "%lld", *(i64*)a);
        else if (type == ((AType)&num_type)) len = sprintf(buf, "%lld", *(i64*)a);
        else if (type == ((AType)&i32_type)) len = sprintf(buf, "%d", *(i32*)a);
        else if (type == ((AType)&i16_type)) len = sprintf(buf, "%hd", *(i16*)a);
        else if (type == ((AType)&i8_type)) len = sprintf(buf, "%hhd", *(i8*) a);
        else if (type == ((AType)&u64_type)) len = sprintf(buf, "%llu", *(u64*)a);
        else if (type == ((AType)&u32_type)) len = sprintf(buf, "%u", *(u32*)a);
        else if (type == ((AType)&u16_type)) len = sprintf(buf, "%hu", *(u16*)a);
        else if (type == ((AType)&u8_type)) len = sprintf(buf, "%hhu", *(u8*) a);
        else if (type == ((AType)&f128_type)) len = sprintf(buf, "%f", (f64)*(f128*)a);
        else if (type == ((AType)&f64_type)) len = sprintf(buf, "%f", *(f64*)a);
        else if (type == ((AType)&f32_type)) len = sprintf(buf, "%f", *(f32*)a);
        else if (type == ((AType)&cstr_type)) len = sprintf(buf, "%s", *(cstr*)a);
        else {
            do { A_formatter(((void*)0), stderr, (bool)1, "implement primitive cast to str: %s", type->name); exit(1); } while(0);
        }
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, buf);
    } else {
        string s = ((__typeof__((a)->f)) ((A)(a))[-1].type) -> cast_string(a);
        if (s) {
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, "\"");
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, s->chars);
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, "\"");
        } else
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, "null");
    }
}

string A_cast_string(A a) {
    AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (type == ((AType)&string_type))
        return a;
    bool once = (bool)0;
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 1024;; A_initialize(instance); instance; });
    if (type->traits & A_TRAIT_PRIMITIVE)
        A_serialize(type, res, a);
    else {
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, type->name);
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, "[");
        for (num i = 0; i < type->member_count; i++) {
            type_member_t* m = &type->members[i];

            if (m->member_type & (A_TYPE_PROP | A_TYPE_PRIV | A_TYPE_INTERN)) {
                if (once)
                    ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, " ");
                u8* ptr = (u8*)a + m->offset;
                ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, m->name);
                ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, ":");
                A_serialize(m->type, res, ptr);
                once = (bool)1;
            }
        }
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, "]");
    }
    return res;
}
# 637 "/home/kalen/src/A/src/A.c"
A numeric_with_i8 (A a, i8 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_i16(A a, i16 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_i32(A a, i32 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_i64(A a, i64 v) {
    AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (type == ((AType)&i8_type)) *(i8*) a = (i8) v;
    if (type == ((AType)&i16_type)) *(i16*)a = (i16)v;
    if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;
# 653 "/home/kalen/src/A/src/A.c"
}
A numeric_with_u8 (A a, u8 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_u16(A a, u16 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_u32(A a, u32 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_u64(A a, u64 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_f32(A a, f32 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_f64(A a, f64 v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_bool(A a, bool v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }
A numeric_with_num(A a, num v) { AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0); if (type == ((AType)&i8_type)) *(i8*) a = (i8) v; if (type == ((AType)&i16_type)) *(i16*)a = (i16)v; if (type == ((AType)&i32_type)) *(i32*)a = (i32)v; if (type == ((AType)&i64_type)) *(i64*)a = (i64)v; if (type == ((AType)&u8_type)) *(u8*) a = (u8) v; if (type == ((AType)&u16_type)) *(u16*)a = (u16)v; if (type == ((AType)&u32_type)) *(u32*)a = (u32)v; if (type == ((AType)&u64_type)) *(u64*)a = (u64)v; if (type == ((AType)&f32_type)) *(f32*)a = (f32)v; if (type == ((AType)&f64_type)) *(f64*)a = (f64)v; return a;; }

A A_method(AType type, cstr method_name, array args);

sz A_len(A a) {
    if (!a) return 0;
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (t == ((AType)&string_type)) return ((string)a)->len;
    if (t == ((AType)&array_type)) return ((array) a)->len;
    if (t == ((AType)&map_type)) return ((map)a)->count;
    if (t == ((AType)&cstr_type) || t == ((AType)&symbol_type) || t == ((AType)&cereal_type))
        return strlen(a);
    do { A_formatter(((void*)0), stderr, (bool)1, "len not handled for type %s", t->name); exit(1); } while(0);
    return 0;
}

num index_of_cstr(A a, cstr f) {
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (t == ((AType)&string_type)) return ((__typeof__(((string)a)->f)) ((A)((string)a))[-1].type) -> index_of((string)a, f);
    if (t == ((AType)&array_type)) return ((__typeof__(((array)a)->f)) ((A)((array)a))[-1].type) -> index_of((array)a, string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)(f)));
    if (t == ((AType)&cstr_type) || t == ((AType)&symbol_type) || t == ((AType)&cereal_type)) {
        cstr v = strstr(a, f);
        return v ? (num)(v - f) : (num)-1;
    }
    do { A_formatter(((void*)0), stderr, (bool)1, "len not handled for type %s", t->name); exit(1); } while(0);
    return 0;
}

Exists A_exists(A o) {
    AType type = (o ? (struct A_f*)((struct A*)o - 1)->type : (struct A_f*)0);
    path f = ((void*)0);
    if (type == ((AType)&string_type))
        f = ((__typeof__(((string)o)->f)) ((A)((string)o))[-1].type) -> cast_path((string)o);
    else if (type == ((AType)&path_type))
        f = o;
    do { if (!(f)) { A_formatter(((void*)0), stderr, (bool)1, "type not supported"); exit(1); } } while(0);
    bool is_dir = ((__typeof__((f)->f)) ((A)(f))[-1].type) -> is_dir(f);
    bool r = ((__typeof__((f)->f)) ((A)(f))[-1].type) -> exists(f);
    if (is_dir)
        return r ? Exists_dir : Exists_no;
    else
        return r ? Exists_file : Exists_no;
}


i32 A_compare(A a, A b) {
    return (i32)((sz)(void*)a - (sz)(void*)b);
}

num parse_formatter(cstr start, cstr res, num sz) {
    cstr scan = start;
    num index = 0;
    if (*scan == '%') {
        if (index < sz - 1)
            res[index++] = *scan++;
        while (*scan) {
            if (strchr("diouxXeEfFgGaAcspn%", *scan)) {
                if (index < sz - 1) res[index++] = *scan++;
                break;
            } else if (strchr("0123456789.-+lhjztL*", *scan)) {
                if (index < sz - 1) res[index++] = *scan++;
            } else
                break;
        }
    }
    res[index] = 0;
    return (num)(scan - start);
}


object A_formatter(AType type, FILE* f, bool write_ln, cstr template, ...) {
    va_list args;
    __builtin_va_start(args, template);
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 1024;; A_initialize(instance); instance; });
    cstr scan = template;

    while (*scan) {

        if (*scan == '%' && *(scan + 1) == 'o') {
            A arg = __builtin_va_arg(args, A);
            string a = arg ? ((__typeof__((arg)->f)) ((A)(arg))[-1].type) -> cast_string(arg) : string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)("null"));
            num len = a->len;
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> reserve(res, len);
            memcpy(&res->chars[res->len], a->chars, len);
            res->len += len;
            scan += 2;
        } else {

            const char* next_percent = strchr(scan, '%');
            num segment_len = next_percent ? (num)(next_percent - scan) : (num)strlen(scan);
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> reserve(res, segment_len);
            memcpy(&res->chars[res->len], scan, segment_len);
            res->len += segment_len;
            scan += segment_len;
            if (*scan == '%') {
                if (*(scan + 1) == 'o')
                    continue;
                char formatter[128];
                int symbol_len = parse_formatter(scan, formatter, 128);
                for (;;) {
                    num f_len = 0;
                    num avail = res->alloc - res->len;
                    cstr end = &res->chars[res->len];
                    if (strchr("fFgG", formatter[symbol_len - 1]))
                        f_len = snprintf(end, avail, formatter, __builtin_va_arg(args, double));
                    else if (strchr("diouxX", formatter[symbol_len - 1]))
                        f_len = snprintf(end, avail, formatter, __builtin_va_arg(args, int));
                    else if (strchr("c", formatter[symbol_len - 1]))
                        f_len = snprintf(end, avail, formatter, __builtin_va_arg(args, int));
                    else
                        f_len = snprintf(
                            end, avail, formatter, __builtin_va_arg(args, void*));
                    if (f_len > avail) {
                        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> reserve(res, res->alloc << 1);
                        continue;
                    }
                    res->len += f_len;
                    break;
                }
                scan += symbol_len;
            }
        }
    }
    __builtin_va_end(args);
    if (f) {
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> write(res, f, (bool)0);
        if (write_ln) {
            fwrite("\n", 1, 1, f);
            fflush(f);
        }
    }

    return type ? (A)((A_f*)type)->with_cereal(A_alloc(type, 1, (bool)1), res->chars) : (A)res;
}

void string_destructor(string a) { free(a->chars); }
num string_compare(string a, string b) { return strcmp(a->chars, b->chars); }
num string_cmp(string a, cstr b) { return strcmp(a->chars, b); }
bool string_eq(string a, cstr b) { return strcmp(a->chars, b) == 0; }

i32 string_index_num(string a, num index) {
    if (index < 0)
        index += a->len;
    if (index >= a->len)
        return 0;
    return (i32)a->chars[index];
}

array string_split(string a, cstr sp) {
    cstr next = a->chars;
    sz slen = strlen(sp);
    while (next) {
        cstr n = strstr(&next[1], sp);
        string v = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = next; instance->ref_length = n ? (sz)(1 + next - n) : 0;; A_initialize(instance); instance; });
        next = n ? n + slen : ((void*)0);
    }
    return ((void*)0);
}

void string_alloc_sz(string a, sz alloc) {
    char* chars = calloc(1 + alloc, sizeof(char));
    memcpy(chars, a->chars, sizeof(char) * a->len);
    chars[a->len] = 0;

    a->chars = chars;
    a->alloc = alloc;
}

string string_mid(string a, num start, num len) {
    return ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = &a->chars[start]; instance->ref_length = len;; A_initialize(instance); instance; });
}

none string_reserve(string a, num extra) {
    if (a->alloc - a->len >= extra)
        return;
    string_alloc_sz(a, a->alloc + extra);
}

none string_append(string a, cstr b) {
    sz blen = strlen(b);
    if (blen + a->len >= a->alloc)
        string_alloc_sz(a, (a->alloc << 1) + blen);
    memcpy(&a->chars[a->len], b, blen);
    a->len += blen;
    a->chars[a->len] = 0;
}

sz string_len(string a) { return a->len; }

num string_index_of(string a, cstr cs) {
    char* f = strstr(a->chars, cs);
    return f ? (num)(f - a->chars) : (num)-1;
}

bool string_cast_bool(string a) {
    return a->len > 0;
}

sz string_cast_sz(string a) {
    return a->len;
}

cstr string_cast_cstr(string a) {
    return a->chars;
}

none string_write(string a, handle f, bool new_line) {
    FILE* output = f ? f : stdout;
    fwrite(a->chars, a->len, 1, output);
    if (new_line) fwrite("\n", 1, 1, output);
    fflush(output);
}

path string_cast_path(string a) {
    return ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); instance->chars = a->chars;; A_initialize(instance); instance; });
}

u64 fnv1a_hash(const void* data, size_t length, u64 hash) {
    const u8* bytes = (const u8*)data;
    for (size_t i = 0; i < length; ++i) {
        hash ^= bytes[i];
        hash *= 0x100000001b3;
    }
    return hash;
}

u64 item_hash(item f) {
    return ((__typeof__((f->key ? f->key : f->value)->f)) ((A)(f->key ? f->key : f->value))[-1].type) -> hash(f->key ? f->key : f->value);
}

u64 string_hash(string a) {
    if (a->h) return a->h;
    a->h = fnv1a_hash(a->chars, a->len, 0xcbf29ce484222325);
    return a->h;
}

void string_init(string a) {
    cstr value = a->chars;
    if (a->alloc)
        a->chars = (char*)calloc(1, 1 + a->alloc);
    if (value) {
        sz len = a->ref_length ? a->ref_length : strlen(value);
        if (!a->alloc)
            a->alloc = len;
        if (a->chars == value)
            a->chars = (char*)calloc(1, len + 1);
        memcpy(a->chars, value, len);
        a->chars[len] = 0;
        a->len = len;
    }
}

num clamp(num i, num mn, num mx) {
    if (i < mn) return mn;
    if (i > mx) return mx;
    return i;
}

real clampf(real i, real mn, real mx) {
    if (i < mn) return mn;
    if (i > mx) return mx;
    return i;
}

string string_with_cstr(string a, cstr value) {
    a->len = value ? strlen(value) : 0;
    a->chars = calloc(a->len + 1, 1);
    memcpy(a->chars, value, a->len);
    return a;
}

bool string_has_suffix(string a, cstr value) {
    sz ln = strlen(value);
    if (!ln || ln > a->len) return (bool)0;
    return strcmp(&a->chars[a->len - ln], value) == 0;
}

item list_push(list a, A e);

item hashmap_fetch(hashmap a, A key) {
    u64 h = ((__typeof__((key)->f)) ((A)(key))[-1].type) -> hash(key);
    u64 k = h % a->alloc;
    list bucket = &a->data[k];
    for (item f = bucket->first; f; f = f->next)
        if (((__typeof__((f->key)->f)) ((A)(f->key))[-1].type) -> compare(f->key, key) == 0)
            return f;
    item n = list_push(bucket, ((void*)0));
    n->key = A_hold(key);
    a->count++;
    return n;
}

item hashmap_lookup(hashmap a, A key) {
    u64 h = ((__typeof__((key)->f)) ((A)(key))[-1].type) -> hash(key);
    u64 k = h % a->alloc;
    list bucket = &a->data[k];
    for (item f = bucket->first; f; f = f->next)
        if (((__typeof__((f->key)->f)) ((A)(f->key))[-1].type) -> compare(f->key, key) == 0)
            return f;
    return ((void*)0);
}

none hashmap_set(hashmap a, A key, A value) {
    item i = ((__typeof__((a)->f)) ((A)(a))[-1].type) -> fetch(a, key);
    A prev = i->value;
    i->value = A_hold(value);
    A_drop(prev);
}

A hashmap_get(hashmap a, A key) {
    item i = ((__typeof__((a)->f)) ((A)(a))[-1].type) -> lookup(a, key);
    return i ? i->value : ((void*)0);
}

bool hashmap_contains(hashmap a, A key) {
    item i = ((__typeof__((a)->f)) ((A)(a))[-1].type) -> lookup(a, key);
    return i != ((void*)0);
}

none hashmap_remove(hashmap a, A key) {
    u64 h = ((__typeof__((key)->f)) ((A)(key))[-1].type) -> hash(key);
    u64 k = h % a->alloc;
    list bucket = &a->data[k];
    for (item f = bucket->first; f; f = f->next)
        if (((__typeof__((f->key)->f)) ((A)(f->key))[-1].type) -> compare(f->key, key) == 0) {
            list_remove_item(bucket, f);
            a->count--;
            break;
        }
}

bool hashmap_cast_bool(hashmap a) {
    return a->count > 0;
}

A hashmap_index_A(hashmap a, A key) {
    return ((__typeof__((a)->f)) ((A)(a))[-1].type) -> get(a, key);
}

hashmap hashmap_init(hashmap a) {
    if (!a->alloc)
         a->alloc = 16;
    a->data = (list)calloc(a->alloc, sizeof(struct list));
    return a;
}

string hashmap_cast_string(hashmap a) {
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 1024;; A_initialize(instance); instance; });
    bool once = (bool)0;
    for (int i = 0; i < a->alloc; i++) {
        list bucket = &a->data[i];
        for (item f = bucket->first; f; f = f->next) {
            string key = ((__typeof__((f->key)->f)) ((A)(f->key))[-1].type) -> cast_string(f->key);
            string val = ((__typeof__((f->value)->f)) ((A)(f->value))[-1].type) -> cast_string(f->value);
            if (once) ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, " ");
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, key->chars);
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, ":");
            ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, val->chars);
            once = (bool)1;
        }
    }
    return res;
}

void map_concat(map a, map b) {
    if (b && ((__typeof__((b)->f)) ((A)(b))[-1].type) -> cast_bool(b)) for (item _i = b->first, e = ((void*)0); _i; _i = _i->next) for (pair e = (pair)_i->value, e0 = e; e == e0; e0++) ((__typeof__((a)->f)) ((A)(a))[-1].type) -> set(a, e->key, e->value);
}

item map_fetch(map a, A key) {
    item i = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> fetch(a->hmap, key);
    return i;
}

none map_set(map a, A key, A value) {
    item i = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> fetch(a->hmap, key);
    pair mi = i->value;
    if (mi) {
        A before = mi->value;
        mi->value = A_hold(value);
        A_drop(before);
    } else {
        mi = i->value = ({ pair instance = (pair)A_alloc(((AType)&pair_type), 1, (bool)1); instance->key = key; instance->value = value;; A_initialize(instance); instance; });
        mi->ref = ((__typeof__((a)->f)) ((A)(a))[-1].type) -> push(a, i);
        mi->ref->key = A_hold(key);
        mi->ref->value = mi;
    }
}

A map_get(map a, A key) {
    item i = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> lookup(a->hmap, key);
    return (i && i->value) ? ((pair)i->value)->value : ((void*)0);
}

bool map_contains(map a, A key) {
    item i = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> lookup(a->hmap, key);
    return i != ((void*)0);
}


none map_remove(map a, A key) {
    item i = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> lookup(a->hmap, key);
    if (i) {
        item ref = i->value;
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> remove_item(a, ref);
    }
}

bool map_cast_bool(map a) {
    return a->count > 0;
}

A list_get(list a, object at_index);

sz map_len(map a) {
    return a->count;
}

A map_index_sz(map a, sz index) {
    do { if (!(index >= 0 && index < a->count)) { A_formatter(((void*)0), stderr, (bool)1, "index out of range"); exit(1); } } while(0);
    item i = list_get(a, A_sz(index));
    return i ? i->value : ((void*)0);
}

A map_index_A(map a, A index) {
    item hash_item = ((__typeof__((a->hmap)->f)) ((A)(a->hmap))[-1].type) -> get(a->hmap, index);
    return hash_item ? hash_item->value : ((void*)0);
}

map map_with_sz(map a, sz size) {
    a->hsize = size;
    return a;
}

void map_init(map a) {
    if (!a->hsize) a->hsize = 1024;
    a->hmap = ({ hashmap instance = (hashmap)A_alloc(((AType)&hashmap_type), 1, (bool)1); instance->alloc = a->hsize;; A_initialize(instance); instance; });
}

string map_cast_string(map a) {
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 1024;; A_initialize(instance); instance; });
    bool once = (bool)0;
    for (item i = a->first; i; i = i->next) {
        pair kv = i->value;
        string key = ((__typeof__((kv->key)->f)) ((A)(kv->key))[-1].type) -> cast_string(kv->key);
        string value = ((__typeof__((kv->value)->f)) ((A)(kv->value))[-1].type) -> cast_string(kv->value);
        if (once) ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, " ");
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, key->chars);
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, ":");
        ((__typeof__((res)->f)) ((A)(res))[-1].type) -> append(res, value->chars);
        once = (bool)1;
    }
    return res;
}


A A_copy(A a) {
    A f = A_fields(a);
    do { if (!(f->count > 0)) { A_formatter(((void*)0), stderr, (bool)1, "invalid count"); exit(1); } } while(0);
    AType type = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    A b = A_alloc(type, f->count, (bool)1);
    for (num i = 0; i < type->member_count; i++) {
        type_member_t* mem = &type->members[i];
        if (mem->member_type) {
            return mem;
        }
    }
    return b;
}

A A_hold(A a) {
    if (a) {
        A f = A_fields(a);
        if (f->refs++ == 1 && f->ar_index > 0)
            af_top->pool->elements[f->ar_index] = ((void*)0);
    }
    return a;
}

void A_free(A a) {
    A aa = A_fields(a);
    A_f* type = aa->type;
    void* prev = ((void*)0);
    while (type) {
        if (prev != type->destructor) {
            type->destructor(a);
            prev = type->destructor;
        }
        if (type == &A_type)
            break;
        type = type->parent_type;
    }
    free(aa);
}

void A_drop(A a) {
    if (a && --A_fields(a)->refs == -1)
        A_free(a);
}

A A_fields(A instance) {
    return (instance - 1)->origin;
}

A A_data(A instance) {
    A obj = A_fields(instance);
    return obj->data;
}

A A_instanceof(A inst, AType type) {
    do { if (!(inst)) { A_formatter(((void*)0), stderr, (bool)1, "instanceof given a null value"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
    AType t = type;
    AType it = (inst ? (struct A_f*)((struct A*)inst - 1)->type : (struct A_f*)0);
    AType it_copy = it;
    while (it) {
        if (it == t)
            return inst;
        else if (it == ((AType)&A_type))
            break;
        it = it->parent_type;
    }
    return ((void*)0);
}


item list_push(list a, A e) {
    item n = ({ item instance = (item)A_alloc(((AType)&item_type), 1, (bool)1); ; A_initialize(instance); instance; });
    n->value = e;
    if (a->last) {
        a->last->next = n;
        n->prev = a->last;
    } else {
        a->first = n;
    }
    a->last = n;
    a->count++;
    return n;
}



num list_index_of(list a, A value) {
    num index = 0;
    for (item ai = a->first; ai; ai = ai->next) {
        if (ai->value == value)
            return index;
        index++;
    }
    return -1;
}

item list_item_of(list a, A value) {
    num index = 0;
    for (item ai = a->first; ai; ai = ai->next) {
        if (ai->value == value) {
            ai->key = A_i64(index);
            return ai;
        }
        index++;
    }
    return ((void*)0);
}

void list_remove(list a, num index) {
    num i = 0;
    item res = ((void*)0);
    for (item ai = a->first; ai; ai = ai->next) {
        if (i++ == index) {
            res = ai;
            if (ai == a->first) a->first = ai->next;
            if (ai == a->last) a->last = ai->prev;
            if (ai->prev) ai->prev->next = ai->next;
            if (ai->next) ai->next->prev = ai->prev;
            a->count--;
            res->prev = ((void*)0);
            res->next = ((void*)0);
        }
    }
}

void list_remove_item(list a, item ai) {
    item res = ((void*)0);
    num i = 0;
    if (ai) {
        if (ai == a->first) a->first = ai->next;
        if (ai == a->last) a->last = ai->prev;
        if (ai->prev) ai->prev->next = ai->next;
        if (ai->next) ai->next->prev = ai->prev;
        a->count--;
        res->prev = ((void*)0);
        res->next = ((void*)0);
    }
}

num list_compare(list a, list b) {
    num diff = a->count - b->count;
    if (diff != 0)
        return diff;
    A_f* ai_t = a->first ? (a->first->value ? (struct A_f*)((struct A*)a->first->value - 1)->type : (struct A_f*)0) : ((void*)0);
    if (ai_t) {
        type_member_t* m = A_member(ai_t, (A_TYPE_IMETHOD), "compare");
        for (item ai = a->first, bi = b->first; ai; ai = ai->next, bi = bi->next) {
            num v = ((num(*)(A,A))((method_t*)m->method)->address)(ai, bi);
            if (v != 0) return v;
        }
    }
    return 0;
}

A list_pop(list a) {
    item l = a->last;
    a->last = a->last->prev;
    if (!a->last)
        a->first = ((void*)0);
    l->prev = ((void*)0);
    a->count--;
    return l;
}

A list_get(list a, object at_index) {
    sz index = 0;
    AType itype = (at_index ? (struct A_f*)((struct A*)at_index - 1)->type : (struct A_f*)0);
    sz at = 0;
    if (itype == ((AType)&sz_type)) {
        at = *(sz*)at_index;
    } else {
        do { if (!(itype == ((AType)&i32_type))) { A_formatter(((void*)0), stderr, (bool)1, "invalid indexing type"); exit(1); } } while(0);
        at = (sz)*(i32*)at_index;
    }
    for (item i = a->first; i; i = i->next) {
        if (at == index)
            return i->value;
        index++;
    }
    do { if (!((bool)0)) { A_formatter(((void*)0), stderr, (bool)1, "could not fetch item at index %i", at); exit(1); } } while(0);
    return ((void*)0);
}

num list_count(list a) {
    return a->count;
}



void vector_init(vector a) {
    if (a->alloc) {
        a->data = A_alloc(a->type, a->alloc, (bool)1);
    }
}

void vector_push(vector a, A any) {
    sz size = a->type->size;
    do { if (!(a->len < a->alloc)) { A_formatter(((void*)0), stderr, (bool)1, "vector out of space"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
    memcpy(&a->data[a->len * size], any, size);
    a->len++;
}

sz vector_count(vector a) {
    return a->len;
}

bool vector_cast_bool(vector a) {
    return a->len > 0;
}

#pragma pack(push, 1)
# 1325 "/home/kalen/src/A/src/A.c"
 A vector_header; vector_f vector_type;
# 1325 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1325 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_vector() { vector_f* type_ref = &vector_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_vector); return (bool)0; } else { memset(type_ref, 0, sizeof(vector_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(vector_type) / sizeof(void*)]; vector_type.parent_type = &A_type; vector_type.name = "vector"; vector_type.members = members; vector_type.size = sizeof(struct vector); vector_type.traits = 0; vector_type.arb = primitive_ffi_arb(((AType)&cstr_type)); vector_type.members[vector_type.member_count].name = "data"; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(struct vector, data); vector_type.members[vector_type.member_count].type = (AType)&A_type; vector_type.members[vector_type.member_count].member_type = A_TYPE_PROP; vector_type.member_count++; vector_type.members[vector_type.member_count].required = (bool)1; vector_type.members[vector_type.member_count].name = "alloc"; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(struct vector, alloc); vector_type.members[vector_type.member_count].type = (AType)&i32_type; vector_type.members[vector_type.member_count].member_type = A_TYPE_PROP; vector_type.member_count++; vector_type.members[vector_type.member_count].name = "len"; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(struct vector, len); vector_type.members[vector_type.member_count].type = (AType)&i32_type; vector_type.members[vector_type.member_count].member_type = A_TYPE_PROP; vector_type.member_count++; vector_type.members[vector_type.member_count].required = (bool)1; vector_type.members[vector_type.member_count].name = "type"; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(struct vector, type); vector_type.members[vector_type.member_count].type = (AType)&AType_type; vector_type.members[vector_type.member_count].member_type = A_TYPE_PROP; vector_type.member_count++; vector_type . push = & vector_push; vector_type.members[vector_type.member_count].name = "push"; vector_type.members[vector_type.member_count].args = (meta_t) { 3, &vector_type, &vector_type, &A_type }; vector_type.members[vector_type.member_count].type = (AType)&none_type; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(vector_f, push); vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . count = & vector_count; vector_type.members[vector_type.member_count].name = "count"; vector_type.members[vector_type.member_count].args = (meta_t) { 2, &vector_type, &vector_type }; vector_type.members[vector_type.member_count].type = (AType)&num_type; vector_type.members[vector_type.member_count].offset = __builtin_offsetof(vector_f, count); vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . init = & vector_init; vector_type . cast_bool = & vector_cast_bool; A_push_type(&vector_type); return (bool)1; } };

bool is_meta(A a) {
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    return t->meta.count > 0;
}

bool is_meta_compatible(A a, A b) {
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (is_meta(a)) {
        AType bt = (b ? (struct A_f*)((struct A*)b - 1)->type : (struct A_f*)0);
        num found = 0;
        for (num i = 0; i < t->meta.count; i++) {
            AType mt = ((AType*)&t->meta.meta_0)[i];
            if (mt == bt)
                found++;
        }
        return found > 0;
    }
    return (bool)0;
}

void array_push(array a, A b) {
    if (a->alloc == a->len) {
        array_expand(a);
    }
    AType t = (a ? (struct A_f*)((struct A*)a - 1)->type : (struct A_f*)0);
    if (is_meta(a))
        do { if (!(is_meta_compatible(a, b))) { A_formatter(((void*)0), stderr, (bool)1, "not meta compatible"); exit(1); } } while(0);
    a->elements[a->len++] = A_hold(b);
}

void array_clear(array a) {
    for (num i = 0; i < a->len; i++) {
        A_drop(a->elements[i]);
        a->elements[i] = ((void*)0);
    }
    a->len = 0;
}

none array_concat(array a, array b) {
    if (((b) ? (i64)((__typeof__((b)->f)) ((A)(b))[-1].type) -> len(b) : (i64)0)) for (A e = ((__typeof__((b)->f)) ((A)(b))[-1].type) -> get(b, 0), e0 = 0; e0 == 0; e0++) for (num __i = 0, __len = ((b) ? (i64)((__typeof__((b)->f)) ((A)(b))[-1].type) -> len(b) : (i64)0); __i < __len; __i++, e = ((__typeof__((b)->f)) ((A)(b))[-1].type) -> get(b, __i)) array_push(a, e);
}

A array_index_num(array a, num i) {
    if (i < 0)
        i += a->len;
    if (i >= a->len)
        return 0;
    return a->elements[i];
}

void array_remove(array a, num b) {
    for (num i = b; i < a->len; i++) {
        A prev = a->elements[b];
        a->elements[b] = a->elements[b + 1];
        A_drop(prev);
    }
    a->elements[--a->len] = ((void*)0);
}

void array_remove_weak(array a, num b) {
    for (num i = b; i < a->len; i++) {
        A prev = a->elements[b];
        a->elements[b] = a->elements[b + 1];
    }
    a->elements[--a->len] = ((void*)0);
}

void array_operator__assign_add(array a, A b) {
    array_push(a, b);
}

void array_operator__assign_sub(array a, num b) {
    array_remove(a, b);
}

A array_first(array a) {
    do { if (!(a->len)) { A_formatter(((void*)0), stderr, (bool)1, "no items"); exit(1); } } while(0);
    return a->elements[a->len - 1];
}

A array_last(array a) {
    do { if (!(a->len)) { A_formatter(((void*)0), stderr, (bool)1, "no items"); exit(1); } } while(0);
    return a->elements[a->len - 1];
}

void array_push_symbols(array a, ...) {
    va_list args;
    __builtin_va_start(args, a);
    char* value;
    while ((value = __builtin_va_arg(args, char*)) != ((void*)0)) {
        string s = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = value;; A_initialize(instance); instance; });
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> push(a, s);
    }
    __builtin_va_end(args);
}

void array_push_objects(array a, A f, ...) {
    va_list args;
    __builtin_va_start(args, f);
    A value;
    while ((value = __builtin_va_arg(args, A)) != ((void*)0))
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> push(a, value);
    __builtin_va_end(args);
}

map map_of(cstr first_key, ...) {
    map a = ({ map instance = (map)A_alloc(((AType)&map_type), 1, (bool)1); instance->hsize = 16;; A_initialize(instance); instance; });
    va_list args;
    __builtin_va_start(args, first_key);
    cstr key = first_key;
    for (;;) {
        A arg = __builtin_va_arg(args, A);
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> set(a, string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)(key)), arg);
        key = __builtin_va_arg(args, cstr);
        if (key == ((void*)0))
            break;
    }
    return a;
}

array array_of(AType validate, ...) {
    array a = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)1); ; A_initialize(instance); instance; });
    va_list args;
    __builtin_va_start(args, validate);
    for (;;) {
        A arg = __builtin_va_arg(args, A);
        if (!arg)
            break;
        do { if (!(!validate || validate == (arg ? (struct A_f*)((struct A*)arg - 1)->type : (struct A_f*)0))) { A_formatter(((void*)0), stderr, (bool)1, "validation failure"); exit(1); } } while(0);
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> push(a, arg);
    }
    return a;
}

array array_of_cstr(cstr first, ...) {
    array a = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)0); ; A_initialize(instance); instance; });
    va_list args;
    __builtin_va_start(args, first);
    for (;;) {
        cstr arg = __builtin_va_arg(args, A);
        if (!arg)
            break;
        ((__typeof__((a)->f)) ((A)(a))[-1].type) -> push(a, ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)0); instance->chars = arg;; A_initialize(instance); instance; }));
    }
    return a;
}

void array_weak_push(array a, A obj) {
    a->elements[a->len++] = obj;
}

A array_pop(array a) {
    do { if (!(a->len > 0)) { A_formatter(((void*)0), stderr, (bool)1, "no items"); exit(1); } } while(0);
    if (!a->unmanaged) A_drop(a->elements[a->len - 1]);
    return a->elements[a->len--];
}

num array_compare(array a, array b) {
    num diff = a->len - b->len;
    if (diff != 0)
        return diff;
    for (num i = 0; i < a->len; i++) {
        num cmp = ((__typeof__((a->elements[i])->f)) ((A)(a->elements[i]))[-1].type) -> compare(a->elements[i], b->elements[i]);
        if (cmp != 0)
            return cmp;
    }
    return 0;
}

A array_get(array a, num i) {
    return a->elements[i];
}

num array_count(array a) {
    return a->len;
}

sz array_len(array a) {
    return a->len;
}


num array_index_of(array a, A b) {
    for (num i = 0; i < a->len; i++) {
        if (((__typeof__((a -> elements[i])->f)) ((A)(a -> elements[i]))[-1].type) -> compare(a -> elements[i], b) == 0)
            return i;
    }
    return -1;
}

void br() {
    usleep(0);
}

bool array_cast_bool(array a) { return a && a->len > 0; }

none array_init(array a) {
    if (a->alloc)
        array_alloc_sz(a, a->alloc);
}

object subprocedure_invoke(subprocedure a, object arg) {
    object(*addr)(object, object, object) = a->addr;
    return addr(a->target, arg, a->ctx);
}

void AF_init(AF a) {
    af_top = a;
    &AF_type;
    a->pool = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)0); instance->alloc = a->start_size ? a->start_size : 1024;; A_initialize(instance); instance; });
    ((__typeof__((a->pool)->f)) ((A)(a->pool))[-1].type) -> push_weak(a->pool, a);

    if (!af_stack) af_stack = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)0); instance->alloc = 16;; A_initialize(instance); instance; });
    ((__typeof__((af_stack)->f)) ((A)(af_stack))[-1].type) -> push_weak(af_stack, a);
}

AF AF_create(sz start_size) {
    AF a = ({ AF instance = (AF)A_alloc(((AType)&AF_type), 1, (bool)0); instance->start_size = start_size;; A_initialize(instance); instance; });

    return a;
}

AF A_pool(sz start_size) {
    return AF_create(start_size);
}

void AF_destructor(AF a) {
    int f = ((__typeof__((af_stack)->f)) ((A)(af_stack))[-1].type) -> index_of(af_stack, a);
    do { if (!(f >= 0)) { A_formatter(((void*)0), stderr, (bool)1, "invalid af-stack index"); exit(1); } } while(0);
    ((__typeof__((af_stack)->f)) ((A)(af_stack))[-1].type) -> remove_weak(af_stack, f);
    if (af_top == a)
        af_top = af_stack->len ? af_stack->elements[af_stack->len - 1] : ((void*)0);
    for (int i = 1; i < a->pool->len; i++) {
        A ref = a->pool->elements[i];
        if (ref) {
            A_free(ref);
        }
    }
    A_free(a->pool);
    a->pool = ((void*)0);
}

AF AF_fetch(num index) {
    if (af_stack && abs((int)index) < af_stack->len)
        return index < 0 ? af_stack->elements[af_stack->len + index] :
                           af_stack->elements[index];
    else
        return ((void*)0);
}

u64 fn_hash(fn f) {
    return (u64)f->method->address;
}

A fn_call(fn f, array args) {
    return A_method_call(f->method, args);
}

bool create_symlink(path target, path link) {
    bool is_err = symlink(target, link) == -1;
    return !is_err;
}

void file_init(file f) {
    do { if (!(!(f->read && f->write))) { A_formatter(((void*)0), stderr, (bool)1, "cannot open for both read and write"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
    cstr src = f->src->chars;
    if (f->read || f->write)
        f->f = fopen(src, f->read ? "rb" : "wb");
}


bool file_write(file f, object o) {
    AType type = (o ? (struct A_f*)((struct A*)o - 1)->type : (struct A_f*)0);
    if (type == ((AType)&string_type)) {
        u16 nbytes = ((string)o)->len;
        u16 le_nbytes = __uint16_identity (nbytes);
        fwrite(&le_nbytes, 2, 1, f->f);
        return fwrite(((string)o)->chars, 1, nbytes, f->f) == nbytes;
    }
    do { if (!(type->traits & A_TRAIT_PRIMITIVE)) { A_formatter(((void*)0), stderr, (bool)1, "not a primitive type"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
    return fwrite(o, (o ? (struct A_f*)((struct A*)o - 1)->type : (struct A_f*)0)->size, 1, f->f) == 1;
}

bool file_read(file f, AType type) {
    object o = A_alloc(type, 1, (bool)1);
    if (type == ((AType)&string_type)) {
        u16 nbytes;
        do { if (!(fread(&nbytes, 2, 1, f->f) == 1)) { A_formatter(((void*)0), stderr, (bool)1, "failed to read byte count"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
        nbytes = __uint16_identity (nbytes);
        return fread(o, 1, nbytes, f->f) == nbytes;
    }
    do { if (!(type->traits & A_TRAIT_PRIMITIVE)) { A_formatter(((void*)0), stderr, (bool)1, "not a primitive type"); if (level_err >= fault_level) { raise(19); exit(1); } } } while(0);
    return fread(o, (o ? (struct A_f*)((struct A*)o - 1)->type : (struct A_f*)0)->size, 1, f->f) == 1;
}

void file_close(file f) {
    if (f->f) {
        fclose(f->f);
        f->f = ((void*)0);
    }
}

void file_destructor(file f) {
    file_close(f);
}

none path_init(path a) {
    cstr arg = a->chars;
    num len = arg ? strlen(arg) : 0;
    a->chars = calloc(len + 1, 1);
    if (arg)
        memcpy(a->chars, arg, len + 1);
}

path path_with_string(path a, string s) {
    a->chars = copy_cstr(s->chars);
    return a;
}

bool path_cast_bool(path a) {
    return a->chars && strlen(a->chars) > 0;
}

sz path_cast_sz(path a) {
    return strlen(a->chars);
}

cstr path_cast_cstr(path a) {
    return a->chars;
}

string path_cast_string(path a) {
    return ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->chars = a->chars;; A_initialize(instance); instance; });
}

path path_with_cereal(path a, cereal cs) {
    a->chars = copy_cstr((cstr)cs);
    return a;
}

bool path_make_dir(path a) {
    cstr cs = a->chars;
    sz len = strlen(cs);
    for (num i = 1; i < len; i++) {
        if (cs[i] == '/' || i == len - 1) {
            bool set = (bool)0;
            if (cs[i] == '/') { cs[i] = 0; set = (bool)1; }
            mkdir(cs, 0755);
            if (set) cs[i] = '/';
        }
    }
    struct stat st = {0};
    return stat(cs, &st) == 0 && ((((st.st_mode)) & 0170000) == (0040000));
}

bool path_is_dir(path a) {
    DIR *dir = opendir(a->chars);
    if (dir == ((void*)0))
        return (bool)0;
    closedir(dir);
    return (bool)1;
}


bool path_is_empty(path a) {
    int n = 0;
    struct dirent *d;
    DIR *dir = opendir(a->chars);

    if (dir == ((void*)0))
        return (bool)0;

    while ((d = readdir(dir)) != ((void*)0)) {
        if (++n > 2)
            break;
    }
    closedir(dir);
    return n <= 2;
}

string path_ext(path a) {
    for (int i = strlen(a->chars) - 1; i >= 0; i--)
        if (a->chars[i] == '.')
            return string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)(&a->chars[i + 1]));
    return string_type.with_cstr(A_alloc(&string_type, 1, (bool)1), (cstr)(((void*)0)));
}

string path_stem(path a) {
    cstr cs = a->chars;
    sz len = strlen(cs);
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 256;; A_initialize(instance); instance; });
    sz dot = 0;
    for (num i = len - 1; i >= 0; i--) {
        if (cs[i] == '.')
            dot = i;
        if (cs[i] == '/' || i == 0) {
            int offset = cs[i] == '/';
            cstr start = &cs[i + offset];
            int n_bytes = (dot > 0 ? dot : len) - (i + offset);
            memcpy(res->chars, start, n_bytes);
            res->len = n_bytes;
            break;
        }
    }
    return res;
}

string path_filename(path a) {
    cstr cs = a->chars;
    sz len = strlen(cs);
    string res = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = 256;; A_initialize(instance); instance; });
    for (num i = len - 1; i >= 0; i--) {
        if (cs[i] == '/' || i == 0) {
            cstr start = &cs[i + (cs[i] == '/')];
            int n_bytes = len - i;
            memcpy(res->chars, start, n_bytes);
            res->len = n_bytes;
            break;
        }
    }
    return res;
}

path path_absolute(path a) {
    path result = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); ; A_initialize(instance); instance; });
    cstr rpath = realpath(a->chars, ((void*)0));
    result->chars = rpath ? strdup(rpath) : copy_cstr("");
    return result;
}


path path_directory(path a) {
    path result = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); ; A_initialize(instance); instance; });
    result->chars = dirname(strdup(a->chars));
    return result;
}

path path_parent(path a) {
    int len = strlen(a->chars);
    char *cp = calloc(len + 4, 1);
    memcpy(cp, a->chars, len);
    if (a->chars[len - 1] == '\\' || a->chars[len - 1] == '/')
        memcpy(&cp[len], "..", 3);
    else
        memcpy(&cp[len], "/..", 4);
    char *dir_name = dirname(cp);
    path result = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); ; A_initialize(instance); instance; });
    result->chars = strdup(dir_name);
    return result;
}

path path_change_ext(path a, cstr ext) {
    int e_len = strlen(ext);
    int len = strlen(a->chars);
    int ext_pos = -1;
    for (int i = len - 1; i >= 0; i--) {
        if (a->chars[i] == '/')
            break;
        if (a->chars[i] == '.') {
            ext_pos = i;
            break;
        }
    }
    path res = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); ; A_initialize(instance); instance; });
    res->chars = calloc(32 + len + e_len, 1);
    if (ext_pos >= 0) {
        memcpy( res->chars, a->chars, ext_pos + 1);
        if (e_len)
            memcpy(&res->chars[ext_pos + 1], ext, e_len);
        else
            res->chars[ext_pos] = 0;
    } else {
        memcpy( res->chars, a->chars, len);
        if (e_len) {
            memcpy(&res->chars[len], ".", 1);
            memcpy(&res->chars[len + 1], ext, e_len);
        }
    }
    return res;
}


path path_cwd(sz size) {
    path a = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); ; A_initialize(instance); instance; });
    a->chars = calloc(size, 1);
    char* res = getcwd(a->chars, size);
    do { if (!(res != ((void*)0))) { A_formatter(((void*)0), stderr, (bool)1, "getcwd failure"); exit(1); } } while(0);
    return a;
}

bool path_exists(path a) {
    FILE *file = fopen(a->chars, "r");
    if (file) {
        fclose(file);
        return (bool)1;
    }
    return (bool)0;
}

u64 path_hash(path a) {
    return fnv1a_hash(a->chars, strlen(a->chars), 0xcbf29ce484222325);
}


A path_read(path a, AType type) {
    FILE* f = fopen(a->chars, "rb");
    if (!f) return ((void*)0);
    if (type == ((AType)&string_type)) {
        fseek(f, 0, 2);
        sz flen = ftell(f);
        fseek(f, 0, 0);
        string a = ({ string instance = (string)A_alloc(((AType)&string_type), 1, (bool)1); instance->alloc = flen;; A_initialize(instance); instance; });
        size_t n = fread(a->chars, 1, flen, f);
        fclose(f);
        do { if (!(n == flen)) { A_formatter(((void*)0), stderr, (bool)1, "could not read enough bytes"); exit(1); } } while(0);
        a->len = flen;
        return a;
    }
    do { if (!((bool)0)) { A_formatter(((void*)0), stderr, (bool)1, "not implemented"); exit(1); } } while(0);
    return ((void*)0);
}

void* primitive_ffi_arb(AType ptype) {
    if (ptype == ((AType)&u8_type)) return &ffi_type_uint8;
    if (ptype == ((AType)&i8_type)) return &ffi_type_sint8;
    if (ptype == ((AType)&u16_type)) return &ffi_type_uint16;
    if (ptype == ((AType)&i16_type)) return &ffi_type_sint16;
    if (ptype == ((AType)&u32_type)) return &ffi_type_uint32;
    if (ptype == ((AType)&i32_type)) return &ffi_type_sint32;
    if (ptype == ((AType)&u64_type)) return &ffi_type_uint64;
    if (ptype == ((AType)&i64_type)) return &ffi_type_sint64;
    if (ptype == ((AType)&f32_type)) return &ffi_type_float;
    if (ptype == ((AType)&f64_type)) return &ffi_type_double;
    if (ptype == ((AType)&f128_type)) return &ffi_type_longdouble;
    if (ptype == ((AType)&cstr_type)) return &ffi_type_pointer;
    if (ptype == ((AType)&symbol_type)) return &ffi_type_pointer;
    if (ptype == ((AType)&cereal_type)) return &ffi_type_pointer;
    if (ptype == ((AType)&bool_type)) return &ffi_type_uint32;
    if (ptype == ((AType)&num_type)) return &ffi_type_sint64;
    if (ptype == ((AType)&sz_type)) return &ffi_type_sint64;
    if (ptype == ((AType)&none_type)) return &ffi_type_void;
    if (ptype == ((AType)&AType_type)) return &ffi_type_pointer;
    if (ptype == ((AType)&handle_type)) return &ffi_type_pointer;
    if (ptype == ((AType)&Member_type)) return &ffi_type_pointer;

    if (ptype == ((AType)&raw_type)) return &ffi_type_pointer;
    do { if (!(ptype->size == sizeof(void*))) { A_formatter(((void*)0), stderr, (bool)1, "we may only import void* handles for now; this may be fixed with arguments given to define"); exit(1); } } while(0);
    return &ffi_type_pointer;
}




array path_ls(path a, string pattern, bool recur) {
    cstr base_dir = a->chars;
    do { if (!(path_is_dir(a))) { A_formatter(((void*)0), stderr, (bool)1, "ls: must be called on directory"); exit(1); } } while(0);
    array list = ({ array instance = (array)A_alloc(((AType)&array_type), 1, (bool)1); instance->alloc = 32;; A_initialize(instance); instance; });
    DIR *dir = opendir(base_dir);
    char abs[4096];
    struct dirent *entry;
    struct stat statbuf;

    do { if (!(dir)) { A_formatter(((void*)0), stderr, (bool)1, "opendir"); exit(1); } } while(0);

    while ((entry = readdir(dir)) != ((void*)0)) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(abs, sizeof(abs), "%s/%s", base_dir, entry->d_name);

        if (stat(abs, &statbuf) == 0) {
            if (((((statbuf.st_mode)) & 0170000) == (0100000))) {
                if (!pattern->len || strstr(abs, pattern->chars))
                    ((__typeof__((list)->f)) ((A)(list))[-1].type) -> push(list, ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); instance->chars = abs;; A_initialize(instance); instance; }));

            } else if (((((statbuf.st_mode)) & 0170000) == (0040000))) {
                if (recur) {
                    path subdir = ({ path instance = (path)A_alloc(((AType)&path_type), 1, (bool)1); instance->chars = abs;; A_initialize(instance); instance; });
                    array sublist = ((__typeof__((subdir)->f)) ((A)(subdir))[-1].type) -> ls(subdir, pattern, recur);
                    ((__typeof__((list)->f)) ((A)(list))[-1].type) -> concat(list, sublist);
                }
            }
        }
    }

    closedir(dir);
    return list;
}

#pragma pack(push, 1)
# 1916 "/home/kalen/src/A/src/A.c"
 A A_header; A_f A_type;
# 1916 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1916 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_A() { A_f* type_ref = &A_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_A); return (bool)0; } else { memset(type_ref, 0, sizeof(A_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(A_type) / sizeof(void*)]; A_type.parent_type = &A_type; A_type.name = "A"; A_type.members = members; A_type.size = sizeof(struct A); A_type.traits = 0; A_type.arb = primitive_ffi_arb(((AType)&cstr_type)); A_type.members[A_type.member_count].name = "type"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, type); A_type.members[A_type.member_count].type = (AType)&AType_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "refs"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, refs); A_type.members[A_type.member_count].type = (AType)&num_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "ar_index"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, ar_index); A_type.members[A_type.member_count].type = (AType)&num_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "data"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, data); A_type.members[A_type.member_count].type = (AType)&A_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "alloc"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, alloc); A_type.members[A_type.member_count].type = (AType)&num_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "count"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, count); A_type.members[A_type.member_count].type = (AType)&num_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type.members[A_type.member_count].name = "origin"; A_type.members[A_type.member_count].offset = __builtin_offsetof(struct A, origin); A_type.members[A_type.member_count].type = (AType)&A_type; A_type.members[A_type.member_count].member_type = A_TYPE_PROP; A_type.member_count++; A_type . init = & A_init; A_type.members[A_type.member_count].name = "init"; A_type.members[A_type.member_count].args = (meta_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = (AType)&none_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, init); A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . destructor = & A_destructor; A_type.members[A_type.member_count].name = "destructor"; A_type.members[A_type.member_count].args = (meta_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = (AType)&none_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, destructor); A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . compare = & A_compare; A_type.members[A_type.member_count].name = "compare"; A_type.members[A_type.member_count].args = (meta_t) { 3, &A_type, &A_type, &A_type }; A_type.members[A_type.member_count].type = (AType)&i32_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, compare); A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . hash = & A_hash; A_type.members[A_type.member_count].name = "hash"; A_type.members[A_type.member_count].args = (meta_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = (AType)&u64_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, hash); A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . copy = & A_copy; A_type.members[A_type.member_count].name = "copy"; A_type.members[A_type.member_count].args = (meta_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = (AType)&A_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, copy); A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type.with_cereal = & A_with_cereal; A_type.members[A_type.member_count].name = "with_cereal"; A_type.members[A_type.member_count].args = (meta_t) { 1, &cereal_type }; A_type.members[A_type.member_count].type = &cereal_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, with_cereal); A_type.members[A_type.member_count].member_type = A_TYPE_CONSTRUCT; A_type.member_count++; A_type.cast_string = & A_cast_string; A_type.members[A_type.member_count].name = "combine_tokens(cast_, string)"; A_type.members[A_type.member_count].args = (meta_t) { 1, &A_type }; A_type.members[A_type.member_count].type = (AType)&string_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, cast_string); A_type.members[A_type.member_count].member_type = A_TYPE_CAST; A_type.member_count++; A_type.cast_bool = & A_cast_bool; A_type.members[A_type.member_count].name = "combine_tokens(cast_, bool)"; A_type.members[A_type.member_count].args = (meta_t) { 1, &A_type }; A_type.members[A_type.member_count].type = (AType)&bool_type; A_type.members[A_type.member_count].offset = __builtin_offsetof(A_f, cast_bool); A_type.members[A_type.member_count].member_type = A_TYPE_CAST; A_type.member_count++; A_push_type(&A_type); return (bool)1; } }
A object_header; object_f object_type; static __attribute__((constructor)) bool global_object() { object_f* type_ref = &object_type; A_f* src_ref = &A_type; if (src_ref->size == 0) { A_lazy_init((global_init_fn)&global_object); return (bool)0; } else { memset(type_ref, 0, sizeof(object_f)); memcpy(&object_type, &A_type, sizeof(A_f)); object_type.name = "object"; object_type.src = &A_type; object_type.meta = (meta_t) { 1, &A_type }; object_type.traits = A_TRAIT_ALIAS; return (bool)1; } }

#pragma pack(push, 1)
# 1919 "/home/kalen/src/A/src/A.c"
 A numeric_header; numeric_f numeric_type;
# 1919 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1919 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_numeric() {
    numeric_f* type_ref = &numeric_type; A_f* base_ref = &A_type;
    if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) {
        A_lazy_init((global_init_fn)&global_numeric);
        return (bool)0;
    } else {
        memset(type_ref, 0, sizeof(numeric_f));
        memcpy(type_ref, base_ref, sizeof(A_f));
        static type_member_t members[16 + sizeof(numeric_type) / sizeof(void*)];
        numeric_type.parent_type = &A_type;
        numeric_type.name = "numeric";
        numeric_type.members = members;
        numeric_type.size = 0;
        numeric_type.traits = A_TRAIT_ABSTRACT;
        numeric_type.arb = ((void*)0);
        A_push_type(&numeric_type);
        return (bool)1;
    } }
#pragma pack(push, 1)
# 1920 "/home/kalen/src/A/src/A.c"
 A string_like_header; string_like_f string_like_type;
# 1920 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1920 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_string_like() { string_like_f* type_ref = &string_like_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_string_like); return (bool)0; } else { memset(type_ref, 0, sizeof(string_like_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(string_like_type) / sizeof(void*)]; string_like_type.parent_type = &A_type; string_like_type.name = "string_like"; string_like_type.members = members; string_like_type.size = 0; string_like_type.traits = A_TRAIT_ABSTRACT; string_like_type.arb = ((void*)0); A_push_type(&string_like_type); return (bool)1; } }
#pragma pack(push, 1)
# 1921 "/home/kalen/src/A/src/A.c"
 A nil_header; nil_f nil_type;
# 1921 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1921 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_nil() { nil_f* type_ref = &nil_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_nil); return (bool)0; } else { memset(type_ref, 0, sizeof(nil_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(nil_type) / sizeof(void*)]; nil_type.parent_type = &A_type; nil_type.name = "nil"; nil_type.members = members; nil_type.size = 0; nil_type.traits = A_TRAIT_ABSTRACT; nil_type.arb = ((void*)0); A_push_type(&nil_type); return (bool)1; } }
#pragma pack(push, 1)
# 1922 "/home/kalen/src/A/src/A.c"
 A raw_header; raw_f raw_type;
# 1922 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1922 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_raw() { raw_f* type_ref = &raw_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_raw); return (bool)0; } else { memset(type_ref, 0, sizeof(raw_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(raw_type) / sizeof(void*)]; raw_type.parent_type = &A_type; raw_type.name = "raw"; raw_type.members = members; raw_type.size = 0; raw_type.traits = A_TRAIT_ABSTRACT; raw_type.arb = ((void*)0); A_push_type(&raw_type); return (bool)1; } }
#pragma pack(push, 1)
# 1923 "/home/kalen/src/A/src/A.c"
 A ref_header; ref_f ref_type;
# 1923 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1923 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_ref() { ref_f* type_ref = &ref_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_ref); return (bool)0; } else { memset(type_ref, 0, sizeof(ref_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(ref_type) / sizeof(void*)]; ref_type.parent_type = &A_type; ref_type.name = "ref"; ref_type.members = members; ref_type.size = 0; ref_type.traits = A_TRAIT_ABSTRACT; ref_type.arb = ((void*)0); A_push_type(&ref_type); return (bool)1; } }
#pragma pack(push, 1)
# 1924 "/home/kalen/src/A/src/A.c"
 A imported_header; imported_f imported_type;
# 1924 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1924 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_imported() { imported_f* type_ref = &imported_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_imported); return (bool)0; } else { memset(type_ref, 0, sizeof(imported_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(imported_type) / sizeof(void*)]; imported_type.parent_type = &A_type; imported_type.name = "imported"; imported_type.members = members; imported_type.size = 0; imported_type.traits = A_TRAIT_ABSTRACT; imported_type.arb = ((void*)0); A_push_type(&imported_type); return (bool)1; } }

#pragma pack(push, 1)
# 1926 "/home/kalen/src/A/src/A.c"
 A u8_header; u8_f u8_type;
# 1926 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1926 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_u8() { u8_f* type_ref = &u8_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_u8); return (bool)0; } else { memset(type_ref, 0, sizeof(u8_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(u8_type) / sizeof(void*)]; u8_type.parent_type = &numeric_type; u8_type.name = "u8"; u8_type.members = members; u8_type.size = sizeof(u8); u8_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_UNSIGNED | A_TRAIT_PRIMITIVE; u8_type.arb = primitive_ffi_arb(((AType)&u8_type)); A_push_type(&u8_type); return (bool)1; } }
#pragma pack(push, 1)
# 1927 "/home/kalen/src/A/src/A.c"
 A u16_header; u16_f u16_type;
# 1927 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1927 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_u16() { u16_f* type_ref = &u16_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_u16); return (bool)0; } else { memset(type_ref, 0, sizeof(u16_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(u16_type) / sizeof(void*)]; u16_type.parent_type = &numeric_type; u16_type.name = "u16"; u16_type.members = members; u16_type.size = sizeof(u16); u16_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_UNSIGNED | A_TRAIT_PRIMITIVE; u16_type.arb = primitive_ffi_arb(((AType)&u16_type)); A_push_type(&u16_type); return (bool)1; } }
#pragma pack(push, 1)
# 1928 "/home/kalen/src/A/src/A.c"
 A u32_header; u32_f u32_type;
# 1928 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1928 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_u32() { u32_f* type_ref = &u32_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_u32); return (bool)0; } else { memset(type_ref, 0, sizeof(u32_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(u32_type) / sizeof(void*)]; u32_type.parent_type = &numeric_type; u32_type.name = "u32"; u32_type.members = members; u32_type.size = sizeof(u32); u32_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_UNSIGNED | A_TRAIT_PRIMITIVE; u32_type.arb = primitive_ffi_arb(((AType)&u32_type)); A_push_type(&u32_type); return (bool)1; } }
#pragma pack(push, 1)
# 1929 "/home/kalen/src/A/src/A.c"
 A u64_header; u64_f u64_type;
# 1929 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1929 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_u64() { u64_f* type_ref = &u64_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_u64); return (bool)0; } else { memset(type_ref, 0, sizeof(u64_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(u64_type) / sizeof(void*)]; u64_type.parent_type = &numeric_type; u64_type.name = "u64"; u64_type.members = members; u64_type.size = sizeof(u64); u64_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_UNSIGNED | A_TRAIT_PRIMITIVE; u64_type.arb = primitive_ffi_arb(((AType)&u64_type)); A_push_type(&u64_type); return (bool)1; } }
#pragma pack(push, 1)
# 1930 "/home/kalen/src/A/src/A.c"
 A i8_header; i8_f i8_type;
# 1930 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1930 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_i8() { i8_f* type_ref = &i8_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_i8); return (bool)0; } else { memset(type_ref, 0, sizeof(i8_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(i8_type) / sizeof(void*)]; i8_type.parent_type = &numeric_type; i8_type.name = "i8"; i8_type.members = members; i8_type.size = sizeof(i8); i8_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; i8_type.arb = primitive_ffi_arb(((AType)&i8_type)); A_push_type(&i8_type); return (bool)1; } }
#pragma pack(push, 1)
# 1931 "/home/kalen/src/A/src/A.c"
 A i16_header; i16_f i16_type;
# 1931 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1931 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_i16() { i16_f* type_ref = &i16_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_i16); return (bool)0; } else { memset(type_ref, 0, sizeof(i16_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(i16_type) / sizeof(void*)]; i16_type.parent_type = &numeric_type; i16_type.name = "i16"; i16_type.members = members; i16_type.size = sizeof(i16); i16_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; i16_type.arb = primitive_ffi_arb(((AType)&i16_type)); A_push_type(&i16_type); return (bool)1; } }
#pragma pack(push, 1)
# 1932 "/home/kalen/src/A/src/A.c"
 A i32_header; i32_f i32_type;
# 1932 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1932 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_i32() { i32_f* type_ref = &i32_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_i32); return (bool)0; } else { memset(type_ref, 0, sizeof(i32_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(i32_type) / sizeof(void*)]; i32_type.parent_type = &numeric_type; i32_type.name = "i32"; i32_type.members = members; i32_type.size = sizeof(i32); i32_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; i32_type.arb = primitive_ffi_arb(((AType)&i32_type)); A_push_type(&i32_type); return (bool)1; } }
#pragma pack(push, 1)
# 1933 "/home/kalen/src/A/src/A.c"
 A i64_header; i64_f i64_type;
# 1933 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1933 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_i64() { i64_f* type_ref = &i64_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_i64); return (bool)0; } else { memset(type_ref, 0, sizeof(i64_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(i64_type) / sizeof(void*)]; i64_type.parent_type = &numeric_type; i64_type.name = "i64"; i64_type.members = members; i64_type.size = sizeof(i64); i64_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; i64_type.arb = primitive_ffi_arb(((AType)&i64_type)); A_push_type(&i64_type); return (bool)1; } }
#pragma pack(push, 1)
# 1934 "/home/kalen/src/A/src/A.c"
 A bool_header; bool_f bool_type;
# 1934 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1934 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_bool() { bool_f* type_ref = &bool_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_bool); return (bool)0; } else { memset(type_ref, 0, sizeof(bool_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(bool_type) / sizeof(void*)]; bool_type.parent_type = &numeric_type; bool_type.name = "bool"; bool_type.members = members; bool_type.size = sizeof(bool); bool_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_UNSIGNED | A_TRAIT_PRIMITIVE; bool_type.arb = primitive_ffi_arb(((AType)&bool_type)); A_push_type(&bool_type); return (bool)1; } }
#pragma pack(push, 1)
# 1935 "/home/kalen/src/A/src/A.c"
 A num_header; num_f num_type;
# 1935 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1935 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_num() { num_f* type_ref = &num_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_num); return (bool)0; } else { memset(type_ref, 0, sizeof(num_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(num_type) / sizeof(void*)]; num_type.parent_type = &numeric_type; num_type.name = "num"; num_type.members = members; num_type.size = sizeof(num); num_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; num_type.arb = primitive_ffi_arb(((AType)&num_type)); A_push_type(&num_type); return (bool)1; } }
#pragma pack(push, 1)
# 1936 "/home/kalen/src/A/src/A.c"
 A sz_header; sz_f sz_type;
# 1936 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1936 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_sz() { sz_f* type_ref = &sz_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_sz); return (bool)0; } else { memset(type_ref, 0, sizeof(sz_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(sz_type) / sizeof(void*)]; sz_type.parent_type = &numeric_type; sz_type.name = "sz"; sz_type.members = members; sz_type.size = sizeof(sz); sz_type.traits = A_TRAIT_INTEGRAL | A_TRAIT_SIGNED | A_TRAIT_PRIMITIVE; sz_type.arb = primitive_ffi_arb(((AType)&sz_type)); A_push_type(&sz_type); return (bool)1; } }
#pragma pack(push, 1)
# 1937 "/home/kalen/src/A/src/A.c"
 A f32_header; f32_f f32_type;
# 1937 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1937 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_f32() { f32_f* type_ref = &f32_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_f32); return (bool)0; } else { memset(type_ref, 0, sizeof(f32_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(f32_type) / sizeof(void*)]; f32_type.parent_type = &numeric_type; f32_type.name = "f32"; f32_type.members = members; f32_type.size = sizeof(f32); f32_type.traits = A_TRAIT_REALISTIC | A_TRAIT_PRIMITIVE; f32_type.arb = primitive_ffi_arb(((AType)&f32_type)); A_push_type(&f32_type); return (bool)1; } }
#pragma pack(push, 1)
# 1938 "/home/kalen/src/A/src/A.c"
 A f64_header; f64_f f64_type;
# 1938 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1938 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_f64() { f64_f* type_ref = &f64_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_f64); return (bool)0; } else { memset(type_ref, 0, sizeof(f64_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(f64_type) / sizeof(void*)]; f64_type.parent_type = &numeric_type; f64_type.name = "f64"; f64_type.members = members; f64_type.size = sizeof(f64); f64_type.traits = A_TRAIT_REALISTIC | A_TRAIT_PRIMITIVE; f64_type.arb = primitive_ffi_arb(((AType)&f64_type)); A_push_type(&f64_type); return (bool)1; } }
#pragma pack(push, 1)
# 1939 "/home/kalen/src/A/src/A.c"
 A f128_header; f128_f f128_type;
# 1939 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1939 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_f128() { f128_f* type_ref = &f128_type; numeric_f* base_ref = &numeric_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_f128); return (bool)0; } else { memset(type_ref, 0, sizeof(f128_f)); memcpy(type_ref, base_ref, sizeof(numeric_f)); static type_member_t members[16 + sizeof(f128_type) / sizeof(void*)]; f128_type.parent_type = &numeric_type; f128_type.name = "f128"; f128_type.members = members; f128_type.size = sizeof(f128); f128_type.traits = A_TRAIT_REALISTIC | A_TRAIT_PRIMITIVE; f128_type.arb = primitive_ffi_arb(((AType)&f128_type)); A_push_type(&f128_type); return (bool)1; } }
#pragma pack(push, 1)
# 1940 "/home/kalen/src/A/src/A.c"
 A cstr_header; cstr_f cstr_type;
# 1940 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1940 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_cstr() { cstr_f* type_ref = &cstr_type; string_like_f* base_ref = &string_like_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_cstr); return (bool)0; } else { memset(type_ref, 0, sizeof(cstr_f)); memcpy(type_ref, base_ref, sizeof(string_like_f)); static type_member_t members[16 + sizeof(cstr_type) / sizeof(void*)]; cstr_type.parent_type = &string_like_type; cstr_type.name = "cstr"; cstr_type.members = members; cstr_type.size = sizeof(cstr); cstr_type.traits = 0 | A_TRAIT_PRIMITIVE; cstr_type.arb = primitive_ffi_arb(((AType)&cstr_type)); A_push_type(&cstr_type); return (bool)1; } }
#pragma pack(push, 1)
# 1941 "/home/kalen/src/A/src/A.c"
 A symbol_header; symbol_f symbol_type;
# 1941 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1941 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_symbol() { symbol_f* type_ref = &symbol_type; string_like_f* base_ref = &string_like_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_symbol); return (bool)0; } else { memset(type_ref, 0, sizeof(symbol_f)); memcpy(type_ref, base_ref, sizeof(string_like_f)); static type_member_t members[16 + sizeof(symbol_type) / sizeof(void*)]; symbol_type.parent_type = &string_like_type; symbol_type.name = "symbol"; symbol_type.members = members; symbol_type.size = sizeof(symbol); symbol_type.traits = 0 | A_TRAIT_PRIMITIVE; symbol_type.arb = primitive_ffi_arb(((AType)&symbol_type)); A_push_type(&symbol_type); return (bool)1; } }
#pragma pack(push, 1)
# 1942 "/home/kalen/src/A/src/A.c"
 A cereal_header; cereal_f cereal_type;
# 1942 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1942 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_cereal() { cereal_f* type_ref = &cereal_type; string_like_f* base_ref = &string_like_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_cereal); return (bool)0; } else { memset(type_ref, 0, sizeof(cereal_f)); memcpy(type_ref, base_ref, sizeof(string_like_f)); static type_member_t members[16 + sizeof(cereal_type) / sizeof(void*)]; cereal_type.parent_type = &string_like_type; cereal_type.name = "cereal"; cereal_type.members = members; cereal_type.size = sizeof(cereal); cereal_type.traits = 0 | A_TRAIT_PRIMITIVE; cereal_type.arb = primitive_ffi_arb(((AType)&cereal_type)); A_push_type(&cereal_type); return (bool)1; } }
#pragma pack(push, 1)
# 1943 "/home/kalen/src/A/src/A.c"
 A none_header; none_f none_type;
# 1943 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1943 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_none() { none_f* type_ref = &none_type; nil_f* base_ref = &nil_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_none); return (bool)0; } else { memset(type_ref, 0, sizeof(none_f)); memcpy(type_ref, base_ref, sizeof(nil_f)); static type_member_t members[16 + sizeof(none_type) / sizeof(void*)]; none_type.parent_type = &nil_type; none_type.name = "none"; none_type.members = members; none_type.size = sizeof(none); none_type.traits = 0 | A_TRAIT_PRIMITIVE; none_type.arb = primitive_ffi_arb(((AType)&none_type)); A_push_type(&none_type); return (bool)1; } }
#pragma pack(push, 1)
# 1944 "/home/kalen/src/A/src/A.c"
 A AType_header; AType_f AType_type;
# 1944 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1944 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_AType() { AType_f* type_ref = &AType_type; raw_f* base_ref = &raw_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_AType); return (bool)0; } else { memset(type_ref, 0, sizeof(AType_f)); memcpy(type_ref, base_ref, sizeof(raw_f)); static type_member_t members[16 + sizeof(AType_type) / sizeof(void*)]; AType_type.parent_type = &raw_type; AType_type.name = "AType"; AType_type.members = members; AType_type.size = sizeof(AType); AType_type.traits = 0 | A_TRAIT_PRIMITIVE; AType_type.arb = primitive_ffi_arb(((AType)&AType_type)); A_push_type(&AType_type); return (bool)1; } }
#pragma pack(push, 1)
# 1945 "/home/kalen/src/A/src/A.c"
 A handle_header; handle_f handle_type;
# 1945 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1945 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_handle() { handle_f* type_ref = &handle_type; raw_f* base_ref = &raw_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_handle); return (bool)0; } else { memset(type_ref, 0, sizeof(handle_f)); memcpy(type_ref, base_ref, sizeof(raw_f)); static type_member_t members[16 + sizeof(handle_type) / sizeof(void*)]; handle_type.parent_type = &raw_type; handle_type.name = "handle"; handle_type.members = members; handle_type.size = sizeof(handle); handle_type.traits = 0 | A_TRAIT_PRIMITIVE; handle_type.arb = primitive_ffi_arb(((AType)&handle_type)); A_push_type(&handle_type); return (bool)1; } }
#pragma pack(push, 1)
# 1946 "/home/kalen/src/A/src/A.c"
 A Member_header; Member_f Member_type;
# 1946 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1946 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_Member() { Member_f* type_ref = &Member_type; raw_f* base_ref = &raw_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_Member); return (bool)0; } else { memset(type_ref, 0, sizeof(Member_f)); memcpy(type_ref, base_ref, sizeof(raw_f)); static type_member_t members[16 + sizeof(Member_type) / sizeof(void*)]; Member_type.parent_type = &raw_type; Member_type.name = "Member"; Member_type.members = members; Member_type.size = sizeof(Member); Member_type.traits = 0 | A_TRAIT_PRIMITIVE; Member_type.arb = primitive_ffi_arb(((AType)&Member_type)); A_push_type(&Member_type); return (bool)1; } }
#pragma pack(push, 1)
# 1947 "/home/kalen/src/A/src/A.c"
 A ARef_header; ARef_f ARef_type;
# 1947 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1947 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_ARef() { ARef_f* type_ref = &ARef_type; ref_f* base_ref = &ref_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_ARef); return (bool)0; } else { memset(type_ref, 0, sizeof(ARef_f)); memcpy(type_ref, base_ref, sizeof(ref_f)); static type_member_t members[16 + sizeof(ARef_type) / sizeof(void*)]; ARef_type.parent_type = &ref_type; ARef_type.name = "ARef"; ARef_type.members = members; ARef_type.size = sizeof(ARef); ARef_type.traits = 0 | A_TRAIT_PRIMITIVE; ARef_type.arb = primitive_ffi_arb(((AType)&ARef_type)); A_push_type(&ARef_type); return (bool)1; } };

#pragma pack(push, 1)
# 1949 "/home/kalen/src/A/src/A.c"
 struct A OPType_redirect; OPType_f OPType_type;
# 1949 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1949 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_OPType() { memset(&OPType_redirect, 0, sizeof(OPType_redirect)); OPType_redirect.type = &OPType_type; OPType_f* type_ref = &OPType_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_OPType); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + OPType_ENUM_COUNT + sizeof(OPType_type) / sizeof(void*)]; memset(&OPType_type, 0, sizeof(OPType_type)); OPType_type.parent_type = & A_type; OPType_type.name = "OPType"; OPType_type.size = sizeof(enum OPType); OPType_type.members = members; OPType_type.traits = A_TRAIT_ENUM; OPType_type.arb = primitive_ffi_arb(((AType)&i32_type)); OPType_type.members[OPType_type.member_count].name = "_add"; OPType_type.members[OPType_type.member_count].offset = OPType__add; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_sub"; OPType_type.members[OPType_type.member_count].offset = OPType__sub; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_mul"; OPType_type.members[OPType_type.member_count].offset = OPType__mul; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_div"; OPType_type.members[OPType_type.member_count].offset = OPType__div; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_or"; OPType_type.members[OPType_type.member_count].offset = OPType__or; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_and"; OPType_type.members[OPType_type.member_count].offset = OPType__and; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_xor"; OPType_type.members[OPType_type.member_count].offset = OPType__xor; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_right"; OPType_type.members[OPType_type.member_count].offset = OPType__right; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_left"; OPType_type.members[OPType_type.member_count].offset = OPType__left; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_compare_equal"; OPType_type.members[OPType_type.member_count].offset = OPType__compare_equal; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_compare_not"; OPType_type.members[OPType_type.member_count].offset = OPType__compare_not; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_is"; OPType_type.members[OPType_type.member_count].offset = OPType__is; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_inherits"; OPType_type.members[OPType_type.member_count].offset = OPType__inherits; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign"; OPType_type.members[OPType_type.member_count].offset = OPType__assign; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_add"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_add; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_sub"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_sub; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_mul"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_mul; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_div"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_div; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_or"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_or; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_and"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_and; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_xor"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_xor; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_right"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_right; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_assign_left"; OPType_type.members[OPType_type.member_count].offset = OPType__assign_left; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++; OPType_type.members[OPType_type.member_count].name = "_mod_assign"; OPType_type.members[OPType_type.member_count].offset = OPType__mod_assign; OPType_type.members[OPType_type.member_count].type = &i32_type; OPType_type.members[OPType_type.member_count].member_type = A_TYPE_ENUMV; OPType_type.member_count++;; A_push_type(&OPType_type); return (bool)1; } }
#pragma pack(push, 1)
# 1950 "/home/kalen/src/A/src/A.c"
 struct A Exists_redirect; Exists_f Exists_type;
# 1950 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1950 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_Exists() { memset(&Exists_redirect, 0, sizeof(Exists_redirect)); Exists_redirect.type = &Exists_type; Exists_f* type_ref = &Exists_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_Exists); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + Exists_ENUM_COUNT + sizeof(Exists_type) / sizeof(void*)]; memset(&Exists_type, 0, sizeof(Exists_type)); Exists_type.parent_type = & A_type; Exists_type.name = "Exists"; Exists_type.size = sizeof(enum Exists); Exists_type.members = members; Exists_type.traits = A_TRAIT_ENUM; Exists_type.arb = primitive_ffi_arb(((AType)&i32_type)); Exists_type.members[Exists_type.member_count].name = "no"; Exists_type.members[Exists_type.member_count].offset = Exists_no; Exists_type.members[Exists_type.member_count].type = &i32_type; Exists_type.members[Exists_type.member_count].member_type = A_TYPE_ENUMV; Exists_type.member_count++; Exists_type.members[Exists_type.member_count].name = "file"; Exists_type.members[Exists_type.member_count].offset = Exists_file; Exists_type.members[Exists_type.member_count].type = &i32_type; Exists_type.members[Exists_type.member_count].member_type = A_TYPE_ENUMV; Exists_type.member_count++; Exists_type.members[Exists_type.member_count].name = "dir"; Exists_type.members[Exists_type.member_count].offset = Exists_dir; Exists_type.members[Exists_type.member_count].type = &i32_type; Exists_type.members[Exists_type.member_count].member_type = A_TYPE_ENUMV; Exists_type.member_count++;; A_push_type(&Exists_type); return (bool)1; } }
#pragma pack(push, 1)
# 1951 "/home/kalen/src/A/src/A.c"
 struct A level_redirect; level_f level_type;
# 1951 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1951 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_level() { memset(&level_redirect, 0, sizeof(level_redirect)); level_redirect.type = &level_type; level_f* type_ref = &level_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_level); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + level_ENUM_COUNT + sizeof(level_type) / sizeof(void*)]; memset(&level_type, 0, sizeof(level_type)); level_type.parent_type = & A_type; level_type.name = "level"; level_type.size = sizeof(enum level); level_type.members = members; level_type.traits = A_TRAIT_ENUM; level_type.arb = primitive_ffi_arb(((AType)&i32_type)); level_type.members[level_type.member_count].name = "info"; level_type.members[level_type.member_count].offset = level_info; level_type.members[level_type.member_count].type = &i32_type; level_type.members[level_type.member_count].member_type = A_TYPE_ENUMV; level_type.member_count++; level_type.members[level_type.member_count].name = "warn"; level_type.members[level_type.member_count].offset = level_warn; level_type.members[level_type.member_count].type = &i32_type; level_type.members[level_type.member_count].member_type = A_TYPE_ENUMV; level_type.member_count++; level_type.members[level_type.member_count].name = "err"; level_type.members[level_type.member_count].offset = level_err; level_type.members[level_type.member_count].type = &i32_type; level_type.members[level_type.member_count].member_type = A_TYPE_ENUMV; level_type.member_count++;; A_push_type(&level_type); return (bool)1; } }

#pragma pack(push, 1)
# 1953 "/home/kalen/src/A/src/A.c"
 A path_header; path_f path_type;
# 1953 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1953 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_path() { path_f* type_ref = &path_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_path); return (bool)0; } else { memset(type_ref, 0, sizeof(path_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(path_type) / sizeof(void*)]; path_type.parent_type = &A_type; path_type.name = "path"; path_type.members = members; path_type.size = sizeof(struct path); path_type.traits = 0; path_type.arb = primitive_ffi_arb(((AType)&cstr_type)); path_type.members[path_type.member_count].name = "chars"; path_type.members[path_type.member_count].offset = __builtin_offsetof(struct path, chars); path_type.members[path_type.member_count].type = (AType)&cstr_type; path_type.members[path_type.member_count].member_type = A_TYPE_PROP; path_type.member_count++; path_type . exists = & path_exists; path_type.members[path_type.member_count].name = "exists"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&bool_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, exists); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . make_dir = & path_make_dir; path_type.members[path_type.member_count].name = "make_dir"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&bool_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, make_dir); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . is_empty = & path_is_empty; path_type.members[path_type.member_count].name = "is_empty"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&bool_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, is_empty); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . is_dir = & path_is_dir; path_type.members[path_type.member_count].name = "is_dir"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&bool_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, is_dir); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . directory = & path_directory; path_type.members[path_type.member_count].name = "directory"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&path_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, directory); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . stem = & path_stem; path_type.members[path_type.member_count].name = "stem"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&string_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, stem); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . ext = & path_ext; path_type.members[path_type.member_count].name = "ext"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&string_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, ext); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . filename = & path_filename; path_type.members[path_type.member_count].name = "filename"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&string_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, filename); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . absolute = & path_absolute; path_type.members[path_type.member_count].name = "absolute"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&path_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, absolute); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . parent = & path_parent; path_type.members[path_type.member_count].name = "parent"; path_type.members[path_type.member_count].args = (meta_t) { 2, &path_type, &path_type }; path_type.members[path_type.member_count].type = (AType)&path_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, parent); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . read = & path_read; path_type.members[path_type.member_count].name = "read"; path_type.members[path_type.member_count].args = (meta_t) { 3, &path_type, &path_type, &AType_type }; path_type.members[path_type.member_count].type = (AType)&A_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, read); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . change_ext = & path_change_ext; path_type.members[path_type.member_count].name = "change_ext"; path_type.members[path_type.member_count].args = (meta_t) { 3, &path_type, &path_type, &cstr_type }; path_type.members[path_type.member_count].type = (AType)&path_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, change_ext); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . ls = & path_ls; path_type.members[path_type.member_count].name = "ls"; path_type.members[path_type.member_count].args = (meta_t) { 4, &path_type, &path_type, &string_type, &bool_type }; path_type.members[path_type.member_count].type = (AType)&array_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, ls); path_type.members[path_type.member_count].member_type = A_TYPE_IMETHOD; path_type.member_count++; path_type . cwd = & path_cwd; path_type.members[path_type.member_count].name = "cwd"; path_type.members[path_type.member_count].args = (meta_t) { 1, &sz_type }; path_type.members[path_type.member_count].type = (AType)&path_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, cwd); path_type.members[path_type.member_count].member_type = A_TYPE_SMETHOD; path_type.member_count++; path_type.with_string = & path_with_string; path_type.members[path_type.member_count].name = "with_string"; path_type.members[path_type.member_count].args = (meta_t) { 1, &string_type }; path_type.members[path_type.member_count].type = &string_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, with_string); path_type.members[path_type.member_count].member_type = A_TYPE_CONSTRUCT; path_type.member_count++; path_type.cast_cstr = & path_cast_cstr; path_type.members[path_type.member_count].name = "combine_tokens(cast_, cstr)"; path_type.members[path_type.member_count].args = (meta_t) { 1, &path_type }; path_type.members[path_type.member_count].type = (AType)&cstr_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, cast_cstr); path_type.members[path_type.member_count].member_type = A_TYPE_CAST; path_type.member_count++; path_type.cast_sz = & path_cast_sz; path_type.members[path_type.member_count].name = "combine_tokens(cast_, sz)"; path_type.members[path_type.member_count].args = (meta_t) { 1, &path_type }; path_type.members[path_type.member_count].type = (AType)&sz_type; path_type.members[path_type.member_count].offset = __builtin_offsetof(path_f, cast_sz); path_type.members[path_type.member_count].member_type = A_TYPE_CAST; path_type.member_count++; path_type . with_cereal = & path_with_cereal; path_type . hash = & path_hash; path_type . init = & path_init; path_type . cast_bool = & path_cast_bool; path_type . cast_string = & path_cast_string; A_push_type(&path_type); return (bool)1; } }
#pragma pack(push, 1)
# 1954 "/home/kalen/src/A/src/A.c"
 A file_header; file_f file_type;
# 1954 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1954 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_file() { file_f* type_ref = &file_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_file); return (bool)0; } else { memset(type_ref, 0, sizeof(file_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(file_type) / sizeof(void*)]; file_type.parent_type = &A_type; file_type.name = "file"; file_type.members = members; file_type.size = sizeof(struct file); file_type.traits = 0; file_type.arb = primitive_ffi_arb(((AType)&cstr_type)); file_type . write = & file_write; file_type.members[file_type.member_count].name = "write"; file_type.members[file_type.member_count].args = (meta_t) { 3, &file_type, &file_type, &object_type }; file_type.members[file_type.member_count].type = (AType)&bool_type; file_type.members[file_type.member_count].offset = __builtin_offsetof(file_f, write); file_type.members[file_type.member_count].member_type = A_TYPE_IMETHOD; file_type.member_count++; file_type . read = & file_read; file_type.members[file_type.member_count].name = "read"; file_type.members[file_type.member_count].args = (meta_t) { 3, &file_type, &file_type, &AType_type }; file_type.members[file_type.member_count].type = (AType)&bool_type; file_type.members[file_type.member_count].offset = __builtin_offsetof(file_f, read); file_type.members[file_type.member_count].member_type = A_TYPE_IMETHOD; file_type.member_count++; file_type . close = & file_close; file_type.members[file_type.member_count].name = "close"; file_type.members[file_type.member_count].args = (meta_t) { 2, &file_type, &file_type }; file_type.members[file_type.member_count].type = (AType)&none_type; file_type.members[file_type.member_count].offset = __builtin_offsetof(file_f, close); file_type.members[file_type.member_count].member_type = A_TYPE_IMETHOD; file_type.member_count++; file_type.members[file_type.member_count].required = (bool)1; file_type.members[file_type.member_count].name = "src"; file_type.members[file_type.member_count].offset = __builtin_offsetof(struct file, src); file_type.members[file_type.member_count].type = (AType)&path_type; file_type.members[file_type.member_count].member_type = A_TYPE_PROP; file_type.member_count++; file_type.members[file_type.member_count].name = "read"; file_type.members[file_type.member_count].offset = __builtin_offsetof(struct file, read); file_type.members[file_type.member_count].type = (AType)&bool_type; file_type.members[file_type.member_count].member_type = A_TYPE_PROP; file_type.member_count++; file_type.members[file_type.member_count].name = "write"; file_type.members[file_type.member_count].offset = __builtin_offsetof(struct file, write); file_type.members[file_type.member_count].type = (AType)&bool_type; file_type.members[file_type.member_count].member_type = A_TYPE_PROP; file_type.member_count++; file_type . init = & file_init; file_type . destructor = & file_destructor; A_push_type(&file_type); return (bool)1; } }
#pragma pack(push, 1)
# 1955 "/home/kalen/src/A/src/A.c"
 A string_header; string_f string_type;
# 1955 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1955 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_string() { string_f* type_ref = &string_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_string); return (bool)0; } else { memset(type_ref, 0, sizeof(string_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(string_type) / sizeof(void*)]; string_type.parent_type = &A_type; string_type.name = "string"; string_type.members = members; string_type.size = sizeof(struct string); string_type.traits = 0; string_type.arb = primitive_ffi_arb(((AType)&cstr_type)); string_type.members[string_type.member_count].name = "chars"; string_type.members[string_type.member_count].offset = __builtin_offsetof(struct string, chars); string_type.members[string_type.member_count].type = (AType)&cstr_type; string_type.members[string_type.member_count].member_type = A_TYPE_PROP; string_type.member_count++; string_type.members[string_type.member_count].name = "alloc"; string_type.members[string_type.member_count].offset = __builtin_offsetof(struct string, alloc); string_type.members[string_type.member_count].type = (AType)&num_type; string_type.members[string_type.member_count].member_type = A_TYPE_PROP; string_type.member_count++; string_type.members[string_type.member_count].name = "ref_length"; string_type.members[string_type.member_count].offset = __builtin_offsetof(struct string, ref_length); string_type.members[string_type.member_count].type = (AType)&num_type; string_type.members[string_type.member_count].member_type = A_TYPE_PROP; string_type.member_count++; string_type.members[string_type.member_count].name = "len"; string_type.members[string_type.member_count].offset = __builtin_offsetof(struct string, len); string_type.members[string_type.member_count].type = (AType)&num_type; string_type.members[string_type.member_count].member_type = A_TYPE_PROP; string_type.member_count++; string_type.members[string_type.member_count].name = "h"; string_type.members[string_type.member_count].offset = __builtin_offsetof(struct string, h); string_type.members[string_type.member_count].type = (AType)&u64_type; string_type.members[string_type.member_count].member_type = A_TYPE_PROP; string_type.member_count++; string_type . len = & string_len; string_type.members[string_type.member_count].name = "len"; string_type.members[string_type.member_count].args = (meta_t) { 2, &string_type, &string_type }; string_type.members[string_type.member_count].type = (AType)&sz_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, len); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . split = & string_split; string_type.members[string_type.member_count].name = "split"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&array_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, split); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . index_of = & string_index_of; string_type.members[string_type.member_count].name = "index_of"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&num_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, index_of); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . append = & string_append; string_type.members[string_type.member_count].name = "append"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&none_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, append); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . mid = & string_mid; string_type.members[string_type.member_count].name = "mid"; string_type.members[string_type.member_count].args = (meta_t) { 4, &string_type, &string_type, &num_type, &num_type }; string_type.members[string_type.member_count].type = (AType)&string_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, mid); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . reserve = & string_reserve; string_type.members[string_type.member_count].name = "reserve"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &num_type }; string_type.members[string_type.member_count].type = (AType)&none_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, reserve); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . write = & string_write; string_type.members[string_type.member_count].name = "write"; string_type.members[string_type.member_count].args = (meta_t) { 4, &string_type, &string_type, &handle_type, &bool_type }; string_type.members[string_type.member_count].type = (AType)&none_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, write); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . has_suffix = & string_has_suffix; string_type.members[string_type.member_count].name = "has_suffix"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&bool_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, has_suffix); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . cmp = & string_cmp; string_type.members[string_type.member_count].name = "cmp"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&num_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, cmp); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . eq = & string_eq; string_type.members[string_type.member_count].name = "eq"; string_type.members[string_type.member_count].args = (meta_t) { 3, &string_type, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = (AType)&bool_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, eq); string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type.cast_cstr = & string_cast_cstr; string_type.members[string_type.member_count].name = "combine_tokens(cast_, cstr)"; string_type.members[string_type.member_count].args = (meta_t) { 1, &string_type }; string_type.members[string_type.member_count].type = (AType)&cstr_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, cast_cstr); string_type.members[string_type.member_count].member_type = A_TYPE_CAST; string_type.member_count++; string_type.cast_sz = & string_cast_sz; string_type.members[string_type.member_count].name = "combine_tokens(cast_, sz)"; string_type.members[string_type.member_count].args = (meta_t) { 1, &string_type }; string_type.members[string_type.member_count].type = (AType)&sz_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, cast_sz); string_type.members[string_type.member_count].member_type = A_TYPE_CAST; string_type.member_count++; string_type.cast_path = & string_cast_path; string_type.members[string_type.member_count].name = "combine_tokens(cast_, path)"; string_type.members[string_type.member_count].args = (meta_t) { 1, &string_type }; string_type.members[string_type.member_count].type = (AType)&path_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, cast_path); string_type.members[string_type.member_count].member_type = A_TYPE_CAST; string_type.member_count++; string_type.with_cstr = & string_with_cstr; string_type.members[string_type.member_count].name = "with_cstr"; string_type.members[string_type.member_count].args = (meta_t) { 1, &cstr_type }; string_type.members[string_type.member_count].type = &cstr_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, with_cstr); string_type.members[string_type.member_count].member_type = A_TYPE_CONSTRUCT; string_type.member_count++; string_type.index_num = & string_index_num; string_type.members[string_type.member_count].name = "emit_idx_symbol(index, num)"; string_type.members[string_type.member_count].args = (meta_t) { 2, &string_type, &num_type }; string_type.members[string_type.member_count].type = (AType)&i32_type; string_type.members[string_type.member_count].offset = __builtin_offsetof(string_f, index_num); string_type.members[string_type.member_count].member_type = A_TYPE_INDEX; string_type.member_count++; string_type . hash = & string_hash; string_type . compare = & string_compare; string_type . init = & string_init; string_type . cast_bool = & string_cast_bool; A_push_type(&string_type); return (bool)1; } }
#pragma pack(push, 1)
# 1956 "/home/kalen/src/A/src/A.c"
 A item_header; item_f item_type;
# 1956 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1956 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_item() { item_f* type_ref = &item_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_item); return (bool)0; } else { memset(type_ref, 0, sizeof(item_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(item_type) / sizeof(void*)]; item_type.parent_type = &A_type; item_type.name = "item"; item_type.members = members; item_type.size = sizeof(struct item); item_type.traits = 0; item_type.arb = primitive_ffi_arb(((AType)&cstr_type)); item_type.members[item_type.member_count].name = "next"; item_type.members[item_type.member_count].offset = __builtin_offsetof(struct item, next); item_type.members[item_type.member_count].type = (AType)&item_type; item_type.members[item_type.member_count].member_type = A_TYPE_PROP; item_type.member_count++; item_type.members[item_type.member_count].name = "prev"; item_type.members[item_type.member_count].offset = __builtin_offsetof(struct item, prev); item_type.members[item_type.member_count].type = (AType)&item_type; item_type.members[item_type.member_count].member_type = A_TYPE_PROP; item_type.member_count++; item_type.members[item_type.member_count].name = "value"; item_type.members[item_type.member_count].offset = __builtin_offsetof(struct item, value); item_type.members[item_type.member_count].type = (AType)&A_type; item_type.members[item_type.member_count].member_type = A_TYPE_PROP; item_type.member_count++; item_type.members[item_type.member_count].name = "key"; item_type.members[item_type.member_count].offset = __builtin_offsetof(struct item, key); item_type.members[item_type.member_count].type = (AType)&A_type; item_type.members[item_type.member_count].member_type = A_TYPE_PROP; item_type.member_count++; item_type . hash = & item_hash; A_push_type(&item_type); return (bool)1; } }

#pragma pack(push, 1)
# 1958 "/home/kalen/src/A/src/A.c"
 A list_header; list_f list_type;
# 1958 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1958 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_list() { list_f* type_ref = &list_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_list); return (bool)0; } else { memset(type_ref, 0, sizeof(list_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(list_type) / sizeof(void*)]; list_type.parent_type = &A_type; list_type.name = "list"; list_type.members = members; list_type.size = sizeof(struct list); list_type.traits = 0; list_type.arb = primitive_ffi_arb(((AType)&cstr_type)); list_type.members[list_type.member_count].name = "first"; list_type.members[list_type.member_count].offset = __builtin_offsetof(struct list, first); list_type.members[list_type.member_count].type = (AType)&item_type; list_type.members[list_type.member_count].member_type = A_TYPE_PROP; list_type.member_count++; list_type.members[list_type.member_count].name = "last"; list_type.members[list_type.member_count].offset = __builtin_offsetof(struct list, last); list_type.members[list_type.member_count].type = (AType)&item_type; list_type.members[list_type.member_count].member_type = A_TYPE_PROP; list_type.member_count++; list_type.members[list_type.member_count].name = "count"; list_type.members[list_type.member_count].offset = __builtin_offsetof(struct list, count); list_type.members[list_type.member_count].type = (AType)&i64_type; list_type.members[list_type.member_count].member_type = A_TYPE_PROP; list_type.member_count++; list_type . pop = & list_pop; list_type.members[list_type.member_count].name = "pop"; list_type.members[list_type.member_count].args = (meta_t) { 2, &list_type, &list_type }; list_type.members[list_type.member_count].type = (AType)&A_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, pop); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . push = & list_push; list_type.members[list_type.member_count].name = "push"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &A_type }; list_type.members[list_type.member_count].type = (AType)&item_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, push); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . index_of = & list_index_of; list_type.members[list_type.member_count].name = "index_of"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &A_type }; list_type.members[list_type.member_count].type = (AType)&num_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, index_of); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . item_of = & list_item_of; list_type.members[list_type.member_count].name = "item_of"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &A_type }; list_type.members[list_type.member_count].type = (AType)&item_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, item_of); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . remove = & list_remove; list_type.members[list_type.member_count].name = "remove"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &num_type }; list_type.members[list_type.member_count].type = (AType)&none_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, remove); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . remove_item = & list_remove_item; list_type.members[list_type.member_count].name = "remove_item"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &item_type }; list_type.members[list_type.member_count].type = (AType)&none_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, remove_item); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . get = & list_get; list_type.members[list_type.member_count].name = "get"; list_type.members[list_type.member_count].args = (meta_t) { 3, &list_type, &list_type, &A_type }; list_type.members[list_type.member_count].type = (AType)&A_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, get); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . count = & list_count; list_type.members[list_type.member_count].name = "count"; list_type.members[list_type.member_count].args = (meta_t) { 2, &list_type, &list_type }; list_type.members[list_type.member_count].type = (AType)&num_type; list_type.members[list_type.member_count].offset = __builtin_offsetof(list_f, count); list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; A_push_type(&list_type); return (bool)1; } }
#pragma pack(push, 1)
# 1959 "/home/kalen/src/A/src/A.c"
 A array_header; array_f array_type;
# 1959 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1959 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_array() { array_f* type_ref = &array_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_array); return (bool)0; } else { memset(type_ref, 0, sizeof(array_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(array_type) / sizeof(void*)]; array_type.parent_type = &A_type; array_type.name = "array"; array_type.members = members; array_type.size = sizeof(struct array); array_type.traits = 0; array_type.arb = primitive_ffi_arb(((AType)&cstr_type)); array_type.members[array_type.member_count].name = "elements"; array_type.members[array_type.member_count].offset = __builtin_offsetof(struct array, elements); array_type.members[array_type.member_count].type = (AType)&ARef_type; array_type.members[array_type.member_count].member_type = A_TYPE_PROP; array_type.member_count++; array_type.members[array_type.member_count].name = "unmanaged"; array_type.members[array_type.member_count].offset = __builtin_offsetof(struct array, unmanaged); array_type.members[array_type.member_count].type = (AType)&bool_type; array_type.members[array_type.member_count].member_type = A_TYPE_PROP; array_type.member_count++; array_type.members[array_type.member_count].name = "alloc"; array_type.members[array_type.member_count].offset = __builtin_offsetof(struct array, alloc); array_type.members[array_type.member_count].type = (AType)&i32_type; array_type.members[array_type.member_count].member_type = A_TYPE_PROP; array_type.member_count++; array_type.members[array_type.member_count].name = "len"; array_type.members[array_type.member_count].offset = __builtin_offsetof(struct array, len); array_type.members[array_type.member_count].type = (AType)&i32_type; array_type.members[array_type.member_count].member_type = A_TYPE_PROP; array_type.member_count++; array_type . of = & array_of; array_type.members[array_type.member_count].name = "of"; array_type.members[array_type.member_count].args = (meta_t) { 1, &AType_type }; array_type.members[array_type.member_count].type = (AType)&array_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, of); array_type.members[array_type.member_count].member_type = A_TYPE_SMETHOD; array_type.member_count++; array_type . of_cstr = & array_of_cstr; array_type.members[array_type.member_count].name = "of_cstr"; array_type.members[array_type.member_count].args = (meta_t) { 1, &cstr_type }; array_type.members[array_type.member_count].type = (AType)&array_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, of_cstr); array_type.members[array_type.member_count].member_type = A_TYPE_SMETHOD; array_type.member_count++; array_type . first = & array_first; array_type.members[array_type.member_count].name = "first"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&A_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, first); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . last = & array_last; array_type.members[array_type.member_count].name = "last"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&A_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, last); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . pop = & array_pop; array_type.members[array_type.member_count].name = "pop"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&A_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, pop); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . remove = & array_remove; array_type.members[array_type.member_count].name = "remove"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &num_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, remove); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . remove_weak = & array_remove_weak; array_type.members[array_type.member_count].name = "remove_weak"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &num_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, remove_weak); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push = & array_push; array_type.members[array_type.member_count].name = "push"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &A_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, push); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push_weak = & array_push_weak; array_type.members[array_type.member_count].name = "push_weak"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &A_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, push_weak); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . clear = & array_clear; array_type.members[array_type.member_count].name = "clear"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, clear); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . concat = & array_concat; array_type.members[array_type.member_count].name = "concat"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, concat); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . get = & array_get; array_type.members[array_type.member_count].name = "get"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &num_type }; array_type.members[array_type.member_count].type = (AType)&A_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, get); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . count = & array_count; array_type.members[array_type.member_count].name = "count"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&num_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, count); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . len = & array_len; array_type.members[array_type.member_count].name = "len"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &array_type }; array_type.members[array_type.member_count].type = (AType)&sz_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, len); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . index_of = & array_index_of; array_type.members[array_type.member_count].name = "index_of"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &A_type }; array_type.members[array_type.member_count].type = (AType)&num_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, index_of); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . operator__assign_add = & array_operator__assign_add; array_type.members[array_type.member_count].name = "combine_tokens(operator_, _assign_add)"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, operator__assign_add); array_type.members[array_type.member_count].member_type = A_TYPE_OPERATOR; array_type.members[array_type.member_count].operator_type = OPType__assign_add; array_type.member_count++; array_type . operator__assign_sub = & array_operator__assign_sub; array_type.members[array_type.member_count].name = "combine_tokens(operator_, _assign_sub)"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &num_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, operator__assign_sub); array_type.members[array_type.member_count].member_type = A_TYPE_OPERATOR; array_type.members[array_type.member_count].operator_type = OPType__assign_sub; array_type.member_count++; array_type . push_symbols = & array_push_symbols; array_type.members[array_type.member_count].name = "push_symbols"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &cstr_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, push_symbols); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push_objects = & array_push_objects; array_type.members[array_type.member_count].name = "push_objects"; array_type.members[array_type.member_count].args = (meta_t) { 3, &array_type, &array_type, &A_type }; array_type.members[array_type.member_count].type = (AType)&none_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, push_objects); array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type.index_num = & array_index_num; array_type.members[array_type.member_count].name = "emit_idx_symbol(index, num)"; array_type.members[array_type.member_count].args = (meta_t) { 2, &array_type, &num_type }; array_type.members[array_type.member_count].type = (AType)&A_type; array_type.members[array_type.member_count].offset = __builtin_offsetof(array_f, index_num); array_type.members[array_type.member_count].member_type = A_TYPE_INDEX; array_type.member_count++; array_type . init = & array_init; array_type . cast_bool = & array_cast_bool; A_push_type(&array_type); return (bool)1; } }
#pragma pack(push, 1)
# 1960 "/home/kalen/src/A/src/A.c"
 A hashmap_header; hashmap_f hashmap_type;
# 1960 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1960 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_hashmap() { hashmap_f* type_ref = &hashmap_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_hashmap); return (bool)0; } else { memset(type_ref, 0, sizeof(hashmap_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(hashmap_type) / sizeof(void*)]; hashmap_type.parent_type = &A_type; hashmap_type.name = "hashmap"; hashmap_type.members = members; hashmap_type.size = sizeof(struct hashmap); hashmap_type.traits = 0; hashmap_type.arb = primitive_ffi_arb(((AType)&cstr_type)); hashmap_type.members[hashmap_type.member_count].name = "data"; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(struct hashmap, data); hashmap_type.members[hashmap_type.member_count].type = (AType)&list_type; hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_PROP; hashmap_type.member_count++; hashmap_type.members[hashmap_type.member_count].name = "alloc"; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(struct hashmap, alloc); hashmap_type.members[hashmap_type.member_count].type = (AType)&num_type; hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_PROP; hashmap_type.member_count++; hashmap_type.members[hashmap_type.member_count].name = "count"; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(struct hashmap, count); hashmap_type.members[hashmap_type.member_count].type = (AType)&num_type; hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_PROP; hashmap_type.member_count++; hashmap_type . remove = & hashmap_remove; hashmap_type.members[hashmap_type.member_count].name = "remove"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 3, &hashmap_type, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&none_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, remove); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type . set = & hashmap_set; hashmap_type.members[hashmap_type.member_count].name = "set"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 4, &hashmap_type, &hashmap_type, &A_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&none_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, set); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type . get = & hashmap_get; hashmap_type.members[hashmap_type.member_count].name = "get"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 3, &hashmap_type, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&A_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, get); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type . fetch = & hashmap_fetch; hashmap_type.members[hashmap_type.member_count].name = "fetch"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 3, &hashmap_type, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&item_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, fetch); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type . lookup = & hashmap_lookup; hashmap_type.members[hashmap_type.member_count].name = "lookup"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 3, &hashmap_type, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&item_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, lookup); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type . contains = & hashmap_contains; hashmap_type.members[hashmap_type.member_count].name = "contains"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 3, &hashmap_type, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&bool_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, contains); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_IMETHOD; hashmap_type.member_count++; hashmap_type.index_A = & hashmap_index_A; hashmap_type.members[hashmap_type.member_count].name = "emit_idx_symbol(index, A)"; hashmap_type.members[hashmap_type.member_count].args = (meta_t) { 2, &hashmap_type, &A_type }; hashmap_type.members[hashmap_type.member_count].type = (AType)&A_type; hashmap_type.members[hashmap_type.member_count].offset = __builtin_offsetof(hashmap_f, index_A); hashmap_type.members[hashmap_type.member_count].member_type = A_TYPE_INDEX; hashmap_type.member_count++; hashmap_type . cast_string = & hashmap_cast_string; hashmap_type . init = & hashmap_init; hashmap_type . cast_bool = & hashmap_cast_bool; A_push_type(&hashmap_type); return (bool)1; } }
#pragma pack(push, 1)
# 1961 "/home/kalen/src/A/src/A.c"
 A pair_header; pair_f pair_type;
# 1961 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1961 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_pair() { pair_f* type_ref = &pair_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_pair); return (bool)0; } else { memset(type_ref, 0, sizeof(pair_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(pair_type) / sizeof(void*)]; pair_type.parent_type = &A_type; pair_type.name = "pair"; pair_type.members = members; pair_type.size = sizeof(struct pair); pair_type.traits = 0; pair_type.arb = primitive_ffi_arb(((AType)&cstr_type)); pair_type.members[pair_type.member_count].name = "ref"; pair_type.members[pair_type.member_count].offset = __builtin_offsetof(struct pair, ref); pair_type.members[pair_type.member_count].type = (AType)&item_type; pair_type.members[pair_type.member_count].member_type = A_TYPE_PROP; pair_type.member_count++; pair_type.members[pair_type.member_count].name = "key"; pair_type.members[pair_type.member_count].offset = __builtin_offsetof(struct pair, key); pair_type.members[pair_type.member_count].type = (AType)&A_type; pair_type.members[pair_type.member_count].member_type = A_TYPE_PROP; pair_type.member_count++; pair_type.members[pair_type.member_count].name = "value"; pair_type.members[pair_type.member_count].offset = __builtin_offsetof(struct pair, value); pair_type.members[pair_type.member_count].type = (AType)&A_type; pair_type.members[pair_type.member_count].member_type = A_TYPE_PROP; pair_type.member_count++; A_push_type(&pair_type); return (bool)1; } }
#pragma pack(push, 1)
# 1962 "/home/kalen/src/A/src/A.c"
 A map_header; map_f map_type;
# 1962 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1962 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_map() { map_f* type_ref = &map_type; list_f* base_ref = &list_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_map); return (bool)0; } else { memset(type_ref, 0, sizeof(map_f)); memcpy(type_ref, base_ref, sizeof(list_f)); static type_member_t members[16 + sizeof(map_type) / sizeof(void*)]; map_type.parent_type = &list_type; map_type.name = "map"; map_type.members = members; map_type.size = sizeof(struct map); map_type.traits = 0; map_type.arb = primitive_ffi_arb(((AType)&cstr_type)); map_type.members[map_type.member_count].name = "hsize"; map_type.members[map_type.member_count].offset = __builtin_offsetof(struct map, hsize); map_type.members[map_type.member_count].type = (AType)&sz_type; map_type.members[map_type.member_count].member_type = A_TYPE_PROP; map_type.member_count++; map_type . set = & map_set; map_type.members[map_type.member_count].name = "set"; map_type.members[map_type.member_count].args = (meta_t) { 4, &map_type, &map_type, &A_type, &A_type }; map_type.members[map_type.member_count].type = (AType)&none_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, set); map_type.members[map_type.member_count].member_type = A_TYPE_IMETHOD; map_type.member_count++; map_type . fetch = & map_fetch; map_type.members[map_type.member_count].name = "fetch"; map_type.members[map_type.member_count].args = (meta_t) { 3, &map_type, &map_type, &A_type }; map_type.members[map_type.member_count].type = (AType)&item_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, fetch); map_type.members[map_type.member_count].member_type = A_TYPE_IMETHOD; map_type.member_count++; map_type . contains = & map_contains; map_type.members[map_type.member_count].name = "contains"; map_type.members[map_type.member_count].args = (meta_t) { 3, &map_type, &map_type, &A_type }; map_type.members[map_type.member_count].type = (AType)&bool_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, contains); map_type.members[map_type.member_count].member_type = A_TYPE_IMETHOD; map_type.member_count++; map_type . concat = & map_concat; map_type.members[map_type.member_count].name = "concat"; map_type.members[map_type.member_count].args = (meta_t) { 3, &map_type, &map_type, &map_type }; map_type.members[map_type.member_count].type = (AType)&none_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, concat); map_type.members[map_type.member_count].member_type = A_TYPE_IMETHOD; map_type.member_count++; map_type . len = & map_len; map_type.members[map_type.member_count].name = "len"; map_type.members[map_type.member_count].args = (meta_t) { 2, &map_type, &map_type }; map_type.members[map_type.member_count].type = (AType)&sz_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, len); map_type.members[map_type.member_count].member_type = A_TYPE_IMETHOD; map_type.member_count++; map_type.index_sz = & map_index_sz; map_type.members[map_type.member_count].name = "emit_idx_symbol(index, sz)"; map_type.members[map_type.member_count].args = (meta_t) { 2, &map_type, &sz_type }; map_type.members[map_type.member_count].type = (AType)&A_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, index_sz); map_type.members[map_type.member_count].member_type = A_TYPE_INDEX; map_type.member_count++; map_type.index_A = & map_index_A; map_type.members[map_type.member_count].name = "emit_idx_symbol(index, A)"; map_type.members[map_type.member_count].args = (meta_t) { 2, &map_type, &A_type }; map_type.members[map_type.member_count].type = (AType)&A_type; map_type.members[map_type.member_count].offset = __builtin_offsetof(map_f, index_A); map_type.members[map_type.member_count].member_type = A_TYPE_INDEX; map_type.member_count++; map_type . get = & map_get; map_type . init = & map_init; map_type . cast_string = & map_cast_string; map_type . cast_bool = & map_cast_bool; A_push_type(&map_type); return (bool)1; } }
#pragma pack(push, 1)
# 1963 "/home/kalen/src/A/src/A.c"
 A fn_header; fn_f fn_type;
# 1963 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1963 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_fn() { fn_f* type_ref = &fn_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_fn); return (bool)0; } else { memset(type_ref, 0, sizeof(fn_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(fn_type) / sizeof(void*)]; fn_type.parent_type = &A_type; fn_type.name = "fn"; fn_type.members = members; fn_type.size = sizeof(struct fn); fn_type.traits = 0; fn_type.arb = primitive_ffi_arb(((AType)&cstr_type)); fn_type.members[fn_type.member_count].name = "target"; fn_type.members[fn_type.member_count].offset = __builtin_offsetof(struct fn, target); fn_type.members[fn_type.member_count].type = (AType)&A_type; fn_type.members[fn_type.member_count].member_type = A_TYPE_PROP; fn_type.member_count++; fn_type.members[fn_type.member_count].name = "context"; fn_type.members[fn_type.member_count].offset = __builtin_offsetof(struct fn, context); fn_type.members[fn_type.member_count].type = (AType)&A_type; fn_type.members[fn_type.member_count].member_type = A_TYPE_PROP; fn_type.member_count++; fn_type . call = & fn_call; fn_type.members[fn_type.member_count].name = "call"; fn_type.members[fn_type.member_count].args = (meta_t) { 3, &fn_type, &fn_type, &array_type }; fn_type.members[fn_type.member_count].type = (AType)&A_type; fn_type.members[fn_type.member_count].offset = __builtin_offsetof(fn_f, call); fn_type.members[fn_type.member_count].member_type = A_TYPE_IMETHOD; fn_type.member_count++; fn_type . hash = & fn_hash; A_push_type(&fn_type); return (bool)1; } }
#pragma pack(push, 1)
# 1964 "/home/kalen/src/A/src/A.c"
 A subprocedure_header; subprocedure_f subprocedure_type;
# 1964 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1964 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_subprocedure() { subprocedure_f* type_ref = &subprocedure_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_subprocedure); return (bool)0; } else { memset(type_ref, 0, sizeof(subprocedure_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(subprocedure_type) / sizeof(void*)]; subprocedure_type.parent_type = &A_type; subprocedure_type.name = "subprocedure"; subprocedure_type.members = members; subprocedure_type.size = sizeof(struct subprocedure); subprocedure_type.traits = 0; subprocedure_type.arb = primitive_ffi_arb(((AType)&cstr_type)); subprocedure_type.members[subprocedure_type.member_count].required = (bool)1; subprocedure_type.members[subprocedure_type.member_count].name = "target"; subprocedure_type.members[subprocedure_type.member_count].offset = __builtin_offsetof(struct subprocedure, target); subprocedure_type.members[subprocedure_type.member_count].type = (AType)&object_type; subprocedure_type.members[subprocedure_type.member_count].member_type = A_TYPE_PROP; subprocedure_type.member_count++; subprocedure_type.members[subprocedure_type.member_count].name = "ctx"; subprocedure_type.members[subprocedure_type.member_count].offset = __builtin_offsetof(struct subprocedure, ctx); subprocedure_type.members[subprocedure_type.member_count].type = (AType)&object_type; subprocedure_type.members[subprocedure_type.member_count].member_type = A_TYPE_PROP; subprocedure_type.member_count++; subprocedure_type.members[subprocedure_type.member_count].required = (bool)1; subprocedure_type.members[subprocedure_type.member_count].name = "addr"; subprocedure_type.members[subprocedure_type.member_count].offset = __builtin_offsetof(struct subprocedure, addr); subprocedure_type.members[subprocedure_type.member_count].type = (AType)&handle_type; subprocedure_type.members[subprocedure_type.member_count].member_type = A_TYPE_PROP; subprocedure_type.member_count++; subprocedure_type . invoke = & subprocedure_invoke; subprocedure_type.members[subprocedure_type.member_count].name = "invoke"; subprocedure_type.members[subprocedure_type.member_count].args = (meta_t) { 3, &subprocedure_type, &subprocedure_type, &A_type }; subprocedure_type.members[subprocedure_type.member_count].type = (AType)&A_type; subprocedure_type.members[subprocedure_type.member_count].offset = __builtin_offsetof(subprocedure_f, invoke); subprocedure_type.members[subprocedure_type.member_count].member_type = A_TYPE_IMETHOD; subprocedure_type.member_count++; A_push_type(&subprocedure_type); return (bool)1; } }

#pragma pack(push, 1)
# 1966 "/home/kalen/src/A/src/A.c"
 A AF_header; AF_f AF_type;
# 1966 "/home/kalen/src/A/src/A.c"
#pragma pack(pop)
# 1966 "/home/kalen/src/A/src/A.c"
 static __attribute__((constructor)) bool global_AF() { AF_f* type_ref = &AF_type; A_f* base_ref = &A_type; if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { A_lazy_init((global_init_fn)&global_AF); return (bool)0; } else { memset(type_ref, 0, sizeof(AF_f)); memcpy(type_ref, base_ref, sizeof(A_f)); static type_member_t members[16 + sizeof(AF_type) / sizeof(void*)]; AF_type.parent_type = &A_type; AF_type.name = "AF"; AF_type.members = members; AF_type.size = sizeof(struct AF); AF_type.traits = 0; AF_type.arb = primitive_ffi_arb(((AType)&cstr_type)); AF_type.members[AF_type.member_count].name = "pool"; AF_type.members[AF_type.member_count].offset = __builtin_offsetof(struct AF, pool); AF_type.members[AF_type.member_count].type = (AType)&array_type; AF_type.members[AF_type.member_count].member_type = A_TYPE_PROP; AF_type.member_count++; AF_type.members[AF_type.member_count].name = "start_size"; AF_type.members[AF_type.member_count].offset = __builtin_offsetof(struct AF, start_size); AF_type.members[AF_type.member_count].type = (AType)&sz_type; AF_type.members[AF_type.member_count].member_type = A_TYPE_PROP; AF_type.member_count++; AF_type . fetch = & AF_fetch; AF_type.members[AF_type.member_count].name = "fetch"; AF_type.members[AF_type.member_count].args = (meta_t) { 1, &num_type }; AF_type.members[AF_type.member_count].type = (AType)&AF_type; AF_type.members[AF_type.member_count].offset = __builtin_offsetof(AF_f, fetch); AF_type.members[AF_type.member_count].member_type = A_TYPE_SMETHOD; AF_type.member_count++; AF_type . create = & AF_create; AF_type.members[AF_type.member_count].name = "create"; AF_type.members[AF_type.member_count].args = (meta_t) { 1, &sz_type }; AF_type.members[AF_type.member_count].type = (AType)&AF_type; AF_type.members[AF_type.member_count].offset = __builtin_offsetof(AF_f, create); AF_type.members[AF_type.member_count].member_type = A_TYPE_SMETHOD; AF_type.member_count++; AF_type . init = & AF_init; AF_type . destructor = & AF_destructor; A_push_type(&AF_type); return (bool)1; } }

A ATypes_header; ATypes_f ATypes_type; static __attribute__((constructor)) bool global_ATypes() { ATypes_f* type_ref = &ATypes_type; array_f* src_ref = &array_type; if (src_ref->size == 0) { A_lazy_init((global_init_fn)&global_ATypes); return (bool)0; } else { memset(type_ref, 0, sizeof(ATypes_f)); memcpy(&ATypes_type, &array_type, sizeof(array_f)); ATypes_type.name = "ATypes"; ATypes_type.src = &array_type; ATypes_type.meta = (meta_t) { 1, &AType_type }; ATypes_type.traits = A_TRAIT_ALIAS; return (bool)1; } }
