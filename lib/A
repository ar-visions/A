#ifndef _A_
#define _A_

/// start-trim
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <libgen.h>
#include <unistd.h>
#include <signal.h>

/// end-trim

/// A-type runtime
typedef void                none;
typedef signed char         i8;
typedef short               i16;
typedef int                 i32;
typedef long long           i64;
typedef unsigned char       u8;
typedef unsigned short      u16;
typedef unsigned int        u32;
typedef unsigned long long  u64;
typedef long long           num;
typedef long long           sz;      /// a signed 64 bit size lets us act like python, so this is a type for the purpose of indexing and all valid sizes
#ifndef __cplusplus
typedef u8                  bool;
#endif
typedef float               f32;
typedef double              f64;
typedef long double         f128;
typedef double              real;    /// real enough
typedef void*               handle;
typedef char*               cstr;
typedef const char*         symbol;
typedef const char*         cereal;
//typedef struct A_f*       AType;
typedef struct _object*     object;
typedef struct _A**         ARef;
typedef float*              floats;
typedef struct _A*          A;
typedef struct type_member_t* Member;

#define forward(t) typedef struct _##t* t;

#ifdef __cplusplus
extern "C" {
#endif

/*
void*   calloc(size_t num, size_t size);
void    free();
void    exit(int);
//int     abs(int);
cstr    realpath(symbol, symbol);
FILE   *popen(symbol command, symbol type);
int     pclose(FILE*);
i64     strtoll(symbol str, cstr* endptr, int base);
f64     strtod (symbol str, cstr* endptr);
int     system(symbol command);
int     setenv(symbol key, symbol value, int);
cstr    getenv(symbol key);
i32       rand();
void     srand(u32 seed);
*/

typedef struct _A_f* AType;

struct type_member_t;
struct _array;
struct _A_f;

#define a(...) array_of(__VA_ARGS__)


/// our A-type classes have many types of methods
/// constructor, i[nstance]-method, s[tatic]-method, operator (these are enumerable!), and index.  we index by 1 argument only in C but we may allow for more in silver
enum A_MEMBER {
    A_MEMBER_NONE      = 0,
    A_MEMBER_CONSTRUCT = 1,
    A_MEMBER_PROP      = 2,
    A_MEMBER_INLAY     = 4,
    A_MEMBER_PRIV      = 8,
    A_MEMBER_INTERN    = 16,
    A_MEMBER_READ_ONLY = 32,
    A_MEMBER_IMETHOD   = 64,
    A_MEMBER_SMETHOD   = 128,
    A_MEMBER_OPERATOR  = 256,
    A_MEMBER_CAST      = 512,
    A_MEMBER_INDEX     = 1024,
    A_MEMBER_ENUMV     = 2048,
    A_MEMBER_OVERRIDE  = 4096,
    A_MEMBER_VPROP     = 8192,
    A_MEMBER_ATTR      = 16384,
};

typedef enum A_MEMBER AMember;

enum A_TRAIT {
    A_TRAIT_PRIMITIVE = 1,
    A_TRAIT_INTEGRAL  = 2,
    A_TRAIT_REALISTIC = 4,
    A_TRAIT_SIGNED    = 8,
    A_TRAIT_UNSIGNED  = 16,
    A_TRAIT_ENUM      = 32,
    A_TRAIT_ALIAS     = 64,
    A_TRAIT_ABSTRACT  = 128,
    A_TRAIT_VECTOR    = 256,
    A_TRAIT_STRUCT    = 512,
    A_TRAIT_PTR_SIZE  = 1024
};

_Pragma("pack(push, 1)")

typedef struct meta_t {
    long long       count;
    AType           meta_0, meta_1, meta_2, meta_3, 
                    meta_4, meta_5, meta_6, meta_7, meta_8, meta_9;
} meta_t;

forward(shape)

typedef struct ftable_t {
    struct ftable_t* parent_type;
    char*           name;
    char*           module;
    int             size;
    int             msize;
    shape           vmember_shape;
    int             vmember_count;
    AType           vmember_type;
    int             member_count;
    struct type_member_t* members;
    int             traits;
    AType           src;
    void*           arb;
    meta_t          meta;
} ftable_t;

typedef struct type_member_t {
    char*           name;
    AType           type;
    int             offset;
    int             count;
    int             member_type;
    int             operator_type;
    int             required;
    meta_t          args;
    void*           ptr;
    void*           method;
    i64             id;
} type_member_t;

_Pragma("pack(pop)")

typedef bool(*global_init_fn)();

#define true                (bool)1
#define false               (bool)0
#define stringify(x)        #x
#ifdef __cpp
#define null                nullptr
#else
#define null                ((void*)0)
#endif
#define FNV_PRIME           0x100000001b3
#define OFFSET_BASIS        0xcbf29ce484222325

#define   enum_value_DECL(E, N)             E##_##N,
#define   enum_value_COUNT(E, N)            1,
#define   enum_value_METHOD(E, N)
#define   enum_value_IMPL(E, N) \
    E##_type.members[E## _type.member_count].name     = #N; \
    E##_type.members[E## _type.member_count].offset   = E##_##N;\
    E##_type.members[E## _type.member_count].type     = &i32_type; \
    E##_type.members[E## _type.member_count].member_type = A_MEMBER_ENUMV; \
    E##_type.member_count++;
#define   enum_value(X,Y, N)                enum_value_##Y(X, N)


#define   enum_method_DECL(E, R, N, ...)
#define   enum_method_COUNT(E, R, N, ...)
#define   enum_method_IMPL(E, R, N, ...) \
    E##_type . N = & E## _ ## N; \
    E##_type.members[E##_type.member_count].name    = #N; \
    E##_type.members[E##_type.member_count].args    = (meta_t) { emit_types(__VA_ARGS__) }; \
    E##_type.members[E##_type.member_count].type    = (AType)&R##_type; \
    E##_type.members[E##_type.member_count].offset  = offsetof(E##_f, N); \
    E##_type.members[E##_type.member_count].ptr     = (void*)& E##_##N; \
    E##_type.members[E##_type.member_count].member_type = A_MEMBER_SMETHOD; \
    E##_type.member_count++; 
#define   enum_method_METHOD(E, R, N, ...)    R (*N)(E value __VA_OPT__(,) __VA_ARGS__);
#define   enum_method(E,Y,R,N,...)            enum_method_##Y(E,R,N __VA_OPT__(,) __VA_ARGS__)



#define   enum_value_v_DECL(E, N, VAL)             E##_##N = VAL,
#define   enum_value_v_COUNT(E, N, VAL)            1,
#define   enum_value_v_METHOD(E, N, VAL)
#define   enum_value_v_IMPL(E, N, VAL) \
    E##_type.members[E## _type.member_count].name     = #N; \
    E##_type.members[E## _type.member_count].offset   = E##_##N;\
    E##_type.members[E## _type.member_count].type     = &i32_type; \
    E##_type.members[E## _type.member_count].member_type = A_MEMBER_ENUMV; \
    E##_type.member_count++;

#define   enum_value_vargs_DECL(E, N, VAL,...)             E##_##N = VAL,
#define   enum_value_vargs_COUNT(E, N, VAL,...)            1,
#define   enum_value_vargs_METHOD(E, N, VAL,...)
#define   enum_value_vargs_IMPL(E, N, VAL,...) \
    E##_type.members[E## _type.member_count].name     = #N; \
    E##_type.members[E## _type.member_count].offset   = E##_##N;\
    E##_type.members[E## _type.member_count].type     = &i32_type; \
    E##_type.members[E## _type.member_count].member_type = A_MEMBER_ENUMV; \
    E##_type.members[E## _type.member_count].args     = (meta_t) { emit_types(__VA_ARGS__) }; \
    E##_type.member_count++;

//#define   enum_value_v(X,Y, N,VAL)                enum_value_v_##Y(X, N,VAL)

#define ARG_COUNT_HELPER(_1, _2, N, ...) N
#define ARG_COUNT_NO_ZERO(...) \
    ARG_COUNT_HELPER(__VA_ARGS__, 2, 1, 0)

#define CONCAT_HELPER(x, y) x##y
#define CONCAT(x, y) CONCAT_HELPER(x, y)

#define   enum_value_v_1(X,Y, N,VAL)             enum_value_v_##Y(X, N,VAL)
#define   enum_value_v_2(X,Y, N,VAL,T1)          enum_value_vargs_##Y(X, N,VAL,T1)
#define   enum_value_v_3(X,Y, N,VAL,T1,T2)       enum_value_vargs_##Y(X, N,VAL,T1,T2)
#define   enum_value_v_4(X,Y, N,VAL,T1,T2,T3)    enum_value_vargs_##Y(X, N,VAL,T1,T2,T3)
#define   enum_value_v_5(X,Y, N,VAL,T1,T2,T3,T4) enum_value_vargs_##Y(X, N,VAL,T1,T2,T3,T4)
#define   enum_value_v(X,Y, N,VAL, ...) \
    CONCAT(enum_value_v_, ARG_COUNT_NO_ZERO(__VA_ARGS__))(X,Y, N,VAL __VA_OPT__(,) __VA_ARGS__)


#define sqr(x) ({ \
    __typeof__(x) a = x; \
    a*a \
})\

// runtime type-check api
#ifndef NDEBUG
    #define TC(MEMBER, VALUE) VALUE
#else
    #define TC(MEMBER, VALUE) VALUE
#endif

#define NULL_TOKEN
#define ARG_COUNT_NZ_IMPL(NULL_TOKEN, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, N, ...) N

#define ARG_COUNT_NZ(...) _ARG_COUNT_IMPL(__VA_ARGS__, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define _ARG_COUNT_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, N, ...) N
#define _ARG_COUNT_I(...) _ARG_COUNT_IMPL(__VA_ARGS__, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define _ARG_COUNT(...)   _ARG_COUNT_I("A-type", ## __VA_ARGS__)
#define _COMBINE_(A, B)   A##B
#define _COMBINE(A, B)    _COMBINE_(A, B)
#define _N_ARGS_0( TYPE)
#define _N_ARGS_1( TYPE, a) _Generic((a), TYPE##_schema(TYPE, GENERICS, object) const void *: (void)0)(instance, a)
#define _N_ARGS_2( TYPE, a,b) instance->a = TC(a,b);
#define _N_ARGS_4( TYPE, a,b, c,d) \
        _N_ARGS_2 (TYPE, a,b) instance->c = TC(c,d);
#define _N_ARGS_6( TYPE, a,b, c,d, e,f) \
        _N_ARGS_4 (TYPE, a,b, c,d) instance->e = TC(e,f);
#define _N_ARGS_8( TYPE, a,b, c,d, e,f, g,h) \
        _N_ARGS_6 (TYPE, a,b, c,d, e,f) instance->g = TC(g,h);
#define _N_ARGS_10(TYPE, a,b, c,d, e,f, g,h, i,j) \
        _N_ARGS_8 (TYPE, a,b, c,d, e,f, g,h) instance->i = TC(i,j);
#define _N_ARGS_12(TYPE, a,b, c,d, e,f, g,h, i,j, l,m) \
        _N_ARGS_10(TYPE, a,b, c,d, e,f, g,h, i,j) instance->l = TC(l,m);
#define _N_ARGS_14(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o) \
        _N_ARGS_12(TYPE, a,b, c,d, e,f, g,h, i,j, l,m) instance->n = TC(n,o);
#define _N_ARGS_16(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q) \
        _N_ARGS_14(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o) instance->p = TC(p,q);
#define _N_ARGS_18(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s) \
        _N_ARGS_16(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q) instance->r = TC(r,s);
#define _N_ARGS_20(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u) \
        _N_ARGS_18(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s) instance->t = TC(t,u);
#define _N_ARGS_22(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u, v,w) \
        _N_ARGS_20(TYPE, a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u) instance->v = TC(v,w);
#define _N_ARGS_HELPER2(TYPE, N, ...)  _COMBINE(_N_ARGS_, N)(TYPE, ## __VA_ARGS__)
#define _N_ARGS(TYPE,...)    _N_ARGS_HELPER2(TYPE, _ARG_COUNT(__VA_ARGS__), ## __VA_ARGS__)


//#define _N_STRUCT_ARGS_0( TYPE) _N_ARGS_2( TYPE )
#define _N_STRUCT_ARGS_1( TYPE, a) \
    ({ TYPE instance = _Generic((a), TYPE##_schema(TYPE, GENERICS, object) const void *: (void)0)(a); instance; }) 

#define _N_STRUCT_ARGS_2( TYPE, ...) ({ TYPE instance = (TYPE) { __VA_ARGS__ }; instance; })
#define _N_STRUCT_ARGS_3( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_4( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_5( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_6( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_7( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_8( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_9( TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )
#define _N_STRUCT_ARGS_10(TYPE, ...) _N_STRUCT_ARGS_2( TYPE, __VA_ARGS__ )

#define _N_STRUCT_ARGS_HELPER2(TYPE, N, ...)  _COMBINE(_N_STRUCT_ARGS_, N)(TYPE, ## __VA_ARGS__)
#define _N_STRUCT_ARGS(TYPE,...)    _N_STRUCT_ARGS_HELPER2(TYPE, _ARG_COUNT(__VA_ARGS__), ## __VA_ARGS__)

#define structure_of(TYPE, ...) _N_STRUCT_ARGS(TYPE, __VA_ARGS__);
  






#define new(TYPE, ...) \
    ({ \
        TYPE instance = (TYPE)A_alloc(typeid(TYPE), 1, true); \
        _N_ARGS(TYPE, ## __VA_ARGS__); \
        A_initialize((object)instance); \
        instance; \
    })
#define new2(TYPE, ...) \
    ({ \
        TYPE instance = (TYPE)A_alloc(typeid(TYPE), 1, true); \
        TYPE##_N_ARGS(TYPE, ## __VA_ARGS__); \
        A_initialize((object)instance); \
        instance; \
    })

#define _ARG_COUNT_IMPL2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, N, ...) N
#define _ARG_COUNT2(...)        _ARG_COUNT_IMPL2(__VA_ARGS__, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#define _COMBINE_2(A, B)        A##B
#define _COMBINE2(A, B)         _COMBINE_2(A, B)
#define _F(T, a,b)              (((1 << (i64)T##_##a) * b)) 
#define _F_ARGS_0(T)
#define _F_ARGS_1(T)                  
#define _F_ARGS_2(T, a,b)                    _F(T, a, b)
#define _F_ARGS_4(T, a,b, c,d)               _F_ARGS_2 (a,b) | _F(T, c,d)
#define _F_ARGS_6(T, a,b, c,d, e,f)          _F_ARGS_4 (a,b, c, d) | _F(T, e,f)
#define _F_ARGS_8(T, a,b, c,d, e,f, g,h)     _F_ARGS_6 (a,b, c, d, e, f) | _F(T, g,h)
#define _F_ARGS(T,...)    _F_ARGS_HELPER2(T, _ARG_COUNT2(__VA_ARGS__), __VA_ARGS__)
#define _F_ARGS_HELPER2(T, N, ...)  _COMBINE2(_F_ARGS_, N)(T, __VA_ARGS__)
#define flags(T, ...) _F_ARGS(T, __VA_ARGS__);

/// with construct we give it a dynamic type, symbols and A-values
#define construct(type, ...) \
    ({ \
        T instance = (T)A_alloc(type, 1, true); \
        _N_ARGS(instance, ## __VA_ARGS__); \
        A_initialize((A)instance); \
        instance; \
    })

#define new0(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, true); \
        _N_ARGS(instance, ## __VA_ARGS__); \
        A_initialize((A)instance); \
        instance; \
    })

#define create(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, false); \
        _N_ARGS(instance, ## __VA_ARGS__); \
        A_initialize((A)instance); \
        instance; \
    })

#define allocate(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, false); \
        _N_ARGS(instance, ## __VA_ARGS__); \
        instance; \
    })

#define valloc(T, N)                ((A)A_alloc(typeid(T), N, false))
#define ftable(TYPE, INSTANCE)      ((TYPE##_f*)((A)INSTANCE)[-1].type)
#define isa(INSTANCE)               (INSTANCE ? (struct _A_f*)((struct _A*)INSTANCE - 1)->type : (struct _A_f*)0)
// see: javascript; returns null if its not an instance-of; faults if you give it a null
#define instanceof(left, type)      A_instanceof(left, typeid(type))
#define ftableI(I)                  ((__typeof__((I)->f)) ((A)(I))[-1].type)
#define fcall(I,M,...)              ({ __typeof__(I) _i_ = I; ftableI(_i_)->M(_i_, ## __VA_ARGS__); })
#define mcall(I,M,...)              ({ __typeof__(I) _i_ = I; (_i_) ? ftableI(_i_)->M(_i_, ## __VA_ARGS__) : 0; })
#define M(I,N,...)                  fcall(I,N, ## __VA_ARGS__)
#define cstring(I)                  cast(cstr, I)
#define val(T,V)                    A_primitive(typeid(T), (&(T){V}))
#define idx_1(I,T1,V1)              M(I, index ##_## T1, V1)
#define idx_2(I,T1,T2,V1,V2)        M(I, index ##_## T1 ##_## T2, V1, V2)
#define idx(I,V1)                   M(I, index ##_## num, V1)
#define cast(T,I)                   fcall(I, cast_##T)
#define meta_t(I,IDX)               isa(I) -> meta.meta_##IDX
#define ctr(T,WITH,...)             A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, true), ## __VA_ARGS__))
#define ctr1(T,WITH,...)            A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, true), ## __VA_ARGS__))
#define alloc_ctr(T,WITH,...)       A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, false), ## __VA_ARGS__))
#define str(CSTR)                   string_type.with_symbol((string)A_alloc((AType)&string_type, 1, true), (symbol)(CSTR))
#define addr_validateI(I)           ({ \
    __typeof__(I) *addr = &I; \
    I \
})

/// arg expansion for type emission (give address of its statically defined)
#define emit_types(...)             EXPAND_ARGS(__VA_ARGS__)
#define combine_tokens_(A, B)       A##B
#define combine_tokens(A, B)        combine_tokens_(A, B)
#define EXPAND_ARGS(...)            EXPAND_ARGS_HELPER(COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
#define EXPAND_ARGS_HELPER(N, ...)  combine_tokens(EXPAND_ARGS_, N)(__VA_ARGS__)
#define EXPAND_ARGS_0()                                0
#define EXPAND_ARGS_1(a)                               1, (AType)&a##_type
#define EXPAND_ARGS_2(a, b)                            2, (AType)&a##_type, (AType)&b##_type
#define EXPAND_ARGS_3(a, b, c)                         3, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type
#define EXPAND_ARGS_4(a, b, c, d)                      4, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type
#define EXPAND_ARGS_5(a, b, c, d, e)                   5, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type
#define EXPAND_ARGS_6(a, b, c, d, e, f)                6, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type, (AType)&f##_type
#define EXPAND_ARGS_7(a, b, c, d, e, f, g)             7, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type, (AType)&f##_type, (AType)&g##_type
#define EXPAND_ARGS_8(a, b, c, d, e, f, g, h)          8, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type, (AType)&f##_type, (AType)&g##_type, (AType)&h##_type
#define EXPAND_ARGS_9(a, b, c, d, e, f, g, h, ii)      9, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type, (AType)&f##_type, (AType)&g##_type, (AType)&h##_type, (AType)&ii##_type
#define EXPAND_ARGS_10(a, b, c, d, e, f, g, h, ii, j) 10, (AType)&a##_type, (AType)&b##_type, (AType)&c##_type, (AType)&d##_type, (AType)&e##_type, (AType)&f##_type, (AType)&g##_type, (AType)&h##_type, (AType)&ii##_type, (AType)&j##_type
#define COUNT_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define COUNT_ARGS(...)             COUNT_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

//#define EXPAND_ARGS2_0()                       
#define EXPAND_ARGS2_1(a)                        a
#define EXPAND_ARGS2_2(a, b)                     a##_##b
#define EXPAND_ARGS2_3(a, b, c)                  a##_##b##_##c
#define EXPAND_ARGS2_4(a, b, c, d)               a##_##b##_##c##_##d
#define EXPAND_ARGS2_5(a, b, c, d, e)            a##_##b##_##c##_##d##_e
#define EXPAND_ARGS2_6(a, b, c, d, e, f)         a##_##b##_##c##_##d##_e##_##f
#define EXPAND_ARGS2_7(a, b, c, d, e, f, g)      a##_##b##_##c##_##d##_e##_##f##_##g
#define EXPAND_ARGS2_8(a, b, c, d, e, f, g, h)   a##_##b##_##c##_##d##_e##_##f##_##g##_##h
#define emit_idx_symbol(...)             EXPAND_ARGS2(__VA_ARGS__)
#define EXPAND_ARGS2(...)            EXPAND_ARGS_HELPER2(COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
#define EXPAND_ARGS_HELPER2(N, ...)  combine_tokens(EXPAND_ARGS2_, N)(__VA_ARGS__)


#define   i_ctr_public_INST(X, ARG)
#define   i_ctr_public_INST_EXTERN(X, ARG)
#define   i_ctr_public_DECL(X, ARG)
#define   i_ctr_public_GENERICS(X, ARG) ARG: X##_type.with_##ARG,

#define   i_ctr_public_INIT(X, ARG) \
    X##_type.with_##ARG = & X##_with_##ARG; \
    X##_type.members[X##_type.member_count].name        = stringify(with_##ARG); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { emit_types(ARG) }; \
    X##_type.members[X##_type.member_count].type        = (AType)&ARG##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, with_##ARG); \
    X##_type.members[X##_type.member_count].ptr         = (void*)& X##_with_##ARG; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CONSTRUCT; \
    X##_type.member_count++;  
#define   i_ctr_public_PROTO(X, ARG)
#define   i_ctr_public_METHOD(X, ARG)      X (*with_##ARG)(X, ARG);
#define   i_ctr_intern_INST(X, ARG)
#define   i_ctr_intern_INST_EXTERN(X, ARG)
#define   i_ctr_intern_INIT(X, ARG) 
#define   i_ctr_intern_PROTO(X, ARG)
#define   i_ctr_intern_METHOD(X, ARG)
#define   i_ctr(X, Y, T, ARG)              i_ctr_##T##_##Y(X, ARG)



#define   i_prop_public_INST(X, R, N)         R N;
#define   i_prop_public_INST_EXTERN(X, R, N)  i_prop_public_INST(X, R, N)
#define   i_prop_public_DECL(X, R, N)
#define   i_prop_public_GENERICS(X, R, N)
#define   i_prop_public_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;
#define   i_prop_public_PROTO(X, R, N)  
#define   i_prop_public_METHOD(X, R, N)

#define   i_prop_required_INST(X, R, N)         i_prop_public_INST(X, R, N)
#define   i_prop_required_INST_EXTERN(X, R, N)  i_prop_public_INST(X, R, N)
#define   i_prop_required_DECL(X, R, N)
#define   i_prop_required_GENERICS(X, R, N)
#define   i_prop_required_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].required = true; \
    i_prop_public_INIT(X, R, N)
#define   i_prop_required_PROTO(X, R, N)  
#define   i_prop_required_METHOD(X, R, N)

#define   i_prop_intern_INST(X, R, N)           R N;
#define   i_prop_intern_INST_EXTERN(X, R, N)    R _##N;
#define   i_prop_intern_DECL(X, R, N)
#define   i_prop_intern_GENERICS(X, R, N)
#define   i_prop_intern_INIT(X, R, N)
#define   i_prop_intern_PROTO(X, R, N)  
#define   i_prop_intern_METHOD(X, R, N)







#define   i_prop_public_INST_field(X, R, N, M2)         R N;
#define   i_prop_public_INST_EXTERN_field(X, R, N, M2)  i_prop_public_INST_field(X, R, N, M2)
#define   i_prop_public_DECL_field(X, R, N, M2)
#define   i_prop_public_GENERICS_field(X, R, N, M2)
#define   i_prop_public_INIT_field(X, R, N, M2) \
    X##_type.members[X##_type.member_count].name     = #M2; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;
#define   i_prop_public_PROTO_field(X, R, N, M2)  
#define   i_prop_public_METHOD_field(X, R, N, M2)

#define   i_prop_required_INST_field(X, R, N, M2)         i_prop_public_INST_field(X, R, N, M2)
#define   i_prop_required_INST_EXTERN_field(X, R, N, M2)  i_prop_public_INST_field(X, R, N, M2)
#define   i_prop_required_DECL_field(X, R, N, M2)
#define   i_prop_required_GENERICS_field(X, R, N, M2)
#define   i_prop_required_INIT_field(X, R, N, M2) \
    X##_type.members[X##_type.member_count].required = true; \
    i_prop_public_INIT_field(X, R, N, M2)
#define   i_prop_required_PROTO_field(X, R, N, M2)  
#define   i_prop_required_METHOD_field(X, R, N, M2)

#define   i_prop_intern_INST_field(X, R, N, M2)           R N;
#define   i_prop_intern_INST_EXTERN_field(X, R, N, M2)
#define   i_prop_intern_DECL_field(X, R, N, M2)
#define   i_prop_intern_GENERICS_field(X, R, N, M2)
#define   i_prop_intern_INIT_field(X, R, N, M2)          fault("field is not exposed when intern");
#define   i_prop_intern_PROTO_field(X, R, N, M2)  
#define   i_prop_intern_METHOD_field(X, R, N, M2)  




#define   i_prop_public_INST_of(X, R, N, M2) R N;
#define   i_prop_public_INST_EXTERN_of(X, R, N, M2)
#define   i_prop_public_DECL_of(X, R, N, M2)
#define   i_prop_public_GENERICS_of(X, R, N, M2)
#define   i_prop_public_INIT_of(X, R, N, M2) \
    X##_type.members[X##_type.member_count].name     = #M2; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].args     = (meta_t) { 1, (AType)&M2##_type };; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;

#define   i_prop_public_PROTO_of(X, R, N, M2)  
#define   i_prop_public_METHOD_of(X, R, N, M2)

#define   i_prop_required_INST_of(X, R, N, M2) R N;
#define   i_prop_required_INST_EXTERN_of(X, R, N, M2)
#define   i_prop_required_DECL_of(X, R, N, M2)
#define   i_prop_required_GENERICS_of(X, R, N, M2)
#define   i_prop_required_INIT_of(X, R, N, M2) \
    i_prop_public_INIT_of(X, R, N, M2)
#define   i_prop_required_PROTO_of(X, R, N, M2)  
#define   i_prop_required_METHOD_of(X, R, N, M2)

#define   i_prop_intern_INST_of(X, R, N, M2)           R N;
#define   i_prop_intern_INST_EXTERN_of(X, R, N, M2)    M2 _##N;
#define   i_prop_intern_DECL_of(X, R, N, M2)
#define   i_prop_intern_GENERICS_of(X, R, N, M2)
#define   i_prop_intern_INIT_of(X, R, N, M2)
#define   i_prop_intern_PROTO_of(X, R, N, M2)  
#define   i_prop_intern_METHOD_of(X, R, N, M2)  



#define   i_prop_public_INST_as(X, R, N, M2)
#define   i_prop_public_INST_EXTERN_as(X, R, N, M2)
#define   i_prop_public_DECL_as(X, R, N, M2)
#define   i_prop_public_GENERICS_as(X, R, N, M2)
#define   i_prop_public_INIT_as(X, R, N, M2) \
    verify(false, "'as' keyword is used for internals")
#define   i_prop_public_PROTO_as(X, R, N, M2)  
#define   i_prop_public_METHOD_as(X, R, N, M2)

#define   i_prop_required_INST_as(X, R, N, M2)
#define   i_prop_required_INST_EXTERN_as(X, R, N, M2)
#define   i_prop_required_DECL_as(X, R, N, M2)
#define   i_prop_required_GENERICS_as(X, R, N, M2)
#define   i_prop_required_INIT_as(X, R, N, M2) \
    verify(false, "'as' keyword used with internals and cannot be required");
#define   i_prop_required_PROTO_as(X, R, N, M2)  
#define   i_prop_required_METHOD_as(X, R, N, M2)

#define   i_prop_intern_INST_as(X, R, N, M2)           R N;
#define   i_prop_intern_INST_EXTERN_as(X, R, N, M2)    M2 _##N;
#define   i_prop_intern_DECL_as(X, R, N, M2)
#define   i_prop_intern_GENERICS_as(X, R, N, M2)
#define   i_prop_intern_INIT_as(X, R, N, M2)
#define   i_prop_intern_PROTO_as(X, R, N, M2)  
#define   i_prop_intern_METHOD_as(X, R, N, M2)  








#define i_prop_1(X, Y, T, R, N, ...) \
    i_prop_##T##_##Y(X, R, N)

#define i_prop_2(X, Y, T, R, N, MODE2, M2) \
    i_prop_##T##_##Y##_##MODE2(X, R, N, M2)

#define ARG_COUNT_HELPER(_1, _2, N, ...) N
#define ARG_COUNT_NO_ZERO(...) \
    ARG_COUNT_HELPER(__VA_ARGS__, 2, 1, 0)

#define CONCAT_HELPER(x, y) x##y
#define CONCAT(x, y) CONCAT_HELPER(x, y)

#define i_prop(X, Y, T, R, N, ...) \
    CONCAT(i_prop_, ARG_COUNT_NO_ZERO(__VA_ARGS__))(X, Y, T, R, N __VA_OPT__(,) __VA_ARGS__)



#define   i_vprop_public_INST(X, R, N)         R* N;
#define   i_vprop_public_INST_EXTERN(X, R, N)  i_vprop_public_INST(X, R, N)   
#define   i_vprop_public_DECL(X, R, N)
#define   i_vprop_public_GENERICS(X, R, N)
#define   i_vprop_public_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&ARef_type; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_VPROP; \
    X##_type.member_count++;
#define   i_vprop_public_PROTO(X, R, N)  
#define   i_vprop_public_METHOD(X, R, N)

#define   i_vprop_required_INST(X, R, N)         i_vprop_public_INST(X, R, N)
#define   i_vprop_required_INST_EXTERN(X, R, N)  i_vprop_public_INST(X, R, N)
#define   i_vprop_required_DECL(X, R, N)
#define   i_vprop_required_GENERICS(X, R, N)
#define   i_vprop_required_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].required = true; \
    i_vprop_public_INIT(X, R, N)
#define   i_vprop_required_PROTO(X, R, N)  
#define   i_vprop_required_METHOD(X, R, N)

#define   i_vprop_intern_INST(X, R, N)           R* N;
#define   i_vprop_intern_INST_EXTERN(X, R, N)        
#define   i_vprop_intern_DECL(X, R, N)
#define   i_vprop_intern_GENERICS(X, R, N)
#define   i_vprop_intern_INIT(X, R, N)
#define   i_vprop_intern_PROTO(X, R, N)  
#define   i_vprop_intern_METHOD(X, R, N)  
#define   i_vprop(X, Y, T, R, N) i_vprop_##T##_##Y(X, R, N)




#define i_attr_INST(X, ENUM, VALUE, ...)
#define i_attr_INST_EXTERN(X, ENUM, VALUE, ...)
#define i_attr_DECL(X, ENUM, VALUE, ...)
#define i_attr_GENERICS(X, ENUM, VALUE, ...)
#define i_attr_INIT(X, ENUM, VALUE, ...) \
    X##_type.members[X##_type.member_count].name = #VALUE; \
    X##_type.members[X##_type.member_count].id   = ENUM##_##VALUE; \
    X##_type.members[X##_type.member_count].type = (AType)&ENUM##_type; \
    X##_type.members[X##_type.member_count].args = (meta_t) { emit_types(__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_ATTR; \
    X##_type.member_count++;
#define i_attr_PROTO(X, ENUM, VALUE, ...)  
#define i_attr_METHOD(X, ENUM, VALUE, ...)  

/*
    i_attr   (X,Y, Surface,    color,         rgba8) \
    i_attr   (X,Y, Surface,    normal,        rgba8) \
    i_attr   (X,Y, Surface,    emission,      rgbaf) \
    i_attr   (X,Y, Surface,    rough,         u8) \
    i_attr   (X,Y, Surface,    metal,         u8) \
    i_attr   (X,Y, Surface,    height,        f32) \
    i_attr   (X,Y, Surface,    ao,            u8) \
    i_attr   (X,Y, Surface,    environment,   rgbaf, IBL) \
*/

#define i_attr(X, Y, ENUM, VALUE, ...) i_attr_##Y(X, ENUM, VALUE, __VA_ARGS__)



#define   i_array_public_INST(X, R, S, N)         R N[S];  
#define   i_array_public_INST_EXTERN(X, R, S, N)  i_array_public_INST(X, R, S, N)
#define   i_array_public_DECL(X, R, S, N)
#define   i_array_public_GENERICS(X, R, S, N)
#define   i_array_public_INIT(X, R, S, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].count    = S; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;
#define   i_array_public_PROTO(X, R, S, N)  
#define   i_array_public_METHOD(X, R, S, N)

#define   i_array_intern_INST(X, R, S, N)         R N[S];
#define   i_array_intern_INST_EXTERN(X, R, S, N)  ARef _##N[S];
#define   i_array_intern_DECL(X, R, S, N)
#define   i_array_intern_GENERICS(X, R, S, N)
#define   i_array_intern_INIT(X, R, S, N)
#define   i_array_intern_PROTO(X, R, S, N)  
#define   i_array_intern_METHOD(X, R, S, N)  
#define   i_array(X, Y, T, R, S, N) i_array_##T##_##Y(X, R, S, N)


#define   i_struct_ctr_INST(X, ARG)
#define   i_struct_ctr_INST_EXTERN(X, ARG)
#define   i_struct_ctr_DECL(X, ARG)
#define   i_struct_ctr_GENERICS(X, ARG) ARG*: X##_type.with_##ARG,
#define   i_struct_ctr_INIT(X, ARG) \
    X##_type.with_##ARG = & X##_with_##ARG; \
    X##_type.members[X##_type.member_count].name        = stringify(with_##ARG); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { }; \
    X##_type.members[X##_type.member_count].type        = (AType)&ARG##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, with_##ARG); \
    X##_type.members[X##_type.member_count].ptr         = (void*)& X##_with_##ARG; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CONSTRUCT; \
    X##_type.member_count++;  
#define   i_struct_ctr_PROTO(X, ARG)
#define   i_struct_ctr_METHOD(X, ARG)      X (*with_##ARG)(ARG*);
#define   i_struct_ctr(X, Y, ARG)          i_struct_ctr_##Y(X, ARG)

#define   i_struct_ctr_obj_INST(X, ARG)
#define   i_struct_ctr_obj_INST_EXTERN(X, ARG)
#define   i_struct_ctr_obj_DECL(X, ARG)
#define   i_struct_ctr_obj_GENERICS(X, ARG) ARG: X##_type.with_##ARG,
#define   i_struct_ctr_obj_INIT(X, ARG) \
    X##_type.with_##ARG = & X##_with_##ARG; \
    X##_type.members[X##_type.member_count].name        = stringify(with_##ARG); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { }; \
    X##_type.members[X##_type.member_count].type        = (AType)&ARG##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, with_##ARG); \
    X##_type.members[X##_type.member_count].ptr         = (void*)& X##_with_##ARG; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CONSTRUCT; \
    X##_type.member_count++;  
#define   i_struct_ctr_obj_PROTO(X, ARG)
#define   i_struct_ctr_obj_METHOD(X, ARG)      X (*with_##ARG)(ARG);
#define   i_struct_ctr_obj(X, Y, ARG)          i_struct_ctr_obj_##Y(X, ARG)


#define   i_struct_array_INST(X, R, S, N)         R N[S];
#define   i_struct_array_INST_EXTERN(X, R, S, N)  i_struct_array_INST(X, R, S, N)
#define   i_struct_array_DECL(X, R, S, N)
#define   i_struct_array_GENERICS(X, R, S, N)
#define   i_struct_array_INIT(X, R, S, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].count    = S; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;
#define   i_struct_array_PROTO(X, R, S, N)  
#define   i_struct_array_METHOD(X, R, S, N)        
#define   i_struct_array(X, Y, R, S, N) i_struct_array_##Y(X, R, S, N)

#define   i_struct_prop_INST(X, R, N)         R N;
#define   i_struct_prop_INST_EXTERN(X, R, N)  i_struct_prop_INST(X, R, N)
#define   i_struct_prop_DECL(X, R, N)
#define   i_struct_prop_GENERICS(X, R, N)
#define   i_struct_prop_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].count    = 1; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_PROP; \
    X##_type.member_count++;
#define   i_struct_prop_PROTO(X, R, N)  
#define   i_struct_prop_METHOD(X, R, N)      
#define   i_struct_prop(X, Y, R, N) i_struct_prop_##Y(X, R, N)

#define   i_struct_cast_INST(X, R)
#define   i_struct_cast_INST_EXTERN(X, R)
#define   i_struct_cast_DECL(X, R)
#define   i_struct_cast_GENERICS(X, R)
#define   i_struct_cast_INIT(X, R) \
    X##_type.cast_##R = & X##_cast_##R; \
    X##_type.members[X##_type.member_count].name    = stringify(cast_##R); \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, cast_##R); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CAST; \
    X##_type.member_count++;  
#define   i_struct_cast_PROTO(X, R)
#define   i_struct_cast_METHOD(X, R)        R (*cast_##R)(X);         
#define   i_struct_cast(X, Y, R)                i_struct_cast_##Y(X, R)

#define   i_struct_method_INST(    X, R, N, ...)
#define   i_struct_method_INST_EXTERN(    X, R, N, ...)
#define   i_struct_method_DECL(    X, R, N, ...)    R X##_##N(X* __VA_OPT__(,) __VA_ARGS__);
#define   i_struct_method_GENERICS(X, R, N, ...)
#define   i_struct_method_INIT(    X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_IMETHOD; \
    X##_type.member_count++;
#define   i_struct_method_PROTO(X, R, N, ...)
#define   i_struct_method_METHOD(X, R, N, ...)      R (*N)(X* __VA_OPT__(,) __VA_ARGS__);
#define   i_struct_method(X, Y, R, N, ...)          i_struct_method_##Y(X, R, N, __VA_ARGS__)



#define   i_struct_static_INST(    X, R, N, ...)
#define   i_struct_static_INST_EXTERN(X, R, N, ...)
#define   i_struct_static_DECL(    X, R, N, ...)    R X##_##N(__VA_ARGS__);
#define   i_struct_static_GENERICS(X, R, N, ...)
#define   i_struct_static_INIT(    X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_IMETHOD; \
    X##_type.member_count++;
#define   i_struct_static_PROTO(X, R, N, ...)
#define   i_struct_static_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);
#define   i_struct_static(X, Y, R, N, ...)          i_struct_static_##Y(X, R, N, __VA_ARGS__)










#define   i_inlay_public_INST(X, R, N)         struct _##R N;
#define   i_inlay_public_INST_EXTERN(X, R, N)  struct _##R N; 
#define   i_inlay_public_DECL(X, R, N)
#define   i_inlay_public_GENERICS(X, R, N)
#define   i_inlay_public_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct _##X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_INLAY; \
    X##_type.member_count++;
#define   i_inlay_public_PROTO(X, R, N)  
#define   i_inlay_public_METHOD(X, R, N)

#define   i_inlay_required_INST(X, R, N)         i_inlay_public_INST(X, R, N)
#define   i_inlay_required_INST_EXTERN(X, R, N)  i_inlay_public_INST_EXTERN(X, R, N)
#define   i_inlay_required_DECL(X, R, N)
#define   i_inlay_required_GENERICS(X, R, N)
#define   i_inlay_required_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].required = true; \
    i_inlay_public_INIT(X, R, N)
#define   i_inlay_required_PROTO(X, R, N)  
#define   i_inlay_required_METHOD(X, R, N)

#define   i_inlay_intern_INST(X, R, N)            struct _##R N;
#define   i_inlay_intern_INST_EXTERN(X, R, N)     i_inlay_intern_INST(X, R, N)
#define   i_inlay_intern_DECL(X, R, N)
#define   i_inlay_intern_GENERICS(X, R, N)
#define   i_inlay_intern_INIT(X, R, N)
#define   i_inlay_intern_PROTO(X, R, N)  
#define   i_inlay_intern_METHOD(X, R, N)  
#define   i_inlay(X, Y, T, R, N) i_inlay_##T##_##Y(X, R, N)






#define   s_method_public_INST(X, R, N, ...)
#define   s_method_public_INST_EXTERN(X, R, N, ...)
#define   s_method_public_DECL(X, R, N, ...)       R X##_##N(__VA_ARGS__);
#define   s_method_public_GENERICS(X, R, N, ...)
#define   s_method_public_INIT(X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_SMETHOD; \
    X##_type.member_count++;   
#define   s_method_public_PROTO(X, R, N, ...)
#define   s_method_public_METHOD(X, R, N, ...)    R (*N)(__VA_ARGS__);

#define   s_method_intern_INST(X, R, N, ...)
#define   s_method_intern_INST_EXTERN(X, R, N, ...)
#define   s_method_intern_DECL(X, R, N, ...)
#define   s_method_intern_GENERICS(X, R, N, ...)
#define   s_method_intern_INIT(X, R, N, ...)      
#define   s_method_intern_PROTO(X, R, N, ...)
#define   s_method_intern_METHOD(X, R, N, ...)    
#define   s_method(X, Y, T, R, N, ...)            s_method_##T##_##Y(X, R, N, ##__VA_ARGS__)

#define   i_method_public_INST(    X, R, N, ...)
#define   i_method_public_INST_EXTERN(  X, R, N, ...)
#define   i_method_public_DECL(    X, R, N, ...)    R X##_##N(__VA_ARGS__);
#define   i_method_public_GENERICS(X, R, N, ...)
#define   i_method_public_INIT(    X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X, ##__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_IMETHOD; \
    X##_type.member_count++;
#define   i_method_public_PROTO(X, R, N, ...)
#define   i_method_public_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_method_intern_INST(    X, R, N, ...)
#define   i_method_intern_INST_EXTERN(  X, R, N, ...)
#define   i_method_intern_DECL(    X, R, N, ...)
#define   i_method_intern_GENERICS(X, R, N, ...)
#define   i_method_intern_INIT(    X, R, N, ...)    
#define   i_method_intern_PROTO(X, R, N, ...)
#define   i_method_intern_METHOD(X, R, N, ...)      


typedef enum {
    CPU_CAP_NONE      = 0,
    CPU_CAP_SSE       = 1 << 0,  // Bit 0
    CPU_CAP_SSE2      = 1 << 1,  // Bit 1
    CPU_CAP_AVX       = 1 << 2,  // Bit 2
    CPU_CAP_AVX2      = 1 << 3,  // Bit 3
    CPU_CAP_AVX512    = 1 << 4,  // Bit 4
    CPU_CAP_NEON32    = 1 << 5,  // Bit 5 (ARM 32-bit NEON)
    CPU_CAP_NEON64    = 1 << 6,  // Bit 6 (ARM 64-bit NEON)
} CPU_Caps;

CPU_Caps detect_cpu_caps();

#define method_member(X, R, N, ...) \
    X##_type . N = & X## _ ## N ## _neon64; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X, ##__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_IMETHOD; \
    X##_type.member_count++; \

#define   i_SIMD_neon64_INST(    X, R, N, ...)
#define   i_SIMD_neon64_INST_EXTERN(  X, R, N, ...)
#define   i_SIMD_neon64_DECL(    X, R, N, ...)
#define   i_SIMD_neon64_GENERICS(X, R, N, ...)
#define   i_SIMD_neon64_INIT(    X, R, N, ...) \
    if (!X##_type . N && (detect_cpu_caps() & CPU_CAP_NEON64)) { \
        X##_type . N = & X## _ ## N ## _neon64; \
        method_member(X, R, N, ## __VA_ARGS__) \
    }
#define   i_SIMD_neon64_PROTO(X, R, N, ...)
#define   i_SIMD_neon64_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_SIMD_neon32_INST(    X, R, N, ...)
#define   i_SIMD_neon32_INST_EXTERN(  X, R, N, ...)
#define   i_SIMD_neon32_DECL(    X, R, N, ...)
#define   i_SIMD_neon32_GENERICS(X, R, N, ...)
#define   i_SIMD_neon32_INIT(    X, R, N, ...) \
    if (!X##_type . N && (detect_cpu_caps() & CPU_CAP_NEON32)) { \
        X##_type . N = & X## _ ## N ## _neon32; \
        method_member(X, R, N, ## __VA_ARGS__) \
    }
#define   i_SIMD_neon32_PROTO(X, R, N, ...)
#define   i_SIMD_neon32_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_SIMD_avx512_INST(    X, R, N, ...)
#define   i_SIMD_avx512_INST_EXTERN(  X, R, N, ...)
#define   i_SIMD_avx512_DECL(    X, R, N, ...)
#define   i_SIMD_avx512_GENERICS(X, R, N, ...)
#define   i_SIMD_avx512_INIT(    X, R, N, ...) \
    if (!X##_type . N && (detect_cpu_caps() & CPU_CAP_AVX512)) { \
        X##_type . N = & X## _ ## N ## _avx512; \
        method_member(X, R, N, ## __VA_ARGS__) \
    }
#define   i_SIMD_avx512_PROTO(X, R, N, ...)
#define   i_SIMD_avx512_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_SIMD_avx2_INST(    X, R, N, ...)
#define   i_SIMD_avx2_INST_EXTERN(  X, R, N, ...)
#define   i_SIMD_avx2_DECL(    X, R, N, ...)
#define   i_SIMD_avx2_GENERICS(X, R, N, ...)
#define   i_SIMD_avx2_INIT(    X, R, N, ...) \
    if (!X##_type . N && (detect_cpu_caps() & CPU_CAP_AVX2)) { \
        X##_type . N = & X## _ ## N ## _avx2; \
        method_member(X, R, N, ## __VA_ARGS__) \
    }
#define   i_SIMD_avx2_PROTO(X, R, N, ...)
#define   i_SIMD_avx2_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_SIMD_avx_INST(    X, R, N, ...)
#define   i_SIMD_avx_INST_EXTERN(  X, R, N, ...)
#define   i_SIMD_avx_DECL(    X, R, N, ...)
#define   i_SIMD_avx_GENERICS(X, R, N, ...)
#define   i_SIMD_avx_INIT(    X, R, N, ...) \
    if (!X##_type . N && (detect_cpu_caps() & CPU_CAP_AVX)) { \
        X##_type . N = & X## _ ## N ## _avx; \
        method_member(X, R, N, ## __VA_ARGS__) \
    }
#define   i_SIMD_avx_PROTO(X, R, N, ...)
#define   i_SIMD_avx_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

/// avoiding conflict with parsing i_method uses
#define   i_method\
(X, Y, T, R, N, ...) i_method_##T##_##Y(X, R, N, X, ## __VA_ARGS__)

// SIMD is public, since we modify the function table
#define   i_SIMD\
(X, Y, R, ARCH, N, ...) i_SIMD_##ARCH##_##Y(X, R, N, X, ## __VA_ARGS__)

#define   i_operator_public_INST(X, R, N, ARG)
#define   i_operator_public_INST_EXTERN(X, R, N, ARG)
#define   i_operator_public_DECL(X, R, N, ARG)
#define   i_operator_public_GENERICS(X, R, N, ARG)
#define   i_operator_public_INIT(X, R, N, ARG) \
    X##_type  . operator_##N = & X## _operator_ ## N; \
    X##_type.members[X##_type.member_count].name    = stringify(operator_##N); \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X, ARG) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, operator_##N); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_OPERATOR; \
    X##_type.members[X##_type.member_count].operator_type = OPType_ ## N; \
    X##_type.member_count++; 
#define   i_operator_public_PROTO(X, R, N, ARG)
#define   i_operator_public_METHOD(X, R, N, ARG)    R (*operator_ ## N)(X, ARG);

#define   i_operator_intern_INST(X, R, N, ARG)
#define   i_operator_intern_INST_EXTERN(X, R, N, ARG)
#define   i_operator_intern_DECL(X, R, N, ARG)
#define   i_operator_intern_GENERICS(X, R, N, ARG)
#define   i_operator_intern_INIT(X, R, N, ARG)      
#define   i_operator_intern_PROTO(X, R, N, ARG)
#define   i_operator_intern_METHOD(X, R, N, ARG)    
#define   i_operator(X, Y, T, R, N, ARG)            i_operator_##T##_##Y(X, R, N, ARG)

#define   i_cast_public_INST(X, R)
#define   i_cast_public_INST_EXTERN(X, R)
#define   i_cast_public_DECL(X, R)
#define   i_cast_public_GENERICS(X, R)
#define   i_cast_public_INIT(X, R) \
    X##_type.cast_##R = & X##_cast_##R; \
    X##_type.members[X##_type.member_count].name    = stringify(cast_##R); \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, cast_##R); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CAST; \
    X##_type.member_count++;  
#define   i_cast_public_PROTO(X, R)
#define   i_cast_public_METHOD(X, R)        R (*cast_##R)(X);

#define   i_cast_intern_INST(X, R)
#define   i_cast_intern_INST_EXTERN(X, R)
#define   i_cast_intern_DECL(X, R)
#define   i_cast_intern_GENERICS(X, R)
#define   i_cast_intern_INIT(X, R)          
#define   i_cast_intern_PROTO(X, R)
#define   i_cast_intern_METHOD(X, R)        
#define   i_cast(X, Y, T, R)                i_cast_##T##_##Y(X, R)

#define   i_index_public_INST(X, R, ...)
#define   i_index_public_INST_EXTERN(X, R, ...)
#define   i_index_public_DECL(X, R, ...)
#define   i_index_public_GENERICS(X, R, ...)
#define   i_index_public_INIT(X, R, ...) \
    X##_type.emit_idx_symbol(index, __VA_ARGS__) = & emit_idx_symbol(X ## _index, __VA_ARGS__); \
    X##_type.members[X##_type.member_count].name        = stringify(emit_idx_symbol(index, __VA_ARGS__)); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { emit_types(X, __VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type        = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, emit_idx_symbol(index, __VA_ARGS__)); \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_INDEX; \
    X##_type.member_count++;  
#define i_index_public_PROTO(X, R, ...)
#define i_index_public_METHOD(X, R, ...)                R (*emit_idx_symbol(index,__VA_ARGS__))(X, ##__VA_ARGS__);

#define i_index_intern_INST(X, R, ...)
#define i_index_intern_INST_EXTERN(X, R, ...)
#define i_index_intern_DECL(X, R, ...)
#define i_index_intern_GENERICS(X, R, ...)
#define i_index_intern_INIT(X, R, ...)
#define i_index_intern_PROTO(X, R, ...)
#define i_index_intern_METHOD(X, R, ...)                R (*emit_idx_symbol(index, __VA_ARGS__))(X, ##__VA_ARGS__);
#define i_index(X, Y, T, R, ...)                        i_index_##T##_##Y(X, R, ##__VA_ARGS__)

#define i_vargs_public_INST(X, R, N, ...)
#define i_vargs_public_INST_EXTERN(X, R, N, ...)
#define i_vargs_public_DECL(X, R, N, ...)
#define i_vargs_public_GENERICS(X, R, N, ...)
#define i_vargs_public_INIT(X, R, N, ...)               i_method_public_INIT(X, R, N, __VA_ARGS__)  
#define i_vargs_public_PROTO(X, R, N, ...)
#define i_vargs_public_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);

#define i_vargs_intern_INST(X, R, N, ...)
#define i_vargs_intern_INST_EXTERN(X, R, N, ...)
#define i_vargs_intern_DECL(X, R, N, ...)
#define i_vargs_intern_GENERICS(X, R, N, ...)
#define i_vargs_intern_INIT(X, R, N, ...)               i_method_intern_INIT(X, R, N, __VA_ARGS__)  
#define i_vargs_intern_PROTO(X, R, N, ...)
#define i_vargs_intern_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);
#define i_vargs(X, Y, T, R, N, ...)                     i_vargs_##T##_##Y(X, R, N, __VA_ARGS__)

#define s_vargs_public_INST(X, R, N, ...)
#define s_vargs_public_INST_EXTERN(X, R, N, ...)
#define s_vargs_public_DECL(X, R, N, ...)               R X##_##N(__VA_ARGS__, ...);
#define s_vargs_public_GENERICS(X, R, N, ...)
#define s_vargs_public_INIT(X, R, N, ...)               s_method_public_INIT(X, R, N, ##__VA_ARGS__)
#define s_vargs_public_PROTO(X, R, N, ...)
#define s_vargs_public_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);

#define s_vargs_intern_INST(X, R, N, ...)
#define s_vargs_intern_INST_EXTERN(X, R, N, ...)
#define s_vargs_intern_DECL(X, R, N, ...)
#define s_vargs_intern_GENERICS(X, R, N, ...)
#define s_vargs_intern_INIT(X, R, N, ...)               s_method_intern_INIT(X, R, N, ##__VA_ARGS__)
#define s_vargs_intern_PROTO(X, R, N, ...)
#define s_vargs_intern_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);
#define s_vargs(X, Y, T, R, N, ...)                     s_vargs_##T##_##Y(X, R, N, ##__VA_ARGS__)

#define i_override_method_INST(X, N)
#define i_override_method_INST_EXTERN(X, N)
#define i_override_method_DECL(X, N)
#define i_override_method_GENERICS(X, N)
#define i_override_method_INIT(X, N) \
    X##_type . N = (__typeof__(X##_type . N))& X## _ ## N;

#define i_override_method_PROTO(X, N)
#define i_override_method_METHOD(X, N)

#define i_override_ctr_INST(X, R)
#define i_override_ctr_INST_EXTERN(X, N)
#define i_override_ctr_DECL(X, R)
#define i_override_ctr_GENERICS(X, N)                   N: X##_type.with_##N,
#define i_override_ctr_INIT(X, R) \
    X##_type . with_##R = & X##_with_##R; \
    X##_type.members[X##_type.member_count].name        = stringify(with_##R); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { emit_types(R) }; \
    X##_type.members[X##_type.member_count].type        = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, with_##R); \
    X##_type.members[X##_type.member_count].ptr         = (void*)& X##_with_##R; \
    X##_type.members[X##_type.member_count].member_type = A_MEMBER_CONSTRUCT; \
    X##_type.member_count++; 
#define i_override_ctr_PROTO(X, R)
#define i_override_ctr_METHOD(X, R)

#define i_override_cast_INST(X, R)
#define i_override_cast_INST_EXTERN(X, R)
#define i_override_cast_DECL(X, R)
#define i_override_cast_GENERICS(X, N)
#define i_override_cast_INIT(X, R)                      X##_type . cast_##R = & X##_cast_##R;
#define i_override_cast_PROTO(X, R)
#define i_override_cast_METHOD(X, R)

#define i_override_idx_INST(X, R)
#define i_override_idx_INST_EXTERN(X, R)
#define i_override_idx_DECL(X, R)
#define i_override_idx_GENERICS(X, R)
#define i_override_idx_INIT(X, R)                    X##_type . idx_##R = & X##_idx_##R;
#define i_override_idx_PROTO(X, R)
#define i_override_idx_METHOD(X, R)

#define i_override_1(X, Y, OT, N, ...) \
    i_override_##OT##_##Y(X, N)

#define i_override_2(X, Y, OT, N, N2) \
    i_override_##OT##_##Y(X, N) \
    i_override_##OT##_##Y(X, N2)

#define i_override_3(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3)

#define i_override_4(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3) \
    i_override_##OT##_##Y(X, N4)

#define i_override_5(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3) \
    i_override_##OT##_##Y(X, N4) \
    i_override_##OT##_##Y(X, N5)

#define i_override_6(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3) \
    i_override_##OT##_##Y(X, N4) \
    i_override_##OT##_##Y(X, N5) \
    i_override_##OT##_##Y(X, N6)

#define i_override_7(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3) \
    i_override_##OT##_##Y(X, N4) \
    i_override_##OT##_##Y(X, N5) \
    i_override_##OT##_##Y(X, N6) \
    i_override_##OT##_##Y(X, N7)

#define i_override_8(X, Y, OT, N, N2, N3) \
    i_override_##OT##_##Y(X, N)  \
    i_override_##OT##_##Y(X, N2) \
    i_override_##OT##_##Y(X, N3) \
    i_override_##OT##_##Y(X, N4) \
    i_override_##OT##_##Y(X, N5) \
    i_override_##OT##_##Y(X, N6) \
    i_override_##OT##_##Y(X, N7) \
    i_override_##OT##_##Y(X, N8)

#define ARG_COUNT_HELPER(_1, _2, N, ...) N
#define ARG_COUNT_NO_ZERO(...) \
    ARG_COUNT_HELPER(__VA_ARGS__, 2, 1, 0)

#define CONCAT_HELPER(x, y) x##y
#define CONCAT(x, y) CONCAT_HELPER(x, y)

#define i_override(X, Y, OT, N, ...) \
    CONCAT(i_override_, ARG_COUNT_NO_ZERO(__VA_ARGS__))(X, Y, OT, N __VA_OPT__(,) __VA_ARGS__)


//#define i_override(X, Y, OT, N) i_override_##OT##_##Y(X, N)

/// useful for fetching from va_args if they are used; this is how we enable the meta-types on the classes
/// they get a global constructor and type structure, with function table identical except for the call signature
/// at runtime they see their own meta, and may perform validation or different behavior based on those 'types'
/// in the meta array (max is 8)

#define FIRST_HELPER(FIRST, ...) FIRST
#define SECOND_HELPER(FIRST, SECOND, ...) SECOND
#define META0(...)  FIRST_HELPER(__VA_ARGS__, object)
#define META1(...) SECOND_HELPER(__VA_ARGS__, object, object)

typedef struct method_t {
    struct _array*  atypes;
    struct _A_f*    rtype;
    void*           address;
    void*           ffi_cif;  /// ffi-calling info
    void*           ffi_args; /// ffi-data types for args
} method_t;

// when scalar is set, this is known as a class that shapes this data
// the complexity arises when we may want to perform shape on this high level class
// at the moment, a simple rule is sufficient for our use-cases, when scalar is set, it takes the shape
#define A_f_members(B) \
    struct _ ## B ## _f* parent_type; \
    char*           name; \
    char*           module; \
    int             size; \
    int             msize; \
    shape           vmember_shape; \
    int             vmember_count; \
    AType           vmember_type; \
    int             member_count; \
    type_member_t*  members; \
    int             traits; \
    AType           src; \
    void*           arb; \
    meta_t          meta; \

#ifdef __cplusplus
#define declare_typedef(X) \
    typedef struct _ ## X* X;
#else
#define declare_typedef(X) \
    typedef struct _ ## X* X;
#endif

#ifdef __cplusplus
#define declare_typedef_e(X)
#else
#define declare_typedef_e(X) \
    typedef enum X X;
#endif

#define declare_base( X ) \
    declare_typedef(X) \
    _Pragma("pack(push, 1)") \
    typedef struct _ ## X { \
        X##_schema (X, INST) \
        struct _##X##_f* f; \
    } *X; \
    X##_schema (X, DECL) \
    typedef struct _##X##_f { \
        A_f_members(A) \
        X##_schema (X, METHOD) \
    } X##_f; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define declare_abstract( X, ... ) \
    declare_typedef(X) \
    _Pragma("pack(push, 1)") \
    typedef struct _##X##_f { \
        A_f_members(A) \
        A_schema(A, METHOD) \
        X##_schema(X, METHOD, __VA_ARGS__) \
    } X##_f, *X##_ft; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define declare_primitive( X, Y, ... ) \
    _Pragma("pack(push, 1)") \
    typedef struct _##X##_f { \
        A_f_members(A) \
        A_schema(A, METHOD, __VA_ARGS__) \
        X##_schema(X, METHOD, __VA_ARGS__) \
    } X##_f, *X##_ft; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define ENUM_COUNT(...)  (sizeof((int[]){__VA_ARGS__}) / sizeof(int))

#define declare_enum( E ) \
    enum E { \
        E##_schema(E, DECL) \
    }; \
    declare_typedef_e(E) \
    _Pragma("pack(push, 1)") \
    typedef struct _##E##_f { \
        A_f_members(A) \
        A_schema   (A, METHOD) \
        E##_schema (A, METHOD) \
    } E##_f, *E##_ft; \
    _Pragma("pack(pop)") \
    enum { E##_ENUM_COUNT = ENUM_COUNT(E##_schema(E, COUNT)) }; \
    extern E##_f   E##_type;

void A_push_type(AType type);

void        A_lazy_init(global_init_fn fn);

#define define_enum( E ) \
    _Pragma("pack(push, 1)") \
    struct _A E ## _redirect; \
    E ## _f   E ## _type; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool global_##E() { \
        memset(&E ## _redirect, 0, sizeof(E ## _redirect)); \
        E ## _redirect.type = &E ## _type; \
        E ## _f* type_ref = &E ## _type; \
        A_f* base_ref     = &A_type; \
        if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##E); \
            return false; \
        } else { \
            memcpy(type_ref, base_ref, sizeof(A_f)); \
            static type_member_t members[64 + E##_ENUM_COUNT + sizeof(E##_type) / sizeof(void*)]; \
            memset(&E##_type, 0, sizeof(E##_type)); \
            E##_type.parent_type = (__typeof__(E##_type.parent_type))& A_type; \
            E##_type.name     = #E;                 \
            E##_type.module   = MODULE;             \
            E##_type.size     = sizeof(enum E);     \
            E##_type.members  = members;            \
            E##_type.member_count = 0;              \
            E##_type.traits   = A_TRAIT_ENUM;       \
            E##_type.arb      = primitive_ffi_arb(typeid(i32)); \
            E##_schema( E, IMPL ); \
            A_push_type((AType)&E##_type); \
            return true; \
        } \
    }

#define declare_class\
(AA, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        AA##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* f; \
    } *AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define declare_sentry\
(AA) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        struct _##AA##_f* f; \
    } *AA; \
    typedef struct _##AA##_f { \
        A_f_members(AA) \
        A_schema(AA, METHOD) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define declare_meta\
(AA, BASE, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        BASE##_intern (BASE, INST, __VA_ARGS__) \
        AA##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* f; \
    } *AA; \
    typedef struct _##AA##_f { \
        A_f_members(BASE) \
        A_schema(AA, METHOD, __VA_ARGS__) \
        BASE##_schema (AA, METHOD, __VA_ARGS__) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define declare_base_meta\
(AA, BASE, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        BASE##_intern (AA, INST, __VA_ARGS__) \
        struct _##AA##_f* f; \
    } *AA; \
    typedef struct _##AA##_f { \
        A_f_members(BASE) \
        BASE##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define declare_struct\
(AA,...) \
    typedef struct _##AA AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        AA##_schema (AA, INST, __VA_ARGS__) \
    } AA; \
    AA##_schema (AA, DECL, __VA_ARGS__) \
    typedef struct _##AA##_f { \
        A_f_members(BB) \
        AA##_schema (AA, METHOD, __VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define arg_count_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define arg_count(...) arg_count_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define declare_mod\
(AA, BB, ...) \
    declare_subclass_ex(AA, BB, arg_count(AA, BB, ## __VA_ARGS__), AA, BB, ## __VA_ARGS__)

#define declare_subclass_ex(AA, BB, N, ...) \
    typedef struct _##AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct _##AA { \
        _COMBINE(dm_f_, N)(__VA_ARGS__) \
        struct _##AA##_f* f; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct _##AA##_f { \
        A_f_members(BB) \
        A_schema(object, METHOD) \
        _COMBINE(dm_i_, N)(__VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

/// six levels of sub-class should be fine --gates 1985 [not bill]
#define dm_f_1(A0)          A0##_intern (A0, INST) // for internal it calls A##_schema(A, INST), for external the macro is set to A##_schema(A, Y##_EXTERN)
#define dm_f_2(A0, A1)      dm_f_1(A1)     dm_f_1(A0)
#define dm_f_3(A0, A1, A2)  dm_f_2(A1, A2) dm_f_1(A0)

#define dm_f_4(A0, A1, A2, A3)          dm_f_2(A2, A3)          dm_f_2(A0, A1)
#define dm_f_5(A0, A1, A2, A3, A4)      dm_f_4(A1, A2, A3, A4)  dm_f_1(A0)
#define dm_f_6(A0, A1, A2, A3, A4, A5)  dm_f_4(A2, A3, A4, A5)  dm_f_2(A0, A1)

#define dm_i_1(A0) A0##_schema (A0, METHOD)

#define dm_i_2(A0, A1) dm_i_1(A1) dm_i_1(A0)

#define dm_i_3(A0, A1, A2)              dm_i_2(A1, A2)         dm_i_1(A0)
#define dm_i_4(A0, A1, A2, A3)          dm_i_2(A2, A3)         dm_i_2(A0, A1)
#define dm_i_5(A0, A1, A2, A3, A4)      dm_i_4(A1, A2, A3, A4) dm_i_1(A0)
#define dm_i_6(A0, A1, A2, A3, A4, A5)  dm_i_4(A2, A3, A4, A5) dm_i_2(A0, A1)

#define module_init(fn) \
    static bool _module_init() { \
        fn(); \
        return true; \
    } \
    static __attribute__((constructor)) void _module_register() { \
        A_module_init((global_init_fn)&_module_init); \
    }


void* primitive_ffi_arb(AType);

#define define_sentry(A0, VMEMBER_COUNT, ...) \
    _Pragma("pack(push, 1)") \
    A       A0##_head; \
    A0##_f  A0##_type; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool Aglobal_##A0() { \
        A0##_f* type_ref = &A0##_type; \
        A_f* base_ref = &A_type; \
        if ((AType)type_ref == (AType)base_ref) \
            type_ref->name = #A0; \
        if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { \
            A_lazy_init((global_init_fn)&Aglobal_##A0); \
            return false; \
        } else { \
            memset(type_ref, 0,        sizeof(A0##_f)); \
            memcpy(type_ref, base_ref, sizeof(A_f)); \
            static type_member_t members[64 + sizeof(A0##_type) / sizeof(void*)]; \
            type_ref->parent_type = (__typeof__(type_ref->parent_type))&A_type; \
            type_ref->name     = #A0;       \
            type_ref->module   = MODULE;    \
            type_ref->members  = members;   \
            type_ref->member_count = 0; \
            type_ref->size     = 0;   \
            type_ref->vmember_count = VMEMBER_COUNT; \
            type_ref->arb       = primitive_ffi_arb(typeid(A0)); \
            A_push_type((AType)type_ref);    \
            return true;                     \
        }                                    \
    }

#define define_init(id, ...) \
    static __attribute__((constructor)) none Aglobal_initializer_##id() { \
        __VA_ARGS__; \
    }

// define any class as vectorable; useful for serialization and other things
#define define_vector(t, scalar, count) \
    define_init(t, t##_type.vmember_type = typeid(scalar); t##_type.vmember_count = count)


/// alias lets use tag types with an array of types, enabling 
/// design-time and runtime template-like functionality, with 
/// permutation of the class-type and instance-type
#define define_arb(TYPE, BASE, TYPE_SZ, TRAIT, VMEMBER_COUNT, VMEMBER_TYPE, ...) \
    _Pragma("pack(push, 1)") \
    A       TYPE##_head; \
    TYPE##_f  TYPE##_type; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool Aglobal_##TYPE() { \
        TYPE##_f* type_ref = &TYPE##_type; \
        BASE##_f* base_ref = &BASE##_type; \
        if ((AType)type_ref == (AType)base_ref) \
            type_ref->name = #TYPE; \
        if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { \
            A_lazy_init((global_init_fn)&Aglobal_##TYPE); \
            return false; \
        } else { \
            memset(type_ref, 0,        sizeof(TYPE##_f)); \
            memcpy(type_ref, base_ref, sizeof(BASE##_f)); \
            static type_member_t members[64 + sizeof(TYPE##_type) / sizeof(void*)]; \
            type_ref->parent_type = (__typeof__(type_ref->parent_type))&BASE##_type; \
            type_ref->name     = #TYPE;       \
            type_ref->module   = MODULE;    \
            type_ref->members  = members;   \
            type_ref->member_count = 0; \
            type_ref->size     = TYPE_SZ;   \
            type_ref->vmember_count = VMEMBER_COUNT; \
            type_ref->vmember_type = (AType)VMEMBER_TYPE; \
            type_ref->traits   = TRAIT;     \
            type_ref->arb       = primitive_ffi_arb(typeid(TYPE)); \
            TYPE##_schema( TYPE, INIT, __VA_ARGS__ ) \
            A_push_type((AType)type_ref);    \
            return true;                     \
        } \
    } \


#define define_meta(ALIAS_TYPE, SRC_TYPE, ...) \
    A              ALIAS_TYPE##_head; \
    ALIAS_TYPE##_f ALIAS_TYPE##_type; \
    static __attribute__((constructor)) bool global_##ALIAS_TYPE() { \
        ALIAS_TYPE##_f* type_ref = &ALIAS_TYPE##_type; \
        SRC_TYPE##_f* src_ref = &SRC_TYPE##_type; \
        if (src_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##ALIAS_TYPE); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(ALIAS_TYPE##_f)); \
            memcpy(&ALIAS_TYPE##_type, &SRC_TYPE##_type, sizeof(SRC_TYPE##_f)); \
            verify(sizeof(ALIAS_TYPE##_type) >= sizeof(SRC_TYPE##_type), "strange?"); \
            ALIAS_TYPE## _type.module  = MODULE; \
            ALIAS_TYPE##_type.name     = #ALIAS_TYPE; \
            ALIAS_TYPE##_type.src      = &SRC_TYPE##_type; \
            ALIAS_TYPE##_type.meta     = (meta_t) { emit_types(__VA_ARGS__) }; \
            ALIAS_TYPE##_type.traits   = A_TRAIT_ALIAS; \
            A_push_type((AType)&ALIAS_TYPE##_type);     \
            return true; \
        } \
    }


/// vector types.  this is worth commenting about
/// T = element type, t = suffix name for element, f for float for example, f64, etc
/// must provide the Size of the vector at define

#define define_alias(ALIAS_TYPE, SRC_TYPE) \
    A              ALIAS_TYPE##_head; \
    ALIAS_TYPE##_f ALIAS_TYPE##_type; \
    static __attribute__((constructor)) bool global_##ALIAS_TYPE() { \
        ALIAS_TYPE##_f* type_ref = &ALIAS_TYPE##_type; \
        SRC_TYPE##_f* src_ref = &SRC_TYPE##_type; \
        if (src_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##ALIAS_TYPE); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(ALIAS_TYPE##_f)); \
            memcpy(&ALIAS_TYPE##_type, &SRC_TYPE##_type, sizeof(SRC_TYPE##_f)); \
            ALIAS_TYPE##_type.module   = MODULE; \
            ALIAS_TYPE##_type.name     = #ALIAS_TYPE; \
            ALIAS_TYPE##_type.src      = &SRC_TYPE##_type; \
            ALIAS_TYPE##_type.traits   = A_TRAIT_ALIAS; \
            A_push_type((AType)&ALIAS_TYPE##_type);         \
            return true; \
        } \
    }

#define define_mod(A0, A1, ...) \
    define_arb(A0, A1, sizeof(struct _##A0), 0, 0, null, __VA_ARGS__)

#define define_class(A0, ...) \
    define_arb(A0, A, sizeof(struct _##A0), 0, 0, null, __VA_ARGS__)

#define define_struct(A0, ...) \
    define_arb(A0, A, sizeof(struct _##A0), A_TRAIT_STRUCT, 0, null, __VA_ARGS__)

/// primitives dont have construct/method support, but its abstract does
#define define_primitive(X, Y, traits, ...) \
    define_arb(X, Y, sizeof(X), traits | A_TRAIT_PRIMITIVE, 0, null, __VA_ARGS__)

#define define_abstract(X, ...) \
    define_arb(X, A, 0, A_TRAIT_ABSTRACT, 0, null, __VA_ARGS__)

forward(string)
struct _sz { i64 value; };

#define A_schema(X,Y,...) \
    i_prop  (X,Y, public, AType,     type) \
    i_prop  (X,Y, public, AType,     scalar) \
    i_prop  (X,Y, public, i64,       refs) \
    i_prop  (X,Y, public, i64,       ar_index) \
    i_prop  (X,Y, public, object,    data) \
    i_prop  (X,Y, public, shape,     shape) \
    i_prop  (X,Y, public, i64,       alloc) \
    i_prop  (X,Y, public, i64,       count) \
    i_method(X,Y, public, none,      init) \
    i_method(X,Y, public, none,      dealloc) \
    i_method(X,Y, public, i32,       compare,    X) \
    i_method(X,Y, public, u64,       hash) \
    i_method(X,Y, public, object,    copy) \
    i_method(X,Y, public, object,    data) \
    i_method(X,Y, public, AType,     data_type) \
    i_method(X,Y, public, i64,       data_stride) \
    i_ctr(   X,Y, public, cereal) \
    i_cast(  X,Y, public, string) \
    i_cast(  X,Y, public, bool)
#define A_intern(AA,YY,...)      A_schema(AA,YY,__VA_ARGS__)
#define object_intern(AA,YY,...) AA##_schema(AA,YY,__VA_ARGS__)
declare_base(A)

declare_base_meta(object, A, A)

#define typeid(X)   ((AType)&X##_type)

#define scalarof(X) head(X)->scalar

#define numeric_schema(X,Y,...)
declare_abstract(numeric)

#define string_like_schema(X,Y,...)
declare_abstract(string_like)

#define nil_schema(X,Y,...)
declare_abstract(nil)

#define raw_schema(X,Y,...)
declare_abstract(raw)

#define ref_schema(X,Y,...)
declare_abstract(ref)

#define imported_schema(X,Y,...)
declare_abstract(imported)

/// our numeric primitives have their constructs defined
/// this is so we have a defined construction method for data conversion, we actually need it registered
/// we may optimize the need for it to be called in C99 output once working
#define i8_schema(X,Y,...)          numeric_schema(X,Y,...)
#define i16_schema(X,Y,...)         numeric_schema(X,Y,...)
#define i32_schema(X,Y,...)         numeric_schema(X,Y,...)
#define i64_schema(X,Y,...)         numeric_schema(X,Y,...)
#define u8_schema(X,Y,...)          numeric_schema(X,Y,...)
#define u16_schema(X,Y,...)         numeric_schema(X,Y,...)
#define u32_schema(X,Y,...)         numeric_schema(X,Y,...)
#define u64_schema(X,Y,...)         numeric_schema(X,Y,...)
#define f32_schema(X,Y,...)         numeric_schema(X,Y,...)
#define f64_schema(X,Y,...)         numeric_schema(X,Y,...)
#define f128_schema(X,Y,...)        numeric_schema(X,Y,...)
#define AMember_schema(X,Y,...)     numeric_schema(X,Y,...)
#define bool_schema(X,Y,...)        numeric_schema(X,Y,...)
#define num_schema(X,Y,...)         numeric_schema(X,Y,...)
#define sz_schema(X,Y,...)          numeric_schema(X,Y,...)
#define cstr_schema(X,Y,...)        string_like_schema(X,Y,...)
#define symbol_schema(X,Y,...)      string_like_schema(X,Y,...)
#define cereal_schema(X,Y,...)      string_like_schema(X,Y,...)
#define none_schema(X,Y,...)        nil_schema(X,Y,...)
#define raw_t_schema(X,Y,...)       raw_schema(X,Y,...)
#define handle_schema(X,Y,...)      raw_schema(X,Y,...)
#define AType_schema(X,Y,...)       raw_schema(X,Y,...)
#define Member_schema(X,Y,...)      raw_schema(X,Y,...)
#define ARef_schema(X,Y,...)        ref_schema(X,Y,...)

#define floats_schema(X,Y,...)      raw_schema(X,Y,...)

/// meta gives us access to one token we can override with (F)
declare_primitive( i8,          numeric)
declare_primitive(i16,          numeric)
declare_primitive(i32,          numeric)
declare_primitive(i64,          numeric)
declare_primitive( u8,          numeric)
declare_primitive(u16,          numeric)
declare_primitive(u32,          numeric)
declare_primitive(u64,          numeric)
declare_primitive(f32,          numeric)
declare_primitive(f64,          numeric)
declare_primitive(f128,         numeric)
declare_primitive(AMember,      numeric)
declare_primitive(cstr,         string_like)
declare_primitive(symbol,       string_like)
declare_primitive(cereal,       string_like)
declare_primitive(bool,       numeric)
declare_primitive(none,         nil)
declare_primitive(num,          numeric)
declare_primitive(sz,           numeric)
declare_primitive(raw_t,        raw)
declare_primitive(handle,       raw)
/// whatever we can 'name', we can handle as a type of any pointer primitive
declare_primitive(AType,        raw)
declare_primitive(ARef,         ref)
declare_primitive(Member,       raw)

declare_primitive(floats,       raw)

/// doubly-linked item type, integrated key so we dont also need a 'field' type
#define item_schema(X,Y,...) \
    i_prop    (X,Y, public, X,         next) \
    i_prop    (X,Y, public, X,         prev) \
    i_prop    (X,Y, public, object,    value) \
    i_prop    (X,Y, public, object,    key) \
    i_override(X,Y, method, hash)    
declare_class(item)

/// lets mimmick the structure in llama.cpp
#define message_schema(X,Y,...) \
    i_prop(X,Y, public,   cstr, role) \
    i_prop(X,Y, public,   cstr, content) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, dealloc)
declare_class(message)

/// linked-list of elemental data
#define list_schema(X,Y,...) \
    i_prop  (X,Y, public,    item,    first) \
    i_prop  (X,Y, public,    item,    last)  \
    i_prop  (X,Y, public,    i64,     count) \
    i_method(X,Y, public,    object,  pop) \
    i_method(X,Y, public,    item,    push, object) \
    i_method(X,Y, public,    item,    insert_after, object, i32) \
    i_method(X,Y, public,    num,     index_of, object) \
    i_method(X,Y, public,    item,     item_of, object) \
    i_method(X,Y, public,    none,    sort,   ARef) \
    i_method(X,Y, public,    none,    remove, num) \
    i_method(X,Y, public,    none,    remove_item, item) \
    i_method(X,Y, public,    object,  get,  object) \
    i_method(X,Y, public,    num,     count)
declare_class(list)

/// array of elemental data
/// important to define the same operators here in silver definition of runtime
/// one has arguments (operator) and (cast) does not, thats always instance
/// we need different names for these.  they cannot both be considered 'operators'
/// we also need new data structure, so ops vs casts vs constructs vs methods
// += -= *= /= 
// ":", "+=", "-=", "*=", "/=", "|=",
// "&=", "^=", ">>=", "<<=", "%=", null);

#define OPType_schema(X,Y,...) \
    enum_value(X,Y, _undefined) \
    enum_value(X,Y, _add) \
    enum_value(X,Y, _sub) \
    enum_value(X,Y, _mul) \
    enum_value(X,Y, _div) \
    enum_value(X,Y, _or) \
    enum_value(X,Y, _and) \
    enum_value(X,Y, _xor) \
    enum_value(X,Y, _mod) \
    enum_value(X,Y, _right) \
    enum_value(X,Y, _left) \
    enum_value(X,Y, _compare) \
    enum_value(X,Y, _equal) \
    enum_value(X,Y, _not_equal) \
    enum_value(X,Y, _is) \
    enum_value(X,Y, _inherits) \
    enum_value(X,Y, _value_default) \
    enum_value(X,Y, _cond_value) \
    enum_value(X,Y, _assign) \
    enum_value(X,Y, _assign_add) \
    enum_value(X,Y, _assign_sub) \
    enum_value(X,Y, _assign_mul) \
    enum_value(X,Y, _assign_div) \
    enum_value(X,Y, _assign_or) \
    enum_value(X,Y, _assign_and) \
    enum_value(X,Y, _assign_xor) \
    enum_value(X,Y, _assign_mod) \
    enum_value(X,Y, _assign_right) \
    enum_value(X,Y, _assign_left)
declare_enum(OPType)

forward(path)
/*
#define buffer_schema(X,Y,...) \
    i_ctr (X,Y, public,   path) \
    i_ctr (X,Y, public,   i64) \
    i_prop(X,Y, public,   cstr, data) \
    i_prop(X,Y, public,   i64,  count) \
    i_prop(X,Y, public,   i64,  alloc) \
    i_method(X,Y, public, none, append, object, i32) \
    i_override(X,Y, method, dealloc)
declare_class(buffer)
*/

/*
new rule: no redefining C methods
#define file_schema(X,Y,...) \
    i_method(X,Y, public,   bool,   write, object) \
    i_method(X,Y, public,   object, file_read,  AType) \
    i_method(X,Y, public,   string, gets) \
    i_method(X,Y, public,   none,   file_close) \
    i_prop(X,Y,   public,   path,   src) \
    i_prop(X,Y,   public,   bool,   read) \
    i_prop(X,Y,   public,   bool,   write) \
    i_prop(X,Y,   public,   num,    size) \
    i_prop(X,Y,   public,   num,    location) \
    i_prop(X,Y,   public,   handle, id) \
    i_prop(X,Y,   public,   bool,   text_mode) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, dealloc) \
    i_override(X,Y, cast,   bool)
declare_class(file)
*/

forward(array)

#define shape_schema(X,Y,...) \
    i_method(X,Y, public, i64, total) \
    i_override(X,Y, method, compare) \
    i_ctr(X,Y, public, array) \
    i_prop(X,Y, public, i64, count) \
    i_array(X,Y, public, i64, 16, data)
declare_class(shape)

#define vector_schema(X,Y,...) \
    i_prop      (X,Y, public, num,     alloc) \
    i_prop      (X,Y, public, AType,   type) \
    i_prop      (X,Y, public, shape,   vshape) \
    i_method    (X,Y, public, none,    concat, ARef, num) \
    i_method    (X,Y, public, ARef,    get,  num) \
    i_method    (X,Y, public, none,    set,  num, ARef) \
    i_method    (X,Y, public, none,    push, A) \
    i_method    (X,Y, public, vector,  slice, num, num) \
    i_method    (X,Y, public, none,    realloc, sz) \
    i_method    (X,Y, public, none,    resize, sz) \
    i_method    (X,Y, public, sz,      len) \
    i_ctr       (X,Y, public, path) \
    i_override  (X,Y, method, init)
declare_class(vector)

none vector_with_path(vector a, path file_path);

// let us declare our vector with string
// object, user space is simply the cstring

#define subprocedure_schema(X,Y,...) \
    i_prop    (X,Y, required, object, target) \
    i_prop    (X,Y, public,   object, ctx) \
    i_prop    (X,Y, required, handle, addr) \
    i_method  (X,Y, public,   object, invoke, object)
declare_class(subprocedure)

#define subproc(targ, faddr, context) new(subprocedure, target, targ, ctx, context, addr, faddr) 

#define array_schema(X,Y,O) \
    i_vprop          (X,Y, public, O,    elements) \
    i_prop           (X,Y, public, bool, unmanaged) \
    i_prop           (X,Y, public, i32,  alloc) \
    i_prop           (X,Y, public, i32,  len) \
    s_vargs          (X,Y, public, array,   of,             object) \
    s_vargs          (X,Y, public, array,   of_cstr,        cstr) \
    i_method         (X,Y, public, O, first) \
    i_method         (X,Y, public, O,       last) \
    i_method         (X,Y, public, O,       pop) \
    i_method         (X,Y, public, none,    fill,           O) \
    i_method         (X,Y, public, array,   reverse) \
    i_method         (X,Y, public, none,    remove,         num) \
    i_method         (X,Y, public, none,    remove_weak,    num) \
    i_method         (X,Y, public, none,    push,           O) \
    i_method         (X,Y, public, none,    push_weak,      O) \
    i_method         (X,Y, public, none,    clear) \
    i_method         (X,Y, public, none,    concat,         array) \
    i_method         (X,Y, public, O, get, num) \
    i_method         (X,Y, public, num,     count) \
    i_method         (X,Y, public, sz,      len) \
    i_method         (X,Y, public, num,     index_of,       O) \
    i_operator       (X,Y, public, none,    _assign_add,    O) \
    i_operator       (X,Y, public, none,    _assign_sub,    num) \
    i_vargs          (X,Y, public, none,    push_symbols,   X, cstr) \
    i_vargs          (X,Y, public, none,    push_objects,   X, O) \
    i_index          (X,Y, public, O, num) \
    i_ctr            (X,Y, public, i32) \
    i_override       (X,Y, method, init) \
    i_override       (X,Y, cast,   bool) \
    i_override       (X,Y, cast,   string)
declare_class(array, object)

#define ATypes_schema(X,Y,...)
declare_meta(ATypes, array, AType)

#define AF_schema(X,Y,...) \
    i_prop      (X,Y, public, array, pool) \
    i_prop      (X,Y, public, sz,    start_size) \
    s_method    (X,Y, public, AF,    fetch, num) \
    s_method    (X,Y, public, AF,    initialize, sz) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, dealloc)
declare_class(AF)

#define hashmap_schema(X,Y,...) \
    i_prop      (X,Y, public, list,  data) \
    i_prop      (X,Y, public, num,   alloc) \
    i_prop      (X,Y, public, num,   count) \
    i_prop      (X,Y, public, bool,  unmanaged) \
    i_method    (X,Y, public, none,  remove, object) \
    i_method    (X,Y, public, none,  set, object, object) \
    i_method    (X,Y, public, object,get, object) \
    i_method    (X,Y, public, item,  fetch, object) \
    i_method    (X,Y, public, item,  lookup, object) \
    i_method    (X,Y, public, bool,  contains, object) \
    i_index     (X,Y, public, object, object) \
    i_override  (X,Y, cast,   string) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, cast,   bool)
declare_class(hashmap)

#define pair_schema(X,Y,...) \
    i_prop      (X,Y, public, item,    ref) \
    i_prop      (X,Y, public, object,  key) \
    i_prop      (X,Y, public, object,  value)
declare_class(pair)

extern int fault_level;

#define level_schema(X,Y,...) \
    enum_value(X,Y, info) \
    enum_value(X,Y, warn) \
    enum_value(X,Y, err)
declare_enum(level)

/// hmap stores the item, and our refs list has a value that holds that (origin = hmap)
#define map_schema(X,Y,...) \
    i_prop      (X,Y, intern,  hashmap,    hmap) \
    i_prop      (X,Y, public,  sz,         hsize) \
    i_prop      (X,Y, public,  bool,       unmanaged) \
    i_method    (X,Y, public,  none,       set,        object, object) \
    i_method    (X,Y, public,  item,       fetch,      object) \
    i_method    (X,Y, public,  bool,       rm,         object) \
    i_method    (X,Y, public,  bool,       contains,   object) \
    i_method    (X,Y, public,  none,       concat,     map) \
    i_method    (X,Y, public,  sz,         len) \
    i_index     (X,Y, public,  object, sz) \
    i_index     (X,Y, public,  object, object) \
    i_override  (X,Y, method,  get) \
    i_override  (X,Y, method,  init) \
    i_override  (X,Y, cast,    string) \
    i_override  (X,Y, cast,    bool)
declare_mod(map, list)

#define fn_schema(X,Y,...) \
    i_prop      (X,Y, intern, method_t*, method) \
    i_prop      (X,Y, public, object,    target) \
    i_prop      (X,Y, public, object,    context) \
    i_method    (X,Y, public, object,    call, array) \
    i_override  (X,Y, method,    hash)
declare_class(fn)

#define string_schema(X,Y,...) \
    i_prop    (X,Y,   public, symbol,  chars) \
    i_prop    (X,Y,   public, num,     alloc) \
    i_prop    (X,Y,   public, num,     ref_length) \
    i_prop    (X,Y,   public, num,     len) \
    i_prop    (X,Y,   public, u64,     h) \
    i_method  (X,Y,   public, sz,      len) \
    i_method  (X,Y,   public, string,  ucase) \
    i_method  (X,Y,   public, string,  lcase) \
    i_method  (X,Y,   public, array,   split, symbol) \
    i_method  (X,Y,   public, string,  escape) \
    i_method  (X,Y,   public, num,     index_of, symbol) \
    i_method  (X,Y,   public, none,    append, symbol) \
    i_method  (X,Y,   public, none,    append_count, symbol, i32) \
    i_method  (X,Y,   public, none,    push, u32) \
    i_method  (X,Y,   public, none,    concat, string) \
    i_method  (X,Y,   public, string,  trim) \
    i_method  (X,Y,   public, string,  mid, num, num) \
    i_method  (X,Y,   public, none,    reserve, num) \
    i_method  (X,Y,   public, none,    write, handle, bool) \
    i_method  (X,Y,   public, bool,    ends_with, symbol) \
    i_method  (X,Y,   public, bool,    starts_with, symbol) \
    i_method  (X,Y,   public, num,     cmp, symbol) \
    i_method  (X,Y,   public, bool,    eq,  symbol) \
    i_cast    (X,Y,   public, cstr) \
    i_cast    (X,Y,   public, sz) \
    i_cast    (X,Y,   public, path) \
    i_ctr     (X,Y,   public, symbol) \
    i_ctr     (X,Y,   public, cstr) \
    i_ctr     (X,Y,   public, i32) \
    i_index   (X,Y,   public, i32, num) \
    i_override(X,Y,   method, hash) \
    i_override(X,Y,   method, compare) \
    i_override(X,Y,   method, init) \
    i_override(X,Y,   cast,   bool) \
    i_override(X,Y,   method, copy)
declare_class(string)

#define path_schema(X,Y,...) \
    i_method    (X,Y, public, bool,   exists) \
    i_method    (X,Y, public, bool,   make_dir) \
    i_method    (X,Y, public, bool,   is_ext, symbol) \
    i_method    (X,Y, public, bool,   is_empty) \
    i_method    (X,Y, public, bool,   is_dir) \
    i_method    (X,Y, public, none,   cp, path, bool, bool) \
    i_method    (X,Y, public, path,   directory) \
    i_method    (X,Y, public, none,   cd) \
    i_method    (X,Y, public, string, stem) \
    i_method    (X,Y, public, string, ext) \
    i_method    (X,Y, public, string, filename) \
    i_method    (X,Y, public, path,   absolute) \
    i_method    (X,Y, public, path,   parent) \
    i_method    (X,Y, public, object, read, AType) \
    i_method    (X,Y, public, path,   change_ext, cstr) \
    i_method    (X,Y, public, array,  ls, string, bool) \
    i_method    (X,Y, public, bool,   move, path) \
    i_method    (X,Y, public, path,   latest_modified, ARef) \
    i_method    (X,Y, public, i64,    modified_time) \
    s_method    (X,Y, public, path,   cwd, sz) \
    s_method    (X,Y, public, path,   temp, symbol) \
    i_ctr       (X,Y, public, string) \
    i_override  (X,Y, ctr,  symbol) \
    i_override  (X,Y, ctr,  cstr) \
    i_override  (X,Y, cast, cstr) \
    i_override  (X,Y, cast, sz) \
    i_override  (X,Y, method, hash) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, cast,   bool) \
    i_override  (X,Y, cast,   string)
declare_mod(path, string)

#define line_schema(X,Y,...) \
    i_prop(X,Y, public, i32, indent) \
    i_prop(X,Y, public, array, text, of, string)
#undef line_intern
#define line_intern(X,Y,...) line_schema(X,Y,__VA_ARGS__)
declare_class(line)

path path_temp(symbol tmpl);

/// use %o to print objects, or % others -- octet is not a use-case we serve (use base-16 for that)
object A_formatter(AType rtype, FILE* f, object opt, symbol templ, ...);

#define Exists_schema(X,Y,...) \
    enum_value(X,Y, no) \
    enum_value(X,Y, file) \
    enum_value(X,Y, dir)
declare_enum(Exists)

extern FILE* logger;

#define         form(T, t, ...)   (T)A_formatter(typeid(T), null,   (object)false, (symbol)t, ## __VA_ARGS__)
#define    formatter(t, ...)      ((string)A_formatter((AType)null,      null,   (object)false, (symbol)t, ## __VA_ARGS__))
#define            f(t, ...)      ((string)A_formatter((AType)null,      null,   (object)false, (symbol)t, ## __VA_ARGS__))
#define         exec(t, ...)      A_exec(((string)A_formatter((AType)null, null, (object)false, (symbol)t, ## __VA_ARGS__)))
#define          tap(L)           (A_tap(L))
#define        untap(L)           (A_untap(L))
#define        A_log(L, t, ...)   A_formatter((AType)null,      stdout, str(L),  t, ## __VA_ARGS__)
#define          put(t,    ...)   A_formatter((AType)null,      stdout, (object)false, (symbol)t, ## __VA_ARGS__)
#define        print(t,    ...)   A_formatter((AType)null,      stdout, (object)true,  (symbol)t, ## __VA_ARGS__)
#define        error(t, ...)      A_formatter((AType)null,      stderr, (object)true,  (symbol)t, ## __VA_ARGS__)
#define        fault(t, ...) do { A_formatter((AType)null,      stderr, (object)true,  (symbol)t, ## __VA_ARGS__); exit(1); } while(0)
#define  file_exists(t, ...)     (A_exists(A_formatter((AType)null, null, (object)false, (symbol)t, ## __VA_ARGS__)) == Exists_file)
#define   dir_exists(t, ...)     (A_exists(A_formatter((AType)null, null, (object)false, (symbol)t, ## __VA_ARGS__)) == Exists_dir)
#ifndef NDEBUG
#define       assert(a, t, ...) do { if (!(a)) { A_formatter((AType)null, stderr, (object)true,  t, ## __VA_ARGS__); exit(1); } } while(0)
#else
#define       assert(a, t, ...) do { } while(0)
#endif
#define       verify(a, t, ...) \
    do { \
        if (!(a)) { \
            A_formatter((AType)null, stderr, (object)true,  (symbol)t, ## __VA_ARGS__); \
            if (level_err >= fault_level) { \
                exit(1); \
            } \
        } \
    } while(0)

cstr copy_cstr(cstr input);

int A_exec(string cmd);

#define backwards(container, E, e) \
    if (len(((array)container))) for (E e = get(((array)container), len(((array)container)) - 1), e0 = 0; e0 == 0; e0++) \
        for (num __i = len(((array)container)); __i >= 0; __i--, e = __i >= 0 ? (E)get(((array)container), __i) : (E)null) \

/// we can iterate through a collection with this strange code
#define each(container, E, e) \
    if (len(((array)container))) for (E e = get(((array)container), 0), e0 = 0; e0 == 0; e0++) \
        for (num __i = 0, __len = len(((array)container)); __i < __len; __i++, e = get(((array)container), __i)) \

#define each_(container, E, e) \
    if (len(((array)container))) for (E e = get(((array)container), 0), e0 = 0; e0 == 0; e0++) \
        for (num __i = 0, __len = len(((array)container)); __i < __len; __i++, e = get(((array)container), __i)) \

#define values(container, E, e) \
    if (len(((array)container))) for (E e = *(E*)get(((array)container), 0), e0 = 0; e0 == 0; e0++) \
        for (num __i = 0, __len = len(((array)container)); __i < __len; __i++, e = *(E*)get(((array)container), __i)) \

#define vec_values(container, E, e) \
    if (len((container))) for (E e = get((container), 0), e0 = 0; e0 == 0; e0++) \
        for (num __i = 0, __len = len((container)); __i < __len; __i++, e = get((container), __i)) \

/// we can go through a map
#define pairs(MM, EE) \
    if (MM && cast(bool, MM)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (pair EE = (pair)_i->value, e0 = EE; EE == e0; e0++) \

#define evalues(MM, TT, EE) \
    if (MM && cast(bool, MM)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (TT EE = ((item)_i->value)->value, e0 = EE; EE == e0; e0++) \

#define ekeys(MM, TT, EE) \
    if (MM && cast(bool, MM)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (TT EE = ((pair)_i->value)->key, e0 = EE; EE == e0; e0++) \

#define pairs_(MM, EE) \
    if (MM && cast(bool, MM)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (pair EE = (pair)_i->value, e0 = EE; EE == e0; e0++) \

#define min(A, B) ({ \
    __typeof__(A) a = A; \
    __typeof__(B) b = B; \
    __typeof__(A) r = a < b ? a : b; \
    r; \
})

#define max(A, B) ({ \
    __typeof__(A) a = A; \
    __typeof__(B) b = B; \
    __typeof__(A) r = a > b ? a : b; \
    r; \
})

/// possible to iterate safely through primitives
#define primitives(arr, E, e) \
    if (len(arr)) for (E e = *(E*)get(arr, 0), e0 = 0; e0 == 0; e0++) \
        for (num i = 0, __len = len(arr); i < __len; i++, e = *(E*)get(arr, i)) \

object     A_alloc (AType type, num    count, bool af_pool);
object     A_alloc_extra(AType type, num extra, bool af_pool);
object     A_alloc2(AType type, AType scalar, shape shape, bool af_pool);
object     A_valloc(AType type, AType scalar, int alloc, int count, bool af_pool);
string     evaluate(string, map);
string     serialize_environment(map, bool);

/// we are not registering struct types because we have no idea of membership
/// however we may allocate based on their size
#define A_struct(T) A_alloc(typeid(u8), sizeof(T), true)

string      A_enum_string(AType type, i32 value);
i32         A_enum_value(AType type, cstr cs);
#define     e_str(E,I) A_enum_string(typeid(E), I)
#define     e_val(E,S) A_enum_value (typeid(E), S)

bool        isname(char n);
bool        A_is_inlay(type_member_t* m);
object      A_new(AType);
object      A_construct(AType, int, ...);
void        A_serialize(AType type, string res, object a);
object      A_initialize(object); /// called after 'construction' ... this is so we do something generic in init, and support named args
object      A_convert(AType, object);
type_member_t* A_constructor(AType, AType); // find a constructor method (used for dynamic construction)
object      A_instanceof(object, AType); // would be nice to actually allow typeid vs typeid here
object      A_hold(object a);
AType       A_lookup_type(cstr);
void        A_drop(object a);
sz          A_len(object a);
none        A_tap(symbol, subprocedure);
none        A_untap(symbol);
object      A_set_property(object instance, symbol name, object value);
object      A_get_property(object instance, symbol name);
num         index_of_cstr(object a, cstr f);
Exists      A_exists(object a);
num         clamp(num i, num mn, num mx);
real        clampf(real, real, real);
object      construct_with(AType type, object data);
bool        constructs_with(AType type, AType data_type);
i64         read_integer(object data);
#define     drop(a) A_drop(a)
#define     hold(a) (__typeof__(a))A_hold(a)


/// should be adapted to work with schemas 
/// what a weird thing it would be to have map access to properties
/// everything should be A-based, and forget about the argument hacks?
AType       A_find_type(symbol name);
map         A_arguments(int argc, symbol argv[], map default_values, object default_key);
AF          A_pool(sz size);
void        A_free(object a);
A_f**       A_types(num* length);
type_member_t* A_member(AType type, enum A_MEMBER member_type, symbol name, bool poly);
object      A_method_call(method_t* a, array args);
object      A_method(AType type, char* method_name, array args);
object      A_method_vargs(object instance, cstr method_name, int n_args, ...);
fn          A_lambda(object target, type_member_t* member, object context);
object      A_call(object instance, type_member_t* member, array args);
object      A_primitive(AType type, void* data);
object      A_enum(AType enum_type, i32 value);
object      A_i8(i8);
object      A_u8(u8);
object      A_i16(i16);
object      A_u16(u16);
object      A_i32(i32);
object      A_u32(u32);
object      A_i64(i64);
object          i(i64);
object      A_sz(sz);
object      A_u64(u64);
object      A_f32(f32);
object      A_f64(f64);
object  float32(f32);
object   real64(f64);
object      A_cstr(cstr);
object      A_none();
object      A_bool(bool);
object      A_realloc(object, sz);
object      A_resize(object, sz);
string      A_cast_string(A a);
void        A_push(object, object);
void        A_start();
map         A_args(int argc, symbol argv[], symbol default_arg, ...);
A           A_header(object instance);
pid_t       A_last_pid();

#define head(o) A_header((object)o)

//object      A_data(object instance);
object      A_verify(object instance, AType type);
void        A_module_init(bool(*fn)());
void        debug();
void        br();
bool        A_reflect(symbol location);

object parse(cstr s, AType schema);

#define vdata(instance) A_data(instance)

bool      is_meta(object a);
bool      is_meta_compatible(object a, object b);

bool create_symlink(path target, path link);

/// todo: auto-release, no use of drop in most places
/// push_weak is probably a reasonable idea for array
map   map_of(symbol first_key, ...); /// cstr, A, ...
//array array_of(object first, ...);
//array array_of_cstr(cstr first, ...);
void  array_weak_push(array, object);

/// you can be a typedef and a macro -- it makes APIs simpler
shape shape_new(i64 count, ...);
shape shape_from(i64 count, i64* dims);
shape shape_read(FILE* f);

#define array_string_schema(X,Y,...)
declare_meta(array_string,     array, string)

#define array_map_schema(X,Y,...)
declare_meta(array_map,        array, map)

// shape-specific vector implementations
// declare vector types for common numeric types
// we still define type + shape together, so vec + 3 is vec3, if its mat, 4x4 then mat4x4f.. its simple shape in type
// it has its own unique type identity.

#include <A-public>
#ifdef __cplusplus
}
#endif

#endif