#ifndef _A_
#define _A_

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <libgen.h>
#include <unistd.h>
#include <signal.h>

/// A-type runtime
typedef void                none;
typedef signed char         i8;
typedef short               i16;
typedef int                 i32;
typedef long long           i64;
typedef unsigned char       u8;
typedef unsigned short      u16;
typedef unsigned int        u32;
typedef unsigned long long  u64;
typedef long long           num;
typedef long long           sz;      /// a signed 64 bit size lets us act like python, so this is a type for the purpose of indexing and all valid sizes
typedef unsigned int        bool;
typedef float               f32;
typedef double              f64;
typedef long double         f128;
typedef double              real;    /// real enough
typedef void*               handle;
typedef char*               cstr;
typedef const char*         symbol;
typedef const char*         cereal;
//typedef struct A_f*       AType;
typedef struct A*           object;
typedef struct A**          ARef;
typedef struct A*           A;
typedef struct type_member_t* Member;

void*   calloc(size_t num, size_t size);
void    free();
void    exit(int);
int     abs(int);
cstr    realpath(symbol, symbol);
FILE   *popen(symbol command, symbol type);
int     pclose(FILE*);
i64     strtoll(symbol str, cstr* endptr, int base);
f64     strtod (symbol str, cstr* endptr);
int     system(symbol command);
int     setenv(symbol key, symbol value, int);
cstr    getenv(symbol key);


typedef bool(*global_init_fn)();

#define true                (bool)1
#define false               (bool)0
#define stringify(x)        #x
#define null                ((void*)0)
#define FNV_PRIME           0x100000001b3
#define OFFSET_BASIS        0xcbf29ce484222325

/// our A-type classes have many types of methods
/// constructor, i[nstance]-method, s[tatic]-method, operator (these are enumerable!), and index.  we index by 1 argument only in C but we may allow for more in silver
enum A_TYPE {
    A_TYPE_NONE      = 0,
    A_TYPE_CONSTRUCT = 1,
    A_TYPE_PROP      = 2,
    A_TYPE_PRIV      = 4,
    A_TYPE_INTERN    = 8,
    A_TYPE_IMETHOD   = 16,
    A_TYPE_SMETHOD   = 32,
    A_TYPE_OPERATOR  = 64,
    A_TYPE_CAST      = 128,
    A_TYPE_INDEX     = 256,
    A_TYPE_ENUMV     = 512,
    A_TYPE_OVERRIDE  = 1024 /// being explicit with this is important, because we only infer by memory checks otherwise
};                          /// its not that its annoying to write its just more important for the override to be a real member with reference

enum A_TRAIT {
    A_TRAIT_PRIMITIVE = 1,
    A_TRAIT_INTEGRAL  = 2,
    A_TRAIT_REALISTIC = 4,
    A_TRAIT_SIGNED    = 8,
    A_TRAIT_UNSIGNED  = 16,
    A_TRAIT_ENUM      = 32,
    A_TRAIT_ALIAS     = 64,
    A_TRAIT_ABSTRACT  = 128
};

#define   enum_value_DECL(E, N)             E##_##N,
#define   enum_value_COUNT(E, N)            1,
#define   enum_value_IMPL(E, N) \
    E##_type.members[E## _type.member_count].name     = #N; \
    E##_type.members[E## _type.member_count].offset   = E##_##N;\
    E##_type.members[E## _type.member_count].type     = &i32_type; \
    E##_type.members[E## _type.member_count].member_type = A_TYPE_ENUMV; \
    E##_type.member_count++;
#define   enum_value(X,Y, N)                enum_value_##Y(X, N)


/// A_init method is simple: named args are set, then an init() is called from base to top
/// we will need to support 16 args for 8 props

// runtime type-check api
#ifndef NDEBUG
    //intern needs to be effectively switched on to introspect for debug-only
    //it would be useful to runtime verify args, though
    //#define TC(MEMBER, VALUE) A_validate_type(VALUE, A_member(isa(instance), A_TYPE_PROP|A_TYPE_INTERN|A_TYPE_PRIV, #MEMBER)->type)
    #define TC(MEMBER, VALUE) VALUE
#else
    #define TC(MEMBER, VALUE) VALUE
#endif

#define _ARG_COUNT_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, N, ...) N
#define _ARG_COUNT(...)        _ARG_COUNT_IMPL(__VA_ARGS__, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#define _COMBINE_(A, B)        A##B
#define _COMBINE(A, B)         _COMBINE_(A, B)
#define _N_ARGS_HELPER(N, ...) _COMBINE(EXPAND_ARGS_, N)(__VA_ARGS__)
#define _N_ARGS_0()
#define _N_ARGS_1()                  
#define _N_ARGS_2(a,b)                                       instance->a = TC(a,b);
#define _N_ARGS_4(a,b, c,d)                                  _N_ARGS_2 (a,b) instance->c = TC(c,d);
#define _N_ARGS_6(a,b, c,d, e,f)                             _N_ARGS_4 (a,b, c, d) instance->e = TC(e,f);
#define _N_ARGS_8(a,b, c,d, e,f, g,h)                        _N_ARGS_6 (a,b, c, d, e, f) instance->g = TC(g,h);
#define _N_ARGS_10(a,b, c,d, e,f, g,h, i,j)                  _N_ARGS_8 (a,b, c,d, e,f, g,h) instance->i = TC(i,j);
#define _N_ARGS_12(a,b, c,d, e,f, g,h, i,j, l,m)             _N_ARGS_10(a,b, c,d, e,f, g,h, i,j) instance->l = TC(l,m);
#define _N_ARGS_14(a,b, c,d, e,f, g,h, i,j, l,m, n,o)        _N_ARGS_12(a,b, c,d, e,f, g,h, i,j, l,m) instance->n = TC(n,o);
#define _N_ARGS_16(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q)   _N_ARGS_14(a,b, c,d, e,f, g,h, i,j, l,m, n,o) instance->p = TC(p,q);
#define _N_ARGS_18(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s) \
    _N_ARGS_16(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q) instance->r = TC(r,s);
#define _N_ARGS_20(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u) \
    _N_ARGS_18(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s) instance->t = TC(t,u);
#define _N_ARGS_22(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u, v,w) \
    _N_ARGS_20(a,b, c,d, e,f, g,h, i,j, l,m, n,o, p,q, r,s, t,u) instance->v = TC(v,w);
#define _N_ARGS(instance,...)    _N_ARGS_HELPER2(_ARG_COUNT(__VA_ARGS__), __VA_ARGS__)
#define _N_ARGS_HELPER2(N, ...)  _COMBINE(_N_ARGS_, N)(__VA_ARGS__)
#define new(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, true); \
        _N_ARGS(instance, __VA_ARGS__); \
        A_initialize(instance); \
        instance; \
    })



#define _ARG_COUNT_IMPL2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, N, ...) N
#define _ARG_COUNT2(...)        _ARG_COUNT_IMPL2(__VA_ARGS__, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#define _COMBINE_2(A, B)        A##B
#define _COMBINE2(A, B)         _COMBINE_2(A, B)
#define _F(T, a,b)              (((1 << (i64)T##_##a) * b)) 
#define _F_ARGS_0(T)
#define _F_ARGS_1(T)                  
#define _F_ARGS_2(T, a,b)                    _F(T, a, b)
#define _F_ARGS_4(T, a,b, c,d)               _F_ARGS_2 (a,b) | _F(T, c,d)
#define _F_ARGS_6(T, a,b, c,d, e,f)          _F_ARGS_4 (a,b, c, d) | _F(T, e,f)
#define _F_ARGS_8(T, a,b, c,d, e,f, g,h)     _F_ARGS_6 (a,b, c, d, e, f) | _F(T, g,h)
#define _F_ARGS(T,...)    _F_ARGS_HELPER2(T, _ARG_COUNT2(__VA_ARGS__), __VA_ARGS__)
#define _F_ARGS_HELPER2(T, N, ...)  _COMBINE2(_F_ARGS_, N)(T, __VA_ARGS__)
#define flags(T, ...) _F_ARGS(T, __VA_ARGS__);





/// with construct we give it a dynamic type, symbols and A-values
#define construct(type, ...) \
    ({ \
        T instance = (T)A_alloc(type, 1, true); \
        _N_ARGS(instance, __VA_ARGS__); \
        A_initialize(instance); \
        instance; \
    })

#define new0(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, true); \
        _N_ARGS(instance, __VA_ARGS__); \
        A_initialize(instance); \
        instance; \
    })
//#define allocate(T)                 ((A)A_alloc(typeid(T), 1, false))
#define allocate(T, ...) \
    ({ \
        T instance = (T)A_alloc(typeid(T), 1, false); \
        _N_ARGS(instance, __VA_ARGS__); \
        A_initialize(instance); \
        instance; \
    })
#define valloc(T, N)                ((A)A_alloc(typeid(T), N, false))
#define ftable(TYPE, INSTANCE)      ((TYPE##_f*)((A)INSTANCE)[-1].type)
#define isa(INSTANCE)               (INSTANCE ? (struct A_f*)((struct A*)INSTANCE - 1)->type : (struct A_f*)0)
#define inherits(left, type)        (A_instanceof(left, typeid(type)) != null)
/// see: javascript; returns null if its not an instance-of; faults if you give it a null
#define instanceof(left, type)      A_instanceof(left, typeid(type))
#define ftableI(I)                  ((__typeof__((I)->f)) ((A)(I))[-1].type)
/// by defining these, we require their use; cant call() these methods
/// useful in two ways, less tokens and expansion inside call()
/// obviously we only collect so many, but they become keywords of our common language
/// it reserves their use for methods and not scope confusion with variables
#define set(I,...)                  ftableI(I) -> set(I, ##__VA_ARGS__)
#define get(I,...)                  ftableI(I) -> get(I, ##__VA_ARGS__)
#define push(I,...)                 ftableI(I) -> push(I, ##__VA_ARGS__)
#define clear(I,...)                ftableI(I) -> clear(I, ##__VA_ARGS__)
#define pop(I,...)                  ftableI(I) -> pop(I, ##__VA_ARGS__)
#define peek(I,...)                 ftableI(I) -> peek(I, ##__VA_ARGS__)
#define read(I,...)                 ftableI(I) -> read(I, ##__VA_ARGS__)
#define copy(I,...)                 ftableI(I) -> copy(I, ##__VA_ARGS__)
#define write(I,...)                ftableI(I) -> write(I, ##__VA_ARGS__)
#define close(I,...)                ftableI(I) -> close(I, ##__VA_ARGS__)
#define concat(I,...)               ftableI(I) -> concat(I, ##__VA_ARGS__)
#define mid(I,...)                  ftableI(I) -> mid(I, ##__VA_ARGS__)
#define process(I,...)              ftableI(I) -> process(I, ##__VA_ARGS__)
#define append(I,...)               ftableI(I) -> append(I, ##__VA_ARGS__)
#define eq(I,...)                   ftableI(I) -> eq(I, ##__VA_ARGS__)
#define equals(I,...)               ftableI(I) -> equals(I, ##__VA_ARGS__)
#define compare(I,...)              ftableI(I) -> compare(I, ##__VA_ARGS__)
#define count(I,...)                ((I)?ftableI(I) -> count(I, ##__VA_ARGS__):0)
#define contains(I,...)             ftableI(I) -> contains(I, ##__VA_ARGS__)
#define cmp(I,...)                  ftableI(I) -> cmp(I, ##__VA_ARGS__)
#define first(I,...)                ftableI(I) -> first(I, ##__VA_ARGS__)
#define last(I,...)                 ftableI(I) -> last(I, ##__VA_ARGS__)
#define exists(I,...)               ftableI(I) -> exists(I, ##__VA_ARGS__)
#define len(I,...)                  ((I) ? (i64)ftableI(I) -> len(I, ##__VA_ARGS__) : (i64)0)
#define cs(I)                       ((I) ? (cstr)(I)->chars : (cstr)null)
#define fetch(I,...)                ftableI(I) -> fetch(I, ##__VA_ARGS__)
#define lookup(I,...)               ftableI(I) -> lookup(I, ##__VA_ARGS__)
#define remove(I,...)               ftableI(I) -> remove(I, ##__VA_ARGS__)
#define remove_item(I,...)          ftableI(I) -> remove_item(I, ##__VA_ARGS__)
#define index_of(I,...)             ftableI(I) -> index_of(I, ##__VA_ARGS__)
#define item_of(I,...)              ftableI(I) -> item_of(I, ##__VA_ARGS__)
#define build(I,...)                ftableI(I) -> build(I, ##__VA_ARGS__)
#define write(I,...)                ftableI(I) -> write(I, ##__VA_ARGS__)
#define parse(I,...)                ftableI(I) -> parse(I, ##__VA_ARGS__)
#define reserve(I,...)              ftableI(I) -> reserve(I, ##__VA_ARGS__)
#define hash(I,...)                 ftableI(I) -> hash(I, ##__VA_ARGS__)
#define invoke(I,...)               ftableI(I) -> invoke(I, ##__VA_ARGS__)
#define filename(I,...)             ftableI(I) -> filename(I, ##__VA_ARGS__)
#define directory(I,...)            ftableI(I) -> directory(I, ##__VA_ARGS__)
#define parent(I,...)               ftableI(I) -> parent(I, ##__VA_ARGS__)
#define ls(I,...)                   ftableI(I) -> ls(I, ##__VA_ARGS__)
#define is_empty(I,...)             ftableI(I) -> is_empty(I, ##__VA_ARGS__)
#define is_dir(I,...)               ftableI(I) -> is_dir(I, ##__VA_ARGS__)
#define make_dir(I,...)             ftableI(I) -> make_dir(I, ##__VA_ARGS__)
#define cstring(I)                  cast(I, cstr)
#define stem(I,...)                 ftableI(I) -> stem(I, ##__VA_ARGS__)
#define ext(I,...)                  ftableI(I) -> ext(I, ##__VA_ARGS__)
#define element(I,...)              ftableI(I) -> element(I, ##__VA_ARGS__)
#define resolve(I,...)              ftableI(I) -> resolve(I, ##__VA_ARGS__)
#define call(I,N,...)               ftableI(I) -> N(I, ##__VA_ARGS__)
#define call0(I,N,...)              ftableI(I) -> N(I, ##__VA_ARGS__)
#define val(T,V)                    A_primitive(typeid(T), (&(T){V}))
#define idx_1(I,T1,V1)              call0(I, index ##_## T1, V1)
#define idx_2(I,T1,T2,V1,V2)        call0(I, index ##_## T1 ##_## T2, V1, V2)
#define idx(I,V1)                   call0(I, index ##_## num, V1)
#define cast(I,T)                   ftableI(I) -> cast_##T(I)
#define meta_t(I,IDX)               isa(I) -> meta.meta_##IDX
#define ctr(T,WITH,...)             A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, true), ## __VA_ARGS__))
#define ctr1(T,WITH,...)            A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, true), ## __VA_ARGS__))
#define alloc_ctr(T,WITH,...)       A_initialize(T##_type.with_##WITH(A_alloc(typeid(T), 1, false), ## __VA_ARGS__))
#define str(CSTR)                   string_type.with_cstr(A_alloc(&string_type, 1, true), (cstr)(CSTR))
#define operator(I,OP,...)          ftableI(I) -> operator_##OP(I, ##__VA_ARGS__)

/// arg expansion for type emission (give address of its statically defined)
#define emit_types(...)             EXPAND_ARGS(__VA_ARGS__)
#define combine_tokens_(A, B)       A##B
#define combine_tokens(A, B)        combine_tokens_(A, B)
#define EXPAND_ARGS(...)            EXPAND_ARGS_HELPER(COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
#define EXPAND_ARGS_HELPER(N, ...)  combine_tokens(EXPAND_ARGS_, N)(__VA_ARGS__)
#define EXPAND_ARGS_0()                         0
#define EXPAND_ARGS_1(a)                        1, &a##_type
#define EXPAND_ARGS_2(a, b)                     2, &a##_type, &b##_type
#define EXPAND_ARGS_3(a, b, c)                  3, &a##_type, &b##_type, &c##_type
#define EXPAND_ARGS_4(a, b, c, d)               4, &a##_type, &b##_type, &c##_type, &d##_type
#define EXPAND_ARGS_5(a, b, c, d, e)            5, &a##_type, &b##_type, &c##_type, &d##_type, &e##_type
#define EXPAND_ARGS_6(a, b, c, d, e, f)         6, &a##_type, &b##_type, &c##_type, &d##_type, &e##_type, &f##_type
#define EXPAND_ARGS_7(a, b, c, d, e, f, g)      7, &a##_type, &b##_type, &c##_type, &d##_type, &e##_type, &f##_type, &g##_type
#define EXPAND_ARGS_8(a, b, c, d, e, f, g, h)          8,  &a##_type, &b##_type, &c##_type, &d##_type, &e##_type, &f##_type, &g##_type, &h##_type
#define EXPAND_ARGS_9(a, b, c, d, e, f, g, h, ii)       9,  &a##_type, &b##_type, &c##_type, &d##_type, &e##_type, &f##_type, &g##_type, &h##_type, &ii##_type
#define EXPAND_ARGS_10(a, b, c, d, e, f, g, h, ii, j)   10, &a##_type, &b##_type, &c##_type, &d##_type, &e##_type, &f##_type, &g##_type, &h##_type, &ii##_type, &j##_type
#define COUNT_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define COUNT_ARGS(...)             COUNT_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

//#define EXPAND_ARGS2_0()                       
#define EXPAND_ARGS2_1(a)                        a
#define EXPAND_ARGS2_2(a, b)                     a##_##b
#define EXPAND_ARGS2_3(a, b, c)                  a##_##b##_##c
#define EXPAND_ARGS2_4(a, b, c, d)               a##_##b##_##c##_##d
#define EXPAND_ARGS2_5(a, b, c, d, e)            a##_##b##_##c##_##d##_e
#define EXPAND_ARGS2_6(a, b, c, d, e, f)         a##_##b##_##c##_##d##_e##_##f
#define EXPAND_ARGS2_7(a, b, c, d, e, f, g)      a##_##b##_##c##_##d##_e##_##f##_##g
#define EXPAND_ARGS2_8(a, b, c, d, e, f, g, h)   a##_##b##_##c##_##d##_e##_##f##_##g##_##h
#define emit_idx_symbol(...)             EXPAND_ARGS2(__VA_ARGS__)
#define EXPAND_ARGS2(...)            EXPAND_ARGS_HELPER2(COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
#define EXPAND_ARGS_HELPER2(N, ...)  combine_tokens(EXPAND_ARGS2_, N)(__VA_ARGS__)


#define   i_ctr_public_INST(X, ARG)
#define   i_ctr_public_INTERN(X, ARG)
#define   i_ctr_public_ISIZE(X, ARG)
#define   i_ctr_public_DECL(X, ARG)
#define   i_ctr_public_INIT(X, ARG) \
    X##_type.with_##ARG = & X##_with_##ARG; \
    X##_type.members[X##_type.member_count].name        = stringify(with_##ARG); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { emit_types(ARG) }; \
    X##_type.members[X##_type.member_count].type        = &ARG##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, with_##ARG); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_CONSTRUCT; \
    X##_type.member_count++;  
#define   i_ctr_public_PROTO(X, ARG)
#define   i_ctr_public_METHOD(X, ARG)      X (*with_##ARG)(X, ARG);
#define   i_ctr_intern_INST(X, ARG)
#define   i_ctr_intern_INTERN(X, ARG)
#define   i_ctr_intern_ISIZE(X, ARG)
#define   i_ctr_intern_INIT(X, ARG) 
#define   i_ctr_intern_PROTO(X, ARG)
#define   i_ctr_intern_METHOD(X, ARG)
#define   i_ctr(X, Y, T, ARG)              i_ctr_##T##_##Y(X, ARG)


#define   i_prop_public_INST(X, R, N)         R N;  
#define   i_prop_public_INTERN(X, R, N) 
#define   i_prop_public_ISIZE(X, R, N)        
#define   i_prop_public_DECL(X, R, N)
#define   i_prop_public_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].name     = #N; \
    X##_type.members[X##_type.member_count].offset   = offsetof(struct X, N); \
    X##_type.members[X##_type.member_count].type     = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_PROP; \
    X##_type.member_count++;
#define   i_prop_public_PROTO(X, R, N)  
#define   i_prop_public_METHOD(X, R, N)

#define   i_prop_required_INST(X, R, N)         i_prop_public_INST(X, R, N)
#define   i_prop_required_INTERN(X, R, N)
#define   i_prop_required_ISIZE(X, R, N)        
#define   i_prop_required_DECL(X, R, N)
#define   i_prop_required_INIT(X, R, N) \
    X##_type.members[X##_type.member_count].required = true; \
    i_prop_public_INIT(X, R, N)
#define   i_prop_required_PROTO(X, R, N)  
#define   i_prop_required_METHOD(X, R, N)

#define   i_prop_intern_INST(X, R, N)          
#define   i_prop_intern_INTERN(X, R, N)         R N;
#define   i_prop_intern_ISIZE(X, R, N)          +sizeof(void*)
#define   i_prop_intern_DECL(X, R, N)
#define   i_prop_intern_INIT(X, R, N)
#define   i_prop_intern_PROTO(X, R, N)  
#define   i_prop_intern_METHOD(X, R, N)  
#define   i_prop(X, Y, T, R, N) i_prop_##T##_##Y(X, R, N)

#define   s_method_public_INST(X, R, N, ...)
#define   s_method_public_INTERN(X, R, N, ...)
#define   s_method_public_ISIZE(X, R, N)          
#define   s_method_public_DECL(X, R, N, ...)       R X##_##N(__VA_ARGS__);
#define   s_method_public_INIT(X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_SMETHOD; \
    X##_type.member_count++;   
#define   s_method_public_PROTO(X, R, N, ...)
#define   s_method_public_METHOD(X, R, N, ...)    R (*N)(__VA_ARGS__);

#define   s_method_intern_INST(X, R, N, ...)
#define   s_method_intern_INTERN(X, R, N, ...)
#define   s_method_intern_ISIZE(X, R, N, ...)
#define   s_method_intern_DECL(X, R, N, ...)
#define   s_method_intern_INIT(X, R, N, ...)      
#define   s_method_intern_PROTO(X, R, N, ...)
#define   s_method_intern_METHOD(X, R, N, ...)    
#define   s_method(X, Y, T, R, N, ...)            s_method_##T##_##Y(X, R, N, ##__VA_ARGS__)

#define   i_method_public_INST(    X, R, N, ...)
#define   i_method_public_INTERN(  X, R, N, ...)
#define   i_method_public_ISIZE(  X, R, N, ...)
#define   i_method_public_DECL(    X, R, N, ...)    R X##_##N(__VA_ARGS__);
#define   i_method_public_INIT(    X, R, N, ...) \
    X##_type . N = & X## _ ## N; \
    X##_type.members[X##_type.member_count].name    = #N; \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X, ##__VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, N); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_IMETHOD; \
    X##_type.member_count++;
#define   i_method_public_PROTO(X, R, N, ...)
#define   i_method_public_METHOD(X, R, N, ...)      R (*N)(__VA_ARGS__);

#define   i_method_intern_INST(    X, R, N, ...)
#define   i_method_intern_INTERN(  X, R, N, ...)
#define   i_method_intern_ISIZE(  X, R, N, ...)
#define   i_method_intern_DECL(    X, R, N, ...)
#define   i_method_intern_INIT(    X, R, N, ...)    
#define   i_method_intern_PROTO(X, R, N, ...)
#define   i_method_intern_METHOD(X, R, N, ...)      
#define   i_method(X, Y, T, R, N, ...)              i_method_##T##_##Y(X, R, N, X, ##__VA_ARGS__)

#define   i_operator_public_INST(X, R, N, ARG)
#define   i_operator_public_INTERN(X, R, N, ARG)
#define   i_operator_public_ISIZE(X, R, N, ARG)
#define   i_operator_public_DECL(X, R, N, ARG)
#define   i_operator_public_INIT(X, R, N, ARG) \
    X##_type  . operator_##N = & X## _operator_ ## N; \
    X##_type.members[X##_type.member_count].name    = stringify(combine_tokens(operator_, N)); \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X, ARG) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, operator_##N); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_OPERATOR; \
    X##_type.members[X##_type.member_count].operator_type = OPType_ ## N; \
    X##_type.member_count++; 
#define   i_operator_public_PROTO(X, R, N, ARG)
#define   i_operator_public_METHOD(X, R, N, ARG)    R (*operator_ ## N)(X, ARG);

#define   i_operator_intern_INST(X, R, N, ARG)
#define   i_operator_intern_INTERN(X, R, N, ARG)
#define   i_operator_intern_ISIZE(X, R, N, ARG)
#define   i_operator_intern_DECL(X, R, N, ARG)
#define   i_operator_intern_INIT(X, R, N, ARG)      
#define   i_operator_intern_PROTO(X, R, N, ARG)
#define   i_operator_intern_METHOD(X, R, N, ARG)    
#define   i_operator(X, Y, T, R, N, ARG)            i_operator_##T##_##Y(X, R, N, ARG)

#define   i_cast_public_INST(X, R)
#define   i_cast_public_INTERN(X, R)
#define   i_cast_public_ISIZE(X, R)
#define   i_cast_public_DECL(X, R)
#define   i_cast_public_INIT(X, R) \
    X##_type.cast_##R = & X##_cast_##R; \
    X##_type.members[X##_type.member_count].name    = stringify(combine_tokens(cast_, R)); \
    X##_type.members[X##_type.member_count].args    = (meta_t) { emit_types(X) }; \
    X##_type.members[X##_type.member_count].type    = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset  = offsetof(X##_f, cast_##R); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_CAST; \
    X##_type.member_count++;  
#define   i_cast_public_PROTO(X, R)
#define   i_cast_public_METHOD(X, R)        R (*cast_##R)(X);

#define   i_cast_intern_INST(X, R)
#define   i_cast_intern_INTERN(X, R)
#define   i_cast_intern_ISIZE(X, R)
#define   i_cast_intern_DECL(X, R)
#define   i_cast_intern_INIT(X, R)          
#define   i_cast_intern_PROTO(X, R)
#define   i_cast_intern_METHOD(X, R)        
#define   i_cast(X, Y, T, R)                i_cast_##T##_##Y(X, R)

#define   i_index_public_INST(X, R, ...)
#define   i_index_public_INTERN(X, R, ...)
#define   i_index_public_ISIZE(X, R, ...)
#define   i_index_public_DECL(X, R, ...)
#define   i_index_public_INIT(X, R, ...) \
    X##_type.emit_idx_symbol(index, __VA_ARGS__) = & emit_idx_symbol(X ## _index, __VA_ARGS__); \
    X##_type.members[X##_type.member_count].name        = stringify(emit_idx_symbol(index, __VA_ARGS__)); \
    X##_type.members[X##_type.member_count].args        = (meta_t) { emit_types(X, __VA_ARGS__) }; \
    X##_type.members[X##_type.member_count].type        = (AType)&R##_type; \
    X##_type.members[X##_type.member_count].offset      = offsetof(X##_f, emit_idx_symbol(index, __VA_ARGS__)); \
    X##_type.members[X##_type.member_count].member_type = A_TYPE_INDEX; \
    X##_type.member_count++;  
#define i_index_public_PROTO(X, R, ...)
#define i_index_public_METHOD(X, R, ...)                R (*emit_idx_symbol(index,__VA_ARGS__))(X, ##__VA_ARGS__);

#define i_index_intern_INST(X, R, ...)
#define i_index_intern_INTERN(X, R, ...)
#define i_index_intern_ISIZE(X, R, ...)
#define i_index_intern_DECL(X, R, ...)
#define i_index_intern_INIT(X, R, ...)
#define i_index_intern_PROTO(X, R, ...)
#define i_index_intern_METHOD(X, R, ...)                R (*emit_idx_symbol(index, __VA_ARGS__))(X, ##__VA_ARGS__);
#define i_index(X, Y, T, R, ...)                        i_index_##T##_##Y(X, R, ##__VA_ARGS__)

#define i_vargs_public_INST(X, R, N, ...)
#define i_vargs_public_INTERN(X, R, N, ...)
#define i_vargs_public_ISIZE(X, R, N, ...)
#define i_vargs_public_ISIZE(X, R, N, ...)
#define i_vargs_public_DECL(X, R, N, ...)
#define i_vargs_public_INIT(X, R, N, ...)               i_method_public_INIT(X, R, N, __VA_ARGS__)  
#define i_vargs_public_PROTO(X, R, N, ...)
#define i_vargs_public_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);

#define i_vargs_intern_INST(X, R, N, ...)
#define i_vargs_intern_INTERN(X, R, N, ...)
#define i_vargs_intern_ISIZE(X, R, N, ...)
#define i_vargs_intern_DECL(X, R, N, ...)
#define i_vargs_intern_INIT(X, R, N, ...)               i_method_intern_INIT(X, R, N, __VA_ARGS__)  
#define i_vargs_intern_PROTO(X, R, N, ...)
#define i_vargs_intern_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);
#define i_vargs(X, Y, T, R, N, ...)                     i_vargs_##T##_##Y(X, R, N, __VA_ARGS__)

#define s_vargs_public_INST(X, R, N, ...)
#define s_vargs_public_INTERN(X, R, N, ...)
#define s_vargs_public_ISIZE(X, R, N, ...)
#define s_vargs_public_DECL(X, R, N, ...)               R X##_##N(__VA_ARGS__, ...);
#define s_vargs_public_INIT(X, R, N, ...)               s_method_public_INIT(X, R, N, ##__VA_ARGS__)
#define s_vargs_public_PROTO(X, R, N, ...)
#define s_vargs_public_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);

#define s_vargs_intern_INST(X, R, N, ...)
#define s_vargs_intern_INTERN(X, R, N, ...)
#define s_vargs_intern_ISIZE(X, R, N, ...)
#define s_vargs_intern_INIT(X, R, N, ...)               s_method_intern_INIT(X, R, N, ##__VA_ARGS__)
#define s_vargs_intern_PROTO(X, R, N, ...)
#define s_vargs_intern_METHOD(X, R, N, ...)             R (*N)(__VA_ARGS__, ...);
#define s_vargs(X, Y, T, R, N, ...)                     s_vargs_##T##_##Y(X, R, N, ##__VA_ARGS__)

#define i_override_method_INST(X, N)
#define i_override_method_INTERN(X, N)
#define i_override_method_ISIZE(X, N)
#define i_override_method_DECL(X, N)
#define i_override_method_INIT(X, N) \
    X##_type . N = & X## _ ## N;

#define i_override_method_PROTO(X, N)
#define i_override_method_METHOD(X, N)

#define i_override_ctr_INST(X, R)
#define i_override_ctr_INTERN(X, N)
#define i_override_ctr_ISIZE(X, N)
#define i_override_ctr_DECL(X, R)
#define i_override_ctr_INIT(X, R)                       X##_type . with_##R = & X##_with_##R;
#define i_override_ctr_PROTO(X, R)
#define i_override_ctr_METHOD(X, R)

#define i_override_cast_INST(X, R)
#define i_override_cast_INTERN(X, R)
#define i_override_cast_ISIZE(X, R)
#define i_override_cast_DECL(X, R)
#define i_override_cast_INIT(X, R)                      X##_type . cast_##R = & X##_cast_##R;
#define i_override_cast_PROTO(X, R)
#define i_override_cast_METHOD(X, R)

#define i_override_idx_INST(X, R)
#define i_override_idx_INTERN(X, R)
#define i_override_idx_ISIZE(X, R)
#define i_override_idx_DECL(X, R)
#define i_override_idx_INIT(X, R)                    X##_type . idx_##R = & X##_idx_##R;
#define i_override_idx_PROTO(X, R)
#define i_override_idx_METHOD(X, R)

#define i_override(X, Y, OT, N)                        i_override_##OT##_##Y(X, N)

#include <A-type>

typedef struct method_t {
    struct array*   atypes;
    struct A_f*     rtype;
    void*           address;
    void*           ffi_cif;  /// ffi-calling info
    void*           ffi_args; /// ffi-data types for args
} method_t;

#define A_f_members(B) \
    struct B ## _f* parent_type; \
    char*           name; \
    char*           module; \
    int             size; \
    int             member_count; \
    type_member_t*  members; \
    int             traits; \
    AType           src; \
    void*           arb; \
    meta_t          meta; \

#define intern(X)  X##_schema(X, INTERN)
/// this gives you a kind of design-time check for intern access,  i suppose..
/// however we would need to emit it in both cases
#define  isize(X) u8 __##X##_intern[0 X##_schema(X, ISIZE)];

#define declare_base( X ) \
    typedef struct X* X; \
    _Pragma("pack(push, 1)") \
    typedef struct X { \
        X##_schema (X, INST) \
        X##_intern \
        struct X##_f* f; \
    } *X; \
    X##_schema (X, DECL) \
    typedef struct X##_f { \
        A_f_members(A) \
        X##_schema (X, METHOD) \
    } X##_f; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define declare_meta(AA, SRC ) \
    typedef struct SRC* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct AA##_f { \
        A_f_members(SRC) \
        A_schema     (A,  METHOD) \
        SRC##_schema (AA, METHOD) \
    } AA##_f, *AA##_ft; \
    _Pragma("pack(pop)") \
    extern AA##_f AA##_type;


#define declare_abstract( X ) \
    typedef struct X *X; \
    _Pragma("pack(push, 1)") \
    typedef struct X##_f { \
        A_f_members(A) \
        A_schema(A, METHOD) \
        X##_schema(X, METHOD) \
    } X##_f, *X##_ft; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define declare_primitive( X, Y ) \
    _Pragma("pack(push, 1)") \
    typedef struct X##_f { \
        A_f_members(A) \
        A_schema(A, METHOD) \
        X##_schema(X, METHOD) \
    } X##_f, *X##_ft; \
    _Pragma("pack(pop)") \
    extern X##_f X##_type;


#define ENUM_COUNT(...)  (sizeof((int[]){__VA_ARGS__}) / sizeof(int))

#define declare_enum( E ) \
    typedef enum E { \
        E##_schema(E, DECL) \
    } E; \
    _Pragma("pack(push, 1)") \
    typedef struct E##_f { \
        A_f_members(A) \
        A_schema   (E, METHOD) \
    } E##_f, *E##_ft; \
    _Pragma("pack(pop)") \
    enum { E##_ENUM_COUNT = ENUM_COUNT(E##_schema(E, COUNT)) }; \
    extern E##_f   E##_type;

void A_push_type(AType type);

void        A_lazy_init(global_init_fn fn);

#define define_enum( E ) \
    _Pragma("pack(push, 1)") \
    struct A  E ## _redirect; \
    E ## _f   E ## _type; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool global_##E() { \
        memset(&E ## _redirect, 0, sizeof(E ## _redirect)); \
        E ## _redirect.type = &E ## _type; \
        E ## _f* type_ref = &E ## _type; \
        A_f* base_ref     = &A_type; \
        if ((AType)type_ref != (AType)base_ref && base_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##E); \
            return false; \
        } else { \
            memcpy(type_ref, base_ref, sizeof(A_f)); \
            static type_member_t members[16 + E##_ENUM_COUNT + sizeof(E##_type) / sizeof(void*)]; \
            memset(&E##_type, 0, sizeof(E##_type)); \
            E##_type.parent_type = & A_type;        \
            E##_type.name     = #E;                 \
            E##_type.module   = MODULE;             \
            E##_type.size     = sizeof(enum E);     \
            E##_type.members  = members;            \
            E##_type.member_count = 0;              \
            E##_type.traits   = A_TRAIT_ENUM;       \
            E##_type.arb      = primitive_ffi_arb(typeid(i32)); \
            E##_schema( E, IMPL ); \
            A_push_type(&E##_type); \
            return true; \
        } \
    }


/// expand structure definitions for polymorphic types
/// usage: declare_class(Top, Middle, Base);
#define declare_class(AA) \
    typedef struct AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct AA { \
        AA##_schema (AA, INST) AA##_intern \
        struct AA##_f* f; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct AA##_f { \
        A_f_members(BB) \
        A_schema(A, METHOD) \
        AA##_schema (AA, METHOD) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

/// expand structure definitions for polymorphic types
/// usage: declare_mod(Top, Middle, Base);
#define declare_mod(AA, BB, ...) \
    declare_subclass_ex(AA, BB, dm_count(AA, BB, ## __VA_ARGS__), AA, BB, ## __VA_ARGS__)

#define declare_subclass_ex(AA, BB, N, ...) \
    typedef struct AA* AA; \
    _Pragma("pack(push, 1)") \
    typedef struct AA { \
        _COMBINE(dm_f_, N)(__VA_ARGS__) \
        struct AA##_f* f; \
    } *AA; \
    AA##_schema (AA, DECL) \
    typedef struct AA##_f { \
        A_f_members(BB) \
        A_schema(A, METHOD) \
        _COMBINE(dm_i_, N)(__VA_ARGS__) \
    } AA##_f, *AA##_ft; \
    extern AA##_f   AA##_type; \
    _Pragma("pack(pop)")

#define dm_count_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define dm_count(...) dm_count_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

/// six levels of sub-class should be fine --gates 1985 [not bill]
#define dm_f_1(A0)          A0##_schema (A0, INST) A0##_intern
#define dm_f_2(A0, A1)      dm_f_1(A1)     dm_f_1(A0)
#define dm_f_3(A0, A1, A2)  dm_f_2(A1, A2) dm_f_1(A0)

#define dm_f_4(A0, A1, A2, A3)          dm_f_2(A2, A3)          dm_f_2(A0, A1)
#define dm_f_5(A0, A1, A2, A3, A4)      dm_f_4(A1, A2, A3, A4)  dm_f_1(A0)
#define dm_f_6(A0, A1, A2, A3, A4, A5)  dm_f_4(A2, A3, A4, A5)  dm_f_2(A0, A1)

#define dm_i_1(A0) A0##_schema (A0, METHOD)

#define dm_i_2(A0, A1) dm_i_1(A1) dm_i_1(A0)

#define dm_i_3(A0, A1, A2)              dm_i_2(A1, A2)         dm_i_1(A0)
#define dm_i_4(A0, A1, A2, A3)          dm_i_2(A2, A3)         dm_i_2(A0, A1)
#define dm_i_5(A0, A1, A2, A3, A4)      dm_i_4(A1, A2, A3, A4) dm_i_1(A0)
#define dm_i_6(A0, A1, A2, A3, A4, A5)  dm_i_4(A2, A3, A4, A5) dm_i_2(A0, A1)


#define define_mod(A0, A1) \
    define_arb(A0, A1, sizeof(struct A0), 0, primitive_ffi_arb(typeid(cstr)))

#define define_class(A0) \
    define_mod(A0, A)

/// primitives dont have construct/method support, but its abstract does
#define define_primitive(X, Y, traits) \
    define_arb(X, Y, sizeof(X), traits | A_TRAIT_PRIMITIVE, primitive_ffi_arb(typeid(X)))

#define define_abstract(X) \
    define_arb(X, A, 0, A_TRAIT_ABSTRACT, null)

// lazy loading and copying of the table only requires knowledge of our parent class
#define define_arb(A0, A1, TYPE_SZ, TRAIT, FFI) \
    _Pragma("pack(push, 1)") \
    A       A0##_header; \
    A0##_f  A0##_type; \
    _Pragma("pack(pop)") \
    static __attribute__((constructor)) bool global_##A0() { \
        A0##_f* type_ref = &A0##_type; \
        A1##_f* base_ref = &A1##_type; \
        if ((AType)type_ref != (AType)base_ref && (!base_ref->traits && !base_ref->size)) { \
            A_lazy_init((global_init_fn)&global_##A0); \
            return false; \
        } else { \
            memset(type_ref, 0,        sizeof(A0##_f)); \
            memcpy(type_ref, base_ref, sizeof(A1##_f)); \
            static type_member_t members[16 + sizeof(A0##_type) / sizeof(void*)]; \
            A0## _type.parent_type = &A1##_type; \
            A0## _type.name     = #A0;       \
            A0## _type.module   = MODULE;    \
            A0## _type.members  = members;   \
            A0## _type.member_count = 0; \
            A0## _type.size     = TYPE_SZ;   \
            A0## _type.traits   = TRAIT;     \
            A0##_type.arb       = FFI;       \
            A0##_schema( A0, INIT )          \
            A_push_type(&A0##_type);         \
            return true;                     \
        }                                    \
    }


#define module_init(fn) \
    static bool _module_init() { \
        fn(); \
        return true; \
    } \
    static __attribute__((constructor)) void _module_register() { \
        A_module_init((global_init_fn)&_module_init); \
    }


void* primitive_ffi_arb(AType);


/// alias let us meta describe things without adding any code.  just a bit of cloning of the function table.  which is definitely bloat
/// however we can reduce 
/// in this case, array accepts meta types and based on the instance's 
/// type it will use these to filter the list and throw assertions when 
/// an incompatible type is seen

/// so this introduces some new programming for us, in that our types are 
/// defined as optional meta's in series.  Its very useful to anyone who wants to
/// keep codesize down.  silver output can use pointers directly to the table when we cast

/// define_meta(array, ListOfNumerics, u8, u16, u32, u64, i8, i16, i32, i64)

#define define_meta(ALIAS_TYPE, SRC_TYPE, ...) \
    A              ALIAS_TYPE##_header; \
    ALIAS_TYPE##_f ALIAS_TYPE##_type; \
    static __attribute__((constructor)) bool global_##ALIAS_TYPE() { \
        ALIAS_TYPE##_f* type_ref = &ALIAS_TYPE##_type; \
        SRC_TYPE##_f* src_ref = &SRC_TYPE##_type; \
        if (src_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##ALIAS_TYPE); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(ALIAS_TYPE##_f)); \
            memcpy(&ALIAS_TYPE##_type, &SRC_TYPE##_type, sizeof(SRC_TYPE##_f)); \
            ALIAS_TYPE##_type.name     = #ALIAS_TYPE; \
            ALIAS_TYPE##_type.src      = &SRC_TYPE##_type; \
            ALIAS_TYPE##_type.meta     = (meta_t) { emit_types(__VA_ARGS__) }; \
            ALIAS_TYPE##_type.traits   = A_TRAIT_ALIAS; \
            A_push_type(&ALIAS_TYPE##_type);         \
            return true; \
        } \
    }

#define define_alias(ALIAS_TYPE, SRC_TYPE) \
    A              ALIAS_TYPE##_header; \
    ALIAS_TYPE##_f ALIAS_TYPE##_type; \
    static __attribute__((constructor)) bool global_##ALIAS_TYPE() { \
        ALIAS_TYPE##_f* type_ref = &ALIAS_TYPE##_type; \
        SRC_TYPE##_f* src_ref = &SRC_TYPE##_type; \
        if (src_ref->size == 0) { \
            A_lazy_init((global_init_fn)&global_##ALIAS_TYPE); \
            return false; \
        } else { \
            memset(type_ref, 0, sizeof(ALIAS_TYPE##_f)); \
            memcpy(&ALIAS_TYPE##_type, &SRC_TYPE##_type, sizeof(SRC_TYPE##_f)); \
            ALIAS_TYPE##_type.name     = #ALIAS_TYPE; \
            ALIAS_TYPE##_type.src      = &SRC_TYPE##_type; \
            ALIAS_TYPE##_type.traits   = A_TRAIT_ALIAS; \
            A_push_type(&ALIAS_TYPE##_type);         \
            return true; \
        } \
    }

typedef struct string* string;

/// constructors get a type forwarded from the construct macro
#define A_schema(X,Y) \
    i_prop  (X,Y, public, AType,     type) \
    i_prop  (X,Y, public, num,       refs) \
    i_prop  (X,Y, public, num,       ar_index) \
    i_prop  (X,Y, public, A,         data) \
    i_prop  (X,Y, public, num,       alloc) \
    i_prop  (X,Y, public, num,       count) \
    i_prop  (X,Y, public, A,         origin) \
    i_method(X,Y, public, none,      init) \
    i_method(X,Y, public, none,      destructor) \
    i_method(X,Y, public, i32,       compare,    X) \
    i_method(X,Y, public, u64,       hash) \
    i_method(X,Y, public, A,         copy) \
    i_ctr(   X,Y, public, cereal) \
    i_cast(  X,Y, public, string) \
    i_cast(  X,Y, public, bool)
#ifndef A_intern
#define A_intern
#endif
declare_base(A)

_Pragma("pack(push, 1)") \
typedef struct object_f {
    A_f_members(A)
    A_schema   (A,  METHOD)
} object_f, *object_ft;
extern object_f object_type;
 _Pragma("pack(pop)") \

#define typeid(X) ((AType)&X##_type)

#define numeric_schema(X,Y)
declare_abstract(numeric)

#define string_like_schema(X,Y)
declare_abstract(string_like)

#define nil_schema(X,Y)
declare_abstract(nil)

#define raw_schema(X,Y)
declare_abstract(raw)

#define ref_schema(X,Y)
declare_abstract(ref)

#define imported_schema(X,Y)
declare_abstract(imported)

/// our numeric primitives have their constructs defined
/// this is so we have a defined construction method for data conversion, we actually need it registered
/// we may optimize the need for it to be called in C99 output once working
#define i8_schema(X,Y)          numeric_schema(X,Y)
#define i16_schema(X,Y)         numeric_schema(X,Y)
#define i32_schema(X,Y)         numeric_schema(X,Y)
#define i64_schema(X,Y)         numeric_schema(X,Y)
#define u8_schema(X,Y)          numeric_schema(X,Y)
#define u16_schema(X,Y)         numeric_schema(X,Y)
#define u32_schema(X,Y)         numeric_schema(X,Y)
#define u64_schema(X,Y)         numeric_schema(X,Y)
#define f32_schema(X,Y)         numeric_schema(X,Y)
#define f64_schema(X,Y)         numeric_schema(X,Y)
#define f128_schema(X,Y)        numeric_schema(X,Y)
#define bool_schema(X,Y)        numeric_schema(X,Y)
#define num_schema(X,Y)         numeric_schema(X,Y)
#define sz_schema(X,Y)          numeric_schema(X,Y)
#define cstr_schema(X,Y)        string_like_schema(X,Y)
#define symbol_schema(X,Y)      string_like_schema(X,Y)
#define cereal_schema(X,Y)      string_like_schema(X,Y)
#define none_schema(X,Y)        nil_schema(X,Y)
#define raw_t_schema(X,Y)       raw_schema(X,Y)
#define handle_schema(X,Y)      raw_schema(X,Y)
#define AType_schema(X,Y)       raw_schema(X,Y)
#define Member_schema(X,Y)      raw_schema(X,Y)
#define ARef_schema(X,Y)        ref_schema(X,Y)

/// meta gives us access to one token we can override with (F)
declare_primitive( i8,          numeric)
declare_primitive(i16,          numeric)
declare_primitive(i32,          numeric)
declare_primitive(i64,          numeric)
declare_primitive( u8,          numeric)
declare_primitive(u16,          numeric)
declare_primitive(u32,          numeric)
declare_primitive(u64,          numeric)
declare_primitive(f32,          numeric)
declare_primitive(f64,          numeric)
declare_primitive(f128,         numeric)
declare_primitive(cstr,         string_like)
declare_primitive(symbol,       string_like)
declare_primitive(cereal,       string_like)
declare_primitive(bool,       numeric)
declare_primitive(none,         nil)
declare_primitive(num,          numeric)
declare_primitive(sz,           numeric)
declare_primitive(raw_t,        raw)
declare_primitive(handle,       raw)
/// whatever we can 'name', we can handle as a type of any pointer primitive
declare_primitive(AType,        raw)
declare_primitive(ARef,         ref)
declare_primitive(Member,       raw)

/// doubly-linked item type, integrated key so we dont also need a 'field' type
#define item_schema(X,Y) \
    i_prop    (X,Y, public, X,         next) \
    i_prop    (X,Y, public, X,         prev) \
    i_prop    (X,Y, public, A,         value) \
    i_prop    (X,Y, public, A,         key) \
    i_override(X,Y, method, hash)
#ifndef item_intern
#define item_intern
#endif        
declare_class(item)

/// linked-list of elemental data
#define list_schema(X,Y) \
    i_prop  (X,Y, public,    item,    first) \
    i_prop  (X,Y, public,    item,    last)  \
    i_prop  (X,Y, public,    i64,     count) \
    i_method(X,Y, public,    A,       pop) \
    i_method(X,Y, public,    item,    push, A) \
    i_method(X,Y, public,    num,     index_of, A) \
    i_method(X,Y, public,    item,     item_of, A) \
    i_method(X,Y, public,    none,    remove, num) \
    i_method(X,Y, public,    none,    remove_item, item) \
    i_method(X,Y, public,    A,       get,  A) \
    i_method(X,Y, public,    num,     count)
#ifndef list_intern
#define list_intern
#endif
declare_class(list)

/// array of elemental data
/// important to define the same operators here in silver definition of runtime
/// one has arguments (operator) and (cast) does not, thats always instance
/// we need different names for these.  they cannot both be considered 'operators'
/// we also need new data structure, so ops vs casts vs constructs vs methods
// += -= *= /= 
// ":", "+=", "-=", "*=", "/=", "|=",
// "&=", "^=", ">>=", "<<=", "%=", null);

typedef struct string* string;

#define OPType_schema(X,Y) \
    enum_value(X,Y, _add) \
    enum_value(X,Y, _sub) \
    enum_value(X,Y, _mul) \
    enum_value(X,Y, _div) \
    enum_value(X,Y, _or) \
    enum_value(X,Y, _and) \
    enum_value(X,Y, _xor) \
    enum_value(X,Y, _right) \
    enum_value(X,Y, _left) \
    enum_value(X,Y, _compare_equal) \
    enum_value(X,Y, _compare_not) \
    enum_value(X,Y, _is) \
    enum_value(X,Y, _inherits) \
    enum_value(X,Y, _assign) \
    enum_value(X,Y, _assign_add) \
    enum_value(X,Y, _assign_sub) \
    enum_value(X,Y, _assign_mul) \
    enum_value(X,Y, _assign_div) \
    enum_value(X,Y, _assign_or) \
    enum_value(X,Y, _assign_and) \
    enum_value(X,Y, _assign_xor) \
    enum_value(X,Y, _assign_right) \
    enum_value(X,Y, _assign_left) \
    enum_value(X,Y, _mod_assign)
declare_enum(OPType)

typedef struct path* path;

/// .m file is everything a module [body] needs without looking like what they ate onboard the Nebuchadnezzar
#define file_schema(X,Y) \
    i_method(X,Y, public,   bool, write, object) \
    i_method(X,Y, public,   bool, read,  AType) \
    i_method(X,Y, public,   none, close) \
    i_prop(X,Y,   required, path, src) \
    i_prop(X,Y,   public,   bool, read) \
    i_prop(X,Y,   public,   bool, write) \
    i_prop(X,Y,   intern,   int, f) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, destructor)
#ifndef file_intern
#define file_intern
#endif
declare_class(file)

typedef struct array* array;
#define path_schema(X,Y) \
    i_prop      (X,Y, public, cstr,   chars) \
    i_method    (X,Y, public, bool,   exists) \
    i_method    (X,Y, public, bool,   make_dir) \
    i_method    (X,Y, public, bool,   is_empty) \
    i_method    (X,Y, public, bool,   is_dir) \
    i_method    (X,Y, public, path,   directory) \
    i_method    (X,Y, public, string, stem) \
    i_method    (X,Y, public, string, ext) \
    i_method    (X,Y, public, string, filename) \
    i_method    (X,Y, public, path,   absolute) \
    i_method    (X,Y, public, path,   parent) \
    i_method    (X,Y, public, A,      read, AType) \
    i_method    (X,Y, public, path,   change_ext, cstr) \
    i_method    (X,Y, public, array,  ls, string, bool) \
    s_method    (X,Y, public, path,   cwd, sz) \
    i_ctr       (X,Y, public, string) \
    i_cast      (X,Y, public, cstr) \
    i_cast      (X,Y, public, sz) \
    i_override  (X,Y, ctr,    cereal) \
    i_override  (X,Y, method, hash) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, cast,   bool) \
    i_override  (X,Y, cast,   string)
#ifndef path_intern
#define path_intern
#endif
declare_class(path)

#define vector_schema(X,Y) \
    i_prop           (X,Y, public,   A,     data) \
    i_prop           (X,Y, required, i32,   alloc) \
    i_prop           (X,Y, public,   i32,   len) \
    i_prop           (X,Y, required, AType, type) \
    i_method         (X,Y, public, none,    push, A) \
    i_method         (X,Y, public, num,     count) \
    i_override       (X,Y, method, init) \
    i_override       (X,Y, cast,   bool)
#ifndef vector_intern
#define vector_intern
#endif
declare_class(vector)

#define subprocedure_schema(X,Y) \
    i_prop           (X,Y, required, object, target) \
    i_prop           (X,Y, public,   object, ctx) \
    i_prop           (X,Y, required, handle, addr) \
    i_method         (X,Y, public,   A, invoke, A)
#ifndef subprocedure_intern
#define subprocedure_intern
#endif
declare_class(subprocedure)

#define subproc(targ, faddr, context) new(subprocedure, target, targ, ctx, context, addr, faddr) 

#define array_schema(X,Y) \
    i_prop           (X,Y, public, ARef, elements) \
    i_prop           (X,Y, public, bool, unmanaged) \
    i_prop           (X,Y, public, i32,  alloc) \
    i_prop           (X,Y, public, i32,  len) \
    s_vargs          (X,Y, public, array,   of,             AType) \
    s_vargs          (X,Y, public, array,   of_cstr,        cstr) \
    i_method         (X,Y, public, A,       first) \
    i_method         (X,Y, public, A,       last) \
    i_method         (X,Y, public, A,       pop) \
    i_method         (X,Y, public, none,    remove,         num) \
    i_method         (X,Y, public, none,    remove_weak,    num) \
    i_method         (X,Y, public, none,    push,           A) \
    i_method         (X,Y, public, none,    push_weak,      A) \
    i_method         (X,Y, public, none,    clear) \
    i_method         (X,Y, public, none,    concat,         array) \
    i_method         (X,Y, public, A,       get,            num) \
    i_method         (X,Y, public, num,     count) \
    i_method         (X,Y, public, sz,      len) \
    i_method         (X,Y, public, num,     index_of,       A) \
    i_operator       (X,Y, public, none,    _assign_add,    A) \
    i_operator       (X,Y, public, none,    _assign_sub,    num) \
    i_vargs          (X,Y, public, none,    push_symbols,   X, cstr) \
    i_vargs          (X,Y, public, none,    push_objects,   X, A) \
    i_index          (X,Y, public, A,       num) \
    i_override       (X,Y, method, init) \
    i_override       (X,Y, cast,   bool)
#ifndef array_intern
#define array_intern
#endif
declare_class(array)

declare_meta(ATypes, array)

#define AF_schema(X,Y) \
    i_prop      (X,Y, public, array, pool) \
    i_prop      (X,Y, public, sz,    start_size) \
    s_method    (X,Y, public, AF,    fetch, num) \
    s_method    (X,Y, public, AF,    create, sz) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, method, destructor)
#ifndef AF_intern
#define AF_intern
#endif
declare_class(AF)

#define hashmap_schema(X,Y) \
    i_prop      (X,Y, public, list,  data) \
    i_prop      (X,Y, public, num,   alloc) \
    i_prop      (X,Y, public, num,   count) \
    i_method    (X,Y, public, none,  remove, A) \
    i_method    (X,Y, public, none,  set, A, A) \
    i_method    (X,Y, public, A,     get, A) \
    i_method    (X,Y, public, item,  fetch, A) \
    i_method    (X,Y, public, item,  lookup, A) \
    i_method    (X,Y, public, bool,  contains, A) \
    i_index     (X,Y, public, A, A) \
    i_override  (X,Y, cast,   string) \
    i_override  (X,Y, method, init) \
    i_override  (X,Y, cast,   bool)
#ifndef hashmap_intern
#define hashmap_intern
#endif

declare_class(hashmap)

#define pair_schema(X,Y) \
    i_prop      (X,Y, public, item,    ref) \
    i_prop      (X,Y, public, A,       key) \
    i_prop      (X,Y, public, A,       value)
#ifndef pair_intern
#define pair_intern
#endif
declare_class(pair)

extern int fault_level;
#define level_schema(X,Y) \
    enum_value(X,Y, info) \
    enum_value(X,Y, warn) \
    enum_value(X,Y, err)
declare_enum(level)

/// hmap stores the item, and our refs list has a value that holds that (origin = hmap)
#define map_schema(X,Y) \
    i_prop      (X,Y, intern,  hashmap,    hmap) \
    i_prop      (X,Y, public,  sz,         hsize) \
    i_method    (X,Y, public,  none,       set,        A, A) \
    i_method    (X,Y, public,  item,       fetch,      A) \
    i_method    (X,Y, public,  bool,       contains,   A) \
    i_method    (X,Y, public,  none,       concat,     map) \
    i_method    (X,Y, public,  sz,         len) \
    i_index     (X,Y, public,  A, sz) \
    i_index     (X,Y, public,  A, A) \
    i_override  (X,Y, method,  get) \
    i_override  (X,Y, method,  init) \
    i_override  (X,Y, cast,    string) \
    i_override  (X,Y, cast,    bool)
#ifndef map_intern
#define map_intern
#endif
declare_mod(map, list)

#define fn_schema(X,Y) \
    i_prop      (X,Y, intern, method_t*, method) \
    i_prop      (X,Y, public, A,         target) \
    i_prop      (X,Y, public, A,         context) \
    i_method    (X,Y, public, A,         call, array) \
    i_override  (X,Y, method,    hash)
#ifndef fn_intern
#define fn_intern
#endif
declare_class(fn)

#define string_schema(X,Y) \
    i_prop    (X,Y,   public, cstr,    chars) \
    i_prop    (X,Y,   public, num,     alloc) \
    i_prop    (X,Y,   public, num,     ref_length) \
    i_prop    (X,Y,   public, num,     len) \
    i_prop    (X,Y,   public, u64,     h) \
    i_method  (X,Y,   public, sz,      len) \
    i_method  (X,Y,   public, array,   split, cstr) \
    i_method  (X,Y,   public, num,     index_of, cstr) \
    i_method  (X,Y,   public, none,    append, cstr) \
    i_method  (X,Y,   public, string,  mid, num, num) \
    i_method  (X,Y,   public, none,    reserve, num) \
    i_method  (X,Y,   public, none,    write, handle, bool) \
    i_method  (X,Y,   public, bool,    has_suffix, cstr) \
    i_method  (X,Y,   public, num,     cmp, cstr) \
    i_method  (X,Y,   public, bool,    eq,  cstr) \
    i_cast    (X,Y,   public, cstr) \
    i_cast    (X,Y,   public, sz) \
    i_cast    (X,Y,   public, path) \
    i_ctr     (X,Y,   public, cstr) \
    i_index   (X,Y,   public, i32, num) \
    i_override(X,Y,   method, hash) \
    i_override(X,Y,   method, compare) \
    i_override(X,Y,   method, init) \
    i_override(X,Y,   cast,   bool) \
    i_override(X,Y,   method, copy)
#ifndef string_intern
#define string_intern
#endif
declare_class(string)

/// use %o to print objects, or % others -- octet is not a use-case we serve (use base-16 for that)
object A_formatter(AType rtype, FILE* f, bool write_ln, cstr template, ...);

#define Exists_schema(X,Y) \
    enum_value(X,Y, no) \
    enum_value(X,Y, file) \
    enum_value(X,Y, dir)
declare_enum(Exists)

#define         form(T, t, ...)   (T)A_formatter(typeid(T), null,   false, t, ## __VA_ARGS__)
#define       format(t, ...)      (string)A_formatter(null,      null,   false, t, ## __VA_ARGS__)
#define        print(t,    ...)   A_formatter(null,      stdout, true,  t, ## __VA_ARGS__)
#define        error(t, ...)      A_formatter(null,      stderr, true,  t, ## __VA_ARGS__)
#define        fault(t, ...) do { A_formatter(null,      stderr, true,  t, ## __VA_ARGS__); exit(1); } while(0)
#define  file_exists(t, ...)     (A_exists(A_formatter(null, null, false, t, ## __VA_ARGS__)) == Exists_file)
#define   dir_exists(t, ...)     (A_exists(A_formatter(null, null, false, t, ## __VA_ARGS__)) == Exists_dir)
#ifndef NDEBUG
#define       assert(a, t, ...) do { if (!(a)) { A_formatter(null, stderr, true,  t, ## __VA_ARGS__); exit(1); } } while(0)
#else
#define       assert(a, t, ...) do { } while(0)
#endif
#define       verify(a, t, ...) \
    do { \
        if (!(a)) { \
            A_formatter(null, stderr, true,  t, ## __VA_ARGS__); \
            if (level_err >= fault_level) { \
                raise(SIGSTOP); \
                exit(1); \
            } \
        } \
    } while(0)

/// we can iterate through a collection with this strange code
#define each(container, E, e) \
    if (len(container)) for (E e = get(container, 0), e0 = 0; e0 == 0; e0++) \
        for (num __i = 0, __len = len(container); __i < __len; __i++, e = get(container, __i)) \

/// we can go through a map
#define pairs(MM, EE) \
    if (MM && cast(MM, bool)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (pair EE = (pair)_i->value, e0 = EE; EE == e0; e0++) \

#define evalues(MM, TT, EE) \
    if (MM && cast(MM, bool)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (TT EE = ((pair)_i->value)->value, e0 = EE; EE == e0; e0++) \

#define ekeys(MM, TT, EE) \
    if (MM && cast(MM, bool)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (TT EE = ((pair)_i->value)->key, e0 = EE; EE == e0; e0++) \

#define pairs_(MM, EE) \
    if (MM && cast(MM, bool)) for (item _i = MM->first, EE = null; _i; _i = _i->next) \
        for (pair EE = (pair)_i->value, e0 = EE; EE == e0; e0++) \


/// possible to iterate safely through primitives
#define primitives(arr, E, e) \
    if (len(arr)) for (E e = *(E*)get(arr, 0), e0 = 0; e0 == 0; e0++) \
        for (num i = 0, __len = len(arr); i < __len; i++, e = *(E*)get(arr, i)) \

A           A_alloc(AType type, num count, bool af_pool);

/// we are not registering struct types because we have no idea of membership
/// however we may allocate based on their size
#define A_struct(T) A_alloc(typeid(u8), sizeof(struct T), true)

string      A_enum_string(AType type, i32 value);
i32         A_enum_value(AType type, cstr cs);
#define     estr(E,I) A_enum_string(typeid(E), I)
#define     eval(E,S) A_enum_value (typeid(E), S)

A           A_new(AType type);
A           A_construct(AType type, int n_args, ...);
A           A_initialize(A a); /// called after 'construction' ... this is so we do something generic in init, and support named args
A           A_convert(AType type, A input);
type_member_t* A_constructor(AType type, AType first_arg); // find a constructor method (used for dynamic construction)
A           A_instanceof(A left, AType type); // would be nice to actually allow typeid vs typeid here
A           A_hold(A a);
AType       A_lookup_type(cstr);
void        A_drop(A a);
sz          A_len(A a);
num         index_of_cstr(A a, cstr f);
Exists      A_exists(A a);
num         clamp(num i, num mn, num mx);
real        clampf(real, real, real);
#define     drop(a) A_drop(a)
#define     hold(a) A_hold(a)


/// should be adapted to work with schemas 
/// what a weird thing it would be to have map access to properties
/// everything should be A-based, and forget about the argument hacks?

map         A_args(int argc, symbol argv[], map default_values, object default_key);
AF          A_pool(sz size);
void        A_free(A a);
A_f**       A_types(num* length);
type_member_t* A_member(AType type, enum A_TYPE member_type, char* name);
A           A_method_call(method_t* a, array args);
A           A_method(AType type, char* method_name, array args);
A           A_method_vargs(A instance, cstr method_name, int n_args, ...);
fn          A_lambda(A target, type_member_t* member, A context);
A           A_call(A instance, type_member_t* member, array args);
A           A_primitive(AType type, void* data);
A           A_enum(AType enum_type, i32 value);
A           A_i8(i8);
A           A_u8(u8);
A           A_i16(i16);
A           A_u16(u16);
A           A_i32(i32);
A           A_u32(u32);
A           A_i64(i64);
A               i(i64);
A           A_sz(sz);
A           A_u64(u64);
A           A_f32(f32);
A           A_f64(f64);
A               f(f32);
A               r(f64);
A           A_cstr(cstr);
A           A_none();
A           A_bool(bool);
A           A_realloc(A, num);
void        A_push(A, A);
void        A_start();
A           A_fields(A instance);
A           A_data(A instance);
A           A_verify(A instance, AType type);
void        A_module_init(bool(*fn)());
void        debug();
void        br();
bool        A_reflect(symbol location);

bool      is_meta(A a);
bool      is_meta_compatible(A a, A b);

bool create_symlink(path target, path link);

/// todo: auto-release, no use of drop in most places
/// push_weak is probably a reasonable idea for array
map   map_of(cstr first_key, ...); /// cstr, A, ...
//array array_of(AType validate, ...);
//array array_of_cstr(cstr first, ...);
void  array_weak_push(array, A);

#endif